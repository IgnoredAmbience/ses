\documentclass[a4paper]{article}
\usepackage{color}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{wasysym}
\usepackage{xspace}
\usepackage{fullpage}
\usepackage{hyperref}
\usepackage{separationlogic}
\usepackage[english]{babel}
\usepackage[fixlanguage]{babelbib}

\begin{document}

\section{SES Syntax and Description}

\newcommand{\gds}[1]{\ifmmode \textbf{**** gds: }\textrm{#1}\textbf{****}\else
  \\\textbf{************************************}\\
  \textbf{gds: }#1\\\textbf{************************************}\\
  \fi}
\newcommand{\FIXME}[1]{~\vg\colorbox{red}{\textbf{FIXME:}}\textrm{ #1}\vg}
\newcommand{\TODO}[1]{~\vg\colorbox{yellow}{\textbf{TODO:}}\textrm{ #1}\vg}

\newcommand{\syntaxline}[3][\pipe]{#1 & \js{#2} & \textit{#3}\\}
\begin{display}{Syntax of SES values and expressions, $v, e$}
  $\begin{array}{rll}
    \syntaxline[v ::=]{$n$}{Number}
    \syntaxline{$s$}{String}
    \syntaxline{undefined}{Undefined}
    \syntaxline{null}{Null}
    \syntaxline[e ::=]{$v$}{Value}
    \syntaxline{$x$}{Identifier}
    \syntaxline{\{$x_1$:$e_1$, $\ldots$, $x_n$:$e_n$\}}{Object creation}
    \syntaxline{$e$; $e$}{Sequence}
    \syntaxline{$e \oplus e$}{Binary operator}
    \syntaxline{if($e$) \{$e$\} else \{$e$\}}{Conditional}
    \syntaxline{while($e$) \{$e$\}}{Looping}
    \syntaxline{var $x$}{Variable declaration}
    \syntaxline{$e$ = $e$}{Assignment}
    \syntaxline{$e$.$x$}{Member access}
    \syntaxline{$e$[$e$]}{Computed member access}
    \syntaxline{$e$($e$)}{Function call}
    \syntaxline{this}{this}
    \syntaxline{function($e$) \{$e$\}}{Function creation}
    \syntaxline{function $x$($e$) \{$e$\}}{Named function creation}
    \syntaxline{new $e$($e$)}{Object construction}
    \syntaxline{reval($e$, $e$)}{Restricted evaluation}
    \syntaxline{freeze($e$)}{Freeze}
    \syntaxline{def($e$)}{Recursive freeze}
  \end{array}$
\end{display}

An object is a location in the heap, it contains a set of
values indexed by fields.
For the purposes of this semantics, \js{null} and \js{undefined} behave
interchangably.
\gds{You say this, but then you don't mention \js{null} until you get to
  inference rules (where it'd better not be just like \js{undefined}), and you
  only mention \js{undefined} when talking about \js{this}. I think you just
  don't need that last sentence.}

\paragraph{Object creation}  The Object Construction syntax produces a new object
with fields named $x_1, \ldots, x_n$ which map to the values of expressions
$e_1, \ldots, e_n$ when evaluated in order at creation.

\paragraph{Sequence} The sequencing operator specifies that the expression on the left should be
evaluated, followed by the expresion on the right.

\paragraph{Binary operator} Binary operations are evaluated left-to-right, and includes standard
mathematical and string operations. Formalisation of semantics for all of these
are beyond the scope of this project, but will correspond closely to similar
works on the JavaScript family of languages.

\paragraph{Conditional} The conditional expression evaluates the first sub-expression, if it evaluates
to \js{true} under a boolean casting operation, the second sub-expression is
evaluated and result returned, otherwise the third sub-expression is evaluated
and result returned.
\gds{Be prepared to defend the lack of object-level casting. At the moment our
  simple semantics only cast primitive values.}

\paragraph{Looping} The looping expression executes the body sub-expression whilst the condition
sub-expression evaluates to true. The most-recently returned value of the body
is returned.
\gds{...or \js{undefined}}

\paragraph{Variable declaration} Variable declarations are used during activation
record creation to determine free-variables when constructing a new scope. They
are no-ops during evaluation. For simplicity of this specification, combined
declaration/assignment instructions are forbidden (they may be desugared to two
separate instructions during parsing).

\paragraph{Assignment} Assigns the value on the right hand side to the named
field on the left. Assignments to undeclared variables are forbidden (enforced
by the Variable rule), this is consistent with ES5-strict.

\paragraph{Member access} Returns the value of the named field of the object referenced by
the subexpression.

\paragraph{Computed member access} As Member access, but the field name is derived from
the expression in \js{[]}.

\paragraph{Function creation} Creates a function object, assigning the body, parameter
declarations and the current scope to internal fields. A new object is also
created and assigned to the \js{prototype} field for use as the prototype of
objects produced by using this function as a constructor (this permits
emulation of a class-based language).

\paragraph{Named function creation} This syntax is the same as standard function creation,
but also adds the name and a self-reference to the function to the function's
scope record. This permits recursive functions to be created. \emph{Note:} the
name of the function is not added to the current scope, it is permitted in the
actual language, but is considered to be syntactic sugar, combining creation and
assignment.

\paragraph{Function call} Executes the body of the function, using the passed expression
as the value to bind to the parameter. The body of the function is executed in
the scope stored with the function, any variables defined within the function
body are defined on an activation record so that they are lexically scoped.

\paragraph{Object construction} Constructs an object using the given function, an object
is created as usual, it's prototype is assigned to that of the function's
\js{prototype} field. The body of the function is then exectuted, commonly used
to initialize the newly created object.

% ES5-Strict definition, plus reval global - matches caja impl (and intuition).
\paragraph{\js{this}} The \js{this} expression is context-dependent. When used
outside of a
function, it should evaluate to the most global accessible scope.
When used within a function, if the function is called using Member Access, it
will evaluate to the object on which that function was called. Otherwise
(most likely function call directly via scope),
\js{this} returns undefined. Note that this is particularly
problematic because functions can easily be aliased off of the object on which
they appear to be defined.

\paragraph{Restricted evaluation} Parse the first given expression as SES code.
A new scope chain is prepared, its root is an activation record which
initializes any variables declared in the parsed source.
\FIXME{This isn't safe for our no-prototype chain requirement. Also, the
  imports aren't present in the restricted-global this expression. Consider
  change to copy fields across to AR}
\gds{I don't understand any of this fixme. I do think you've got the activation
  records the wrong way around in the description below though. The imports
  should be in the most global object. The untrusted code can choose to override
  the imports if it wishes.}
The object specified by the second parameter (the \emph{imports} to the
restricted environment) is then appended.
The return value of the restricted evaluation statement is the same as that of
the final statement of the source to be executed.

\paragraph{Freeze} Makes the provided object read-only, prevents field additions,
modifications and deletions.
Note that the ES5 spec has a bug, meaning that frozen fields on an object's
prototype are not permitted to be overridden\footnote{See
ses/repairES5.js\#makeTamperProof()}, some browsers opt to ``fix'' the spec bug.
This bug does not occur in these semantics.

\paragraph{Recursive freeze} Recursively calls freeze on all objects reachable
via user-defined fields from the given object.

\section{Operational Semantics}
\newcommand{\auxf}[2]{#1 & \triangleq & #2}
\begin{display}{Auxillary Functions}
  $\begin{array}{lcl}
  \auxf{\obj(l,l')}{l \pointsto \{@proto: l', @frozen: \false\}}\\
  \auxf{\istrue(v)}{v\not\in\{0,\emptystr,\nil,\und,\false\}}\\
  \auxf{\isfalse(v)}{v\in   \{0,\emptystr,\nil,\und,\false\}}\\
  \auxf{\fun(l',L,\js x,\js e,l)}{l'\mapsto\{@proto: \lfp, \js{prototype}:
    l, @scope: L, @body: \lambda \js{x.e}, @frozen: \false\}}\\
  \auxf{\objOrGlob(l)}{l}\\
  \auxf{\objOrGlob(v)}{\lop \quad v\not\in\loc}\\
  \auxf{\getBase(l,l')}{l'}\\
  \auxf{\getBase(l,v)}{v \quad v\not\in\loc}\\
  \auxf{\act(l,\js{x},v,\js{e},l'')}{l\pointsto\{\js{x}:
    v,@this: l'',@proto: \nil\}\sep \defs(\js{x},l,\js{e})}\\
  \auxf{\auxDef(H,l,s)}{H \qquad l \in s \lor l \not\in \loc}\\
  \auxf{\auxDef(H,l,s)}{\auxDef(H,,s \cup\{l\})[(l,@frozen) \mapsto \true]}
  \end{array}$
\end{display}
  \TODO{Some way of looping through (only user-def) fields on \auxDef}
  \FIXME{Need \scope, \proto, \getValue, \pickThis}

\begin{display}{Operational semantics: $H,L,\js e \evalsto H',v$}
  \FIXME{Use $\gevalsto$}
  Dereferencing notation: $H,L,\js{e} \gevalsto H',v \triangleq \exists r. (H,L,\js{e} \evalsto H',r \wedge \getValue(H',r) = v)$.
\vg

  \stateaxiom{(Value)}
    {H,L,v \evalsto H,v}
\vg

  \stateaxiom{(Variable declaration)}
  {H,L,\js{var x} \evalsto H,\und}
\vg

  \staterule{(Object creation)}
    {H_0 = H \sep \obj(l,\lop)\\
     \forall i\in 1..n \st \left(\begin{array}{l}
      H_{i-1},L,\js{ei}\evalsto H_i',v_i \\
      H_i = H_i' [ (l,\js{xi}) \pointsto v_i]\end{array}\right)}
    {H,L,\{\js{x1:e1},\dots, \js{xn:en}\} \evalsto H_n,l}
\vg

  \staterule{(Sequence)}
    {H,L,e_1 \evalsto H_1,v_1 \\
     H_1,L,e_2 \evalsto H',v}
    {H,L,e_1\js; e_2 \evalsto H',v}
\vg

  \staterule{(Binary operator)}
    {H,L,e_1 \evalsto H_1,v_1 \\
     H_1,L,e_2 \evalsto H',v_2\\
     v_1 \oplus v_2 = v}
    {H,L,e_1 \oplus e_2 \evalsto H',v}
\vg

  \staterule{(Conditional true)}
  {H,L,e_1 \evalsto H'',v' \quad \istrue(v') \\
   H'',L,e_2 \evalsto H',v}
  {H,L,\js{if($e_1$)\{$e_2$\} else \{$e_3$\}} \evalsto H',v}
\qquad

  \staterule{(Conditional false)}
  {H,L,e_1 \evalsto H'',v' \quad \isfalse(v') \\
   H'',L,e_3 \evalsto H',v}
  {H,L,\js{if($e_1$)\{$e_2$\} else \{$e_3$\}} \evalsto H',v}
\vg

  \staterule{(While true)}
  {H,L,e_1 \evalsto H'', v \quad \istrue(v) \\
   H'',L,e_2\js{; while($e_1$)\{$e_2$\}} \evalsto H', v''}
  {H,L,\js{while($e_1$)\{$e_2$\}} \evalsto H',\und}
\qquad

  \staterule{(While false)}
  {H,L,e_1 \evalsto H', v \quad \isfalse(v)}
  {H,L,\js{while($e_1$)\{$e_2$\}} \evalsto H',\und}
\vg\gds{\\This doesn't match your description of loops. You said it returned the last value, not always \und.}\vg

  % l' \neq \nil comdition given in ES5-8.7.2.3.a Strict-mode null SetValue (and
  % all-mode GetValue)
  \staterule{(Variable)}
    {\scope(H,L,x) = l' \quad l' \neq \nil}
    {H,L,\js x \evalsto H, \fld{l'}{x}}
\vg

  \staterule{(Member access)}
  {H,L,\js e \evalsto H',l' \\
   l' \neq \nil}
  {H,L,e\js{.}x \evalsto H', \fld{l'}{x}}
\qquad

  \staterule{(Computed member access)}
  {H,L,e_1 \evalsto H'',l' \\
   l' \neq \nil \\
   H'',L,e_2 \evalsto H', x}
  {H,L,e_1\js{[}e_2\js{]} \evalsto H',\fld{l'}{x}}
\vg

  \staterule{(Assignment)}
  {H,L,e_1 \evalsto H_1,\fld{l}{x} \qquad
   H_1(l, @frozen) \neq \true \\
   H_1,L,e_2 \evalsto H_2, v \\
   H' = H_2[(l,x) \pointsto v]}
  {H,L,e_1\js = e_2 \evalsto H', v}
\vg

  \staterule{(Function creation)}
  {H' = H \sep \obj(l,\lop) \sep \fun(l',L,x,e,l)}
  {H,L,\js{function($x$)\{$e$\}} \evalsto H',l'}
\vg

  \staterule{(Named function creation)}
  {H' = H \sep \obj(l,\lop) \sep \fun(l',l_1 \cons L,x,e,l) \sep l_1 \pointsto
    \{@proto:\nil, y:l'\}}
  {H,L,\js{function $y$($x$)\{$e$\}} \evalsto H',l'}
\vg

  \staterule{(Object construction)}
  {H,L,\js{e1} \evalsto H_1,{l_1} \qquad
   l_1\neq \nil\qquad
   H_1(l_1,@body)=\lambda \js{x.e3}\\
   H_1(l_1,@scope)= L'\qquad
   H_1(l_1,\js{prototype})= v\\
   H_1,L,\js{e2} \evalsto H_2,{v_1}  \qquad
   l_2 = \objOrGlob(v) \\
   H_3 = H_2\sep \obj(l_3,l_2) \sep\act(l,\js x,v_1,\js{e3},l_3)\\
   H_3,l \cons L',\js{e3} \evalsto H',v_2\qquad
   \getBase(l_3,v_2) = l'}
  {H,L,\js{new e1(e2)} \evalsto H',{l'}}
\vg

  \staterule{(Function call)}
  {H,L,\js{e1} \evalsto H_1,r_1\qquad
   \pickThis(H_1,{r_1})=l_2\qquad
   \getValue(H_1,r_1)=l_1\\
   H_1(l_1,@body)=\lambda \js{x.e3}\qquad
   H_1(l_1,@scope)= L'\\
   H_1,L,\js{e2} \evalsto H_2,{v}\\
   H_3 = H_2\sep\act(l,\js x,v,\js{e3},l_2) \\
   H_3,l \cons L',\js{e3} \evalsto H',{v'}}
  {H,L,\js{e1(e2)} \evalsto H',{v'}}
\vg

  \FIXME{Probably broken against definition}
  \staterule{(This)}
  {\scope(H,L,@this)=l_1 \\ \proto(H,l_1,@this)=l_2\\ H(l_2,@this)=l'}
  {H,L,\js{this} \evalsto H,l'}
\vg

  \FIXME{See description comment}
  \staterule{(Restricted evaluation)}
  {H,L,e_1 \evalsto H_1,v \qquad
   \parse(v) = e \\
   H_2 = H_1 \sep l \pointsto \{@this:l, @proto:\nil\} * \defs(x, l, e) \\
   H_2,L,e_2 \evalsto H_3, l' \\
   H_3, l' \cons [l], e \evalsto H',v }
  {H,L,\js{reval($e_1$, $e_2$)} \evalsto H',v}
\vg

  \staterule{(Freeze)}
  {H,L,e \gevalsto H'', l\\
   H' = H''[(l, @frozen) \pointsto \true]}
  {H,L,\js{freeze(e)} \evalsto H', l}
\vg

  \staterule{(Recursive freeze)}
  {H,L,\js{e} \gevalsto H'', l \\
   H' = \auxDef(H'', l, \{\})}
  {H,L,\js{def(e)} \evalsto H', l}
\end{display}

\subsection{Notes}
The semantics presented here are based on the ES3 program logic paper. I've
decided to use the scope chain as the scoping and heap accessibility model as I
think it quite neatly captures the functions-as-closures semantics of the
language.

Prototype chain traversal has become more irrelevant with the removal of the
\js{with} statement, the only place a normal object (with a prototype chain) is
placed into the scope chain is at the root, either as the global object $l_g$,
or as the `fake global' imports object during restricted execution. At all other
times, objects placed into the scope chain are controlled by the language, and
will \emph{never} have a prototype set.
\gds{\\
  \js{var super=\{x:1\} ; }\\
  \js{var f = function()\{\} ; }\\
  \js{f.prototype = super ; }\\
  \js{var ob = new f() ; } \\
  \js{ob.x ; // The prototype chain is traversed here}}

Dereferencing syntax has been modified to change the gamma arrows into a
dereferencing rule, this is used implicitly in all cases except for assignment,
where a reference is required to the object that holds the field. (It's a bit
annoying, apart from that, it could be dropped entirely, but that's the way it
is, even in the C++ languages also studied this year...)
Progress was
made between ES3 and ES5 to remove the need to represent references internally
(they were originally specified only as the result of an implementation
decision). According to Mark Miller, of the TC39 ES standardisation body,
references should no longer be needed in the ES5 spec and later revisions. As a
result of this information, they have been removed from this operational
semantics for simplification purposes.

The \js{def} function is definable in the full SES language using the
\js{for..each} construct. As this poses formalisation issues (non-determinism),
it has been decided to not model \js{for..each}, but \js{def} directly in the
operational semantics.

SES permits more granular properties than we model here. We only model
per-object freezing, SES permits this on a per-field basis. We also do not make
the distinction between data and accessor properties, (SES permits values of
accessor properties to be modified through the accessor after the object is
frozen). This choice may need to be reviewed at a later point.

\section{Program Logic}

\newcommand{\defline}[2]{#1 & \qquad & \text{#2}\\}
\begin{display}{Definitions}
  $\begin{array}{lll}
    \defline{h,h_g \in}{Abstract heap}
    \defline{h,h_g,L,\env \satisfies P}{Satisfaction relation}
    \defline{h[h']}{Heap $h$ updated to be consistent with heap $h'$}
    \defline{h[h'](x) \triangleq h'(x)}{iff $x \in \dom(h')$}
    \defline{h[h'](x) \triangleq h(x)}{otherwise}
    \defline{\tr{P}{\js{x}}{Q}}{Hoare triple}
  \end{array}$
\end{display}

\newcommand{\asrtline}[3][\pipe]{#1 & #2 & \text{#3}\\}
\begin{display}{Assertions}
  $\begin{array}{rll}
    \asrtline[P ::=]{P \land P \pipe P \lor P \pipe \lnot P \pipe \true \pipe
    \false}{Boolean formulae}
    \asrtline{P \sep P \pipe P \wand P \pipe P \sepish P}{Structural formulae}
    \asrtline{\upd P \pipe P \boxwand Q}{Global hypothesis formulae}
    \asrtline{(E,E) \pointsto E \pipe \lemp}{SES formulae}
    \asrtline{E \bp E}{Backpointer formula}
    \asrtline{E = E}{Expression equality}
  \end{array}$
\end{display}

\begin{display}{Assertion satisfaction relation}
  $\begin{array}{lcl}
    h,h_g,L,\env \satisfies \true \\
    h,h_g,L,\env \not\satisfies \false \\
    h,h_g,L,\env \satisfies P \land Q & \iff & (h,h_g,L,\env \satisfies
      P) \land (h,h_g,L,\env \satisfies Q) \\
    h,h_g,L,\env \satisfies P \lor Q & \iff & (h,h_g,L,\env \satisfies
      P) \lor (h,h_g,L,\env \satisfies Q) \\
    h,h_g,L,\env \satisfies \lnot P & \iff & \lnot(h,h_g,L,\env
      \satisfies P)\\
    h,h_g,L,\env \satisfies P \sep Q & \iff & \exists h_1,h_2 \st h \equiv h_1
      \sep h_2 \land (h_1,h_g,L,\env \satisfies P) \land (h_2,h_g,L,\env
      \satisfies Q) \\
    h,h_g,L,\env \satisfies P \sepish Q & \iff & \exists h_1,h_2,h_3 \st
      h \equiv h_1 \disju h_2 \disju h_3 \land {} \\
      && (h_1 \disju h_3, h_g, L, \env \satisfies P) \land
      (h_2 \disju h_3, h_g, L, \env \satisfies Q) \\
    h,h_g,L,\env \satisfies P \wand Q & \iff & \forall h' \st
      (h',h_g,L,\env \satisfies P) \land h \disj h' \land h' \subseteq h_g  \\
      & & \impl (h \disju h', h_g, L, \env \satisfies Q) \\
    %h,h_g,L,\env \satisfies \upd P & \iff & h, h_g[h], L, \env \satisfies P \\
    %h,h_g,L,\env \satisfies P?Q & \iff & h, h_g[h], L, \env \satisfies P \\
    %P \boxwand Q & \triangleq & P \wand P ? Q \\
    h,h_g,L,\env \satisfies P \boxwand Q & \iff &
      \forall h' \st (h',h_g[h'],L,\env \satisfies P) \land h \disj h' \\
      & & \impl (h \disju h', h_g[h'], L, \env \satisfies Q) \\
    \TODO{Pull this line out to definitions}
      & & \text{\emph{(Where $h_g[h']$ is function-update notation, to ensure
          consistency)}} \\
    h,h_g,L,\env \satisfies (E_1,E_2) \pointsto E_3 & \iff &
      h \equiv (\evalle{E_1}, \evalle{E_2}) \pointsto \evalle{E_3} \\
    h,h_g,L,\env \satisfies E_1 \bp E_2 & \iff & \forall (l,x) \in \dom(h_g) \st
      h_g(l,x) = \evalle{E_1} \\
      & & \impl (l,x) \in \evalle{E_2} \\
    h,h_g,L,\env \satisfies \lemp & \iff & h = \emp
  \end{array}$
\end{display}

\FIXME{Give $\bp$ a footprint to prevent contradictory assertions/implication}

The definition of $\wand$ is awkward, by introducing the global view of the
heap, we cannot keep both the right-adjoint property of $\sep$
($P \sep Q \vdash R \iff P \vdash Q \wand R$)
and maintain use of $\wand$ as the weakest precondition for a command.

The definition of $\wand$ here is that which maintins the right-adjoint property. The
ability to express weakest preconditions is enabled through the introduction
% of $\upd P$ to maintain consistency between local and global views of the heap.
of box-wand, $\boxwand$, a modified version of $\wand$ that also updates the
state of the global heap used for evaluation of sub-expressions.

% By using it in conjunction with the $\wand$ operator,
It can be used to apply
a \emph{hypothesis} about a future state of the heap to the global view of the
heap. This maintains the ability to express conditions like ``if I make
the heap look like P, then Q will hold''.

\subsection{Hoare Triples}
Definition:
\[ \tr{P}{\js{e}}{Q} \]
Soundness:
\[ (h, h \disju h_f, L, \env \satisfies P) \land h, L, \js{e} \leadsto h', v
  \impl (h', h' \disju h_f, L, \env \satisfies Q) \]
Fault avoidance:
\[ h, h_g, L, \env \satisfies P \land h\subseteq h_g \impl h, L, \js{e} \not\leadsto \fault \]
Safety monoticity:
\[ (h, h_g, L, \env \satisfies P) \land h \disj h' \land h, L, \js{e} \not\leadsto
  \fault \land h\subseteq h_g \impl h \disju h', L, \js{e} \not\leadsto \fault \]
Frame property:
\[ (h, h_g, L, \env \satisfies P) \land h, L, \js{e} \not\leadsto \fault \land
  h \disju h', L, \js{e} \leadsto h_2' \land h\subseteq h_g\impl h, L, \js{e} \leadsto h_2 \land
  h_2' = h_2 \disju h' \]

\TODO{Bake-in safety and frame properties?}
An alternative formulation which emphasises the relationship between the global
view of the heap and the framing property ($h_g = h \disju h_f$) can also be
produced, it should be noted that the meaning is subtly different (in that $h'
\neq h_g$ in all cases).

\TODO{Auxiliary predicates}
\begin{display}{Inference Rules}
  $\bpGen(V,\_,\_,\_) \triangleq V \notdotin \loc$ \\
  $\bpGen(V,L,x,s) \triangleq V \dotin \loc \sep V \bp \{(L,x)\} \cup s$
  \vg

  \stateaxiom{(Declaration)}
    {\tr {\lemp} {\js{var x}} {\rv \doteq \und}}
  \vg

  \stateaxiom{(Value)}
    {\tr {\lemp} {\js{v}} {\rv \doteq \js{v}}}
  \vg

  \staterule{(Variable)}
    {P = \scope(Ls_1, \ls, \js{x}, L) \sepish \getValue(Ls_2, \fld{L}{\js{x}}, V)}
    {\tr P {\js{x}} {P \sep \rv \doteq \fld{L}{\js{x}}}}
  \vg

  \staterule{(Member Access)}
    {\tr P {\js{e}} {Q \sep \rv \doteq V} \quad Q = R \sep \getValue(Ls, V, L)
      \sep L \not\doteq \nil \sep L\dotin\loc}
    {\tr P {\js{e.x}} {Q \sep \rv \doteq \fld{L}{\js{x}}}}
  \vg

  \staterule{(Computed Access)}
    {
      \tr {P} {\js{e1}} {R \sep \rv \doteq V_1} \quad R = S_1 \sep
      \getValue(Ls_1, V_1, L) \sep L \not\doteq \nil \sep L\dotin\loc\\
      \tr {R} {\js{e2}} {Q \sep X \dotin \uvars \sep \rv \doteq V_2}
      \quad Q = S_2 \sep \getValue(Ls_2, V_2, X)
    }
    {\tr {P} {\js{e1[e2]}} {Q \sep \rv \doteq \fld{L}{X}}}
  \vg

  \staterule{(Bin Op)}
    {
      \tr P {\js{e1}} {R \sep \rv \doteq V_1} \quad R = S_1 \sep \getValue(Ls,
      V_1, V_3) \\
      \tr R {\js{e2}} {Q \sep \rv \doteq V_2} \quad Q = S_2 \sep \getValue(Ls,
      V_2, V_4) \\
      V = V_3 \mathbin{\bar\oplus} V_4
    }
    {\tr P {\js{e1} \oplus \js{e2}} {Q \sep \rv \doteq V}}
  \vg

  \FIXME{Look at bp closer - need to remove $V_3$?}
  \gds{I don't think you \emph{need} to remove $V_3$. You maintain permission to\\
    $(L,X)$ after the assignment, so you can use consequence to remove $V_3$\\
    from the bp set then. Also, consider the case where $V_3$=$V_2$.}
  \staterule{(Assign)}
    {
      \tr P {\js{e1}} {R \sep \rv \doteq \fld{L}{X}} \\
      \tr R {\js{e2}} {Q \sep (L,X) \pointsto V_3 \sep \rv \doteq V_1} \\
      Q = S \sep \getValue(Ls, V_1, V_2) \sep \ReadWrite(L) \sep
      \bpGen(V_2, L, X, s)
    }
    {\tr P {\js{e1 = e2}} {Q \sep (L,X) \pointsto V_2 \sep \rv \doteq V_2}}
  \vg

  \staterule{(This)}
  { P = \scope(Ls, \ls, @this, L_1) \sepish \proto(Ls_2, L_1, @this, L_2)
    \sepish (L_2,@this) \pointsto V }
  {\tr P {\js{this}} {P \sep \rv \doteq V}}
  \vg

  \staterule{(Function)}
  {
    P = \lop \bp s_1 \sep \lfp \bp s_2 \sep \bigsep_{0\leq i<\length(\ls)} \lstitem(i,\ls) \bp s'_i \\
      Q = \left(\begin{array}{l}
          \exists L_1,L_2 \st \newobj(L_1,@proto) \sep (L_1,@proto) \pointsto \lop
    \sep \newobj(L_2,@proto, \js{prototype}, @scope, @body) \sep {}\\
    L_2 \bp \{\} \sep \fun(L_2, \ls, x, e, L_1) \sep \rv \doteq L_2 \sep
    L_1 \bp \{(L_2, \js{prototype})\} \sep {} \\
    \lop \bp s_1 \cup \{(L_1,@proto)\} \sep \lfp \bp s_2 \cup
      \{(L_2,@proto)\} \sep \bigsep_{0\leq i<\length(\ls)} \lstitem(i,\ls) \bp \{(L_2,@scope)\} \cup s'_i
    \end{array}\right)
  }
  {\tr P {\js{function(x) \{e\}}} Q}
  \vg

  \staterule{(Named Function)}
    {
      P = \lop \bp s_1 \sep \lfp \bp s_2 \sep
        \bigsep_{0\leq i<\length(\ls)} \lstitem(i,\ls) \bp s'_i \\
      Q = \left(\begin{array}{l}
      \exists L_1, L_2, L_3 \st \newobj(L_1, @proto) \sep (L_1, @proto)
      \pointsto \lop \sep \newobj(L_3,@proto,y) \sep (L_3, @proto) \pointsto
      \nil \sep {} \\
      (L_3,\js{y}) \pointsto L_2 \sep L_2 \bp \{(L_3,\js{y})\} \sep
      L_3 \bp \{(L_2,@scope)\} \sep
      \newobj(L_2,@proto,\js{prototype},@scope,@body) \sep {} \\
      \fun(L_2,(L_3:\ls), \js{x}, \js{e}, L_1) \sep \rv \doteq L_2 \sep
      L_1 \bp \{(L_2, \js{prototype})\} \sep {} \\
      \lop \bp \{(L_1, @proto)\} \cup s_1 \sep \lfp \bp \{(L_2, @proto)\}
      \cup s_2 \sep  \bigsep_{0\leq i<\length(\ls)} \lstitem(i,\ls) \bp \{(L_2,@scope)\} \cup s'_i
      \end{array}\right)
    }
    {\tr P {\js{function y(x) \{e\}}} Q}
  \vg

  \staterule{(Object)}
    {
      \forall i \in 1..n \st \left(\begin{array}{l}
        P_i = R_i \sep \getValue(Ls_i, Y_i, X_i) \sep
          X_i \bp s_i \\
        \tr {P_{i-1}} {\js{ei}} {P_i \sep \rv \doteq Y_i} \\
      \end{array}\right) \\
      P_n = R \sep \lop \bp s_{op} \\
      Q = R \sep
      \exists L \st \left(\begin{array}{l}
        \newobj(L, @proto, \js{x1} \ldots \js{xn}) \sep {} \\
        (L, \js{x1}) \pointsto X_1 \sep X_1 \bp s_1 \cup \{(L,\js{x1})\} \sep
          \dots \sep {} \\
        (L, \js{xn}) \pointsto X_n \sep X_1 \bp s_1 \cup \{(L,\js{x1})\} \sep {} \\
        (L,@proto) \pointsto \lop \sep \lop \bp s_{op} \cup \{(L,@proto)\} \sep {} \\
        \rv \doteq L \sep L \bp \{\} \\
      \end{array}\right) \\
      \js{x1} \neq \dots \neq \js{xn} \qquad \rv \not\in \fv(P_n)
    }
    {\tr {P_0} {\js{\{x1:e1, ..., xn:en\}}} Q}
  \vg\gds{Cool. Probably sound. Not perfect yet.}\vg

  \staterule{(Function Call)}
    {
      \tr P {\js{e1}} {R_1 \sep \rv \doteq F_1} \\
      R_1 = \left(\begin{array}{l}
          S_1 \sepish \pickThis(F_1, T) \sepish \getValue(Ls_1, F_1, F_2) \sep {} \\
          (F_2, @body) \pointsto \lambda X.\js{e3} \sep (F_2, @scope) \pointsto
          Ls_2
      \end{array}\right) \\
      \tr {R_1} {\js{e2}} {R_2 \sep \ls \doteq Ls_3 \sep \rv \doteq V_1} \\
      R_2 = S_2 \sep \getValue(Ls_4, V_1, V_2) \\
      R_3 = \left(\begin{array}{l}
          R_2 \sep \exists L \st \ls \doteq L:Ls_2 \sep (L, X) \pointsto V_2
          \sep (L, @this) \pointsto T \sep (L, @proto) \pointsto \nil \sep
          \defs(X,L,\js{e3}) \sep {} \\
          \newobj(L,@proto,@this,\js{x},\vardecls(X, L, \js{e3}) \sep
          L \bp \{\} \sep T \bp \{(L,@this)\} \cup s \sep
          \bpGen(V_2, L, X, s')
      \end{array}\right) \\
      \tr {R_3} {\js{e3}} {\exists L \st Q \sep \ls \doteq L:Ls_2} \qquad
      \ls \notin \fv(Q) \cup \fv(R_2)
    }
    {\tr P {\js{e1(e2)}} {\exists L \st Q \sep \ls \doteq Ls_3}}
  \vg \gds{Do you want $T\bp s$ in the precondition?}

  \staterule{(New)}
    {}
    {}
  \vg

  % SES-specific
  \staterule{(Restricted evaluation)}
    {}
    {}
  \vg

  \staterule{(Freeze)}
    {}
    {}
  \vg

  \staterule{(Recusive freeze)}
    {}
    {}
  \vg

  % Control flow
  \staterule{(Sequence)}
    {\tr P {\js{e1}} R \quad \tr R {\js{e2}} Q}
    {\tr P {\js{e1; e2}} Q}
  \vg

  \staterule{(If True)}
    {\tr P {\js{e1}}{S\sep \istrue(\E{V_2})\sep\rv\doteq\E{V_1}} \qquad
     S = R \sep \getValue(Ls,\E{V_1},\E{V_2})\\
     \tr {S}{\js{e2}} Q}
    {\tr P {\js{if(e1)\{e2\}\{e3\}}} Q}
  \vg

  \staterule{(If False)}
    {\tr P {\js{e1}}{S\sep \isfalse(\E{V_2})\sep\rv\doteq\E{V_1}} \qquad
     S = R \sep \getValue(Ls,\E{V_1},\E{V_2})\\
     \tr {S}{\js{e3}} Q}
    {\tr P {\js{if(e1)\{e2\}\{e3\}}} Q}
  \vg

  \staterule{(While)}
    {\tr P {\js{e1}} {S\sep\rv\doteq\E{V_1}} \qquad
    S = R \sep \getValue(Ls,\E{V_1},\E{V_2})\\
     \tr {S \sep \istrue(\E{V_2})} {\js{e2}} P\\
     Q = S \sep \isfalse(\E{V_2})\sep\rv\doteq\und\qquad
     \rv\not\in \fv(R)}
    {\tr P {\js{while(e1)\{e2\}}} Q}
  \vg

  % Standard
  \staterule{(Frame)}
    {\tr P {\js{e}} Q}
    {\tr {P \sep R} {\js{e}} {Q \sep R}}

  \staterule{(Consequence)}
    {\tr {P'} {\js{e}} {Q'} \\
     P \impl P' \quad Q' \impl Q}
    {\tr P {\js{e}} Q}
  \vg

  \staterule{(Elimination)}
    {\tr P {\js{e}} Q}
    {\tr {\exists X \st P} {\js{e}} {\exists X \st Q}}

  \staterule{(Disjunction)}
    {\tr{P_1}{\js{e}}{Q_1} \quad \tr{P_2}{\js{e}}{Q_2}}
    {\tr{P_1 \lor P_2}{\js{e}}{Q_1 \lor Q_2}}

\end{display}

\subsection{Notes}
The existing backpointers paper\cite{KassiosKritikos12} is the first case in
which we've seen the concept of a backpointer being used with separation logic
to count references. However, these backpointers are implemented as \emph{ghost
fields} as members of the data structures under examination in the Chalice
tool.

Each object that is being tracked for pointers $o$, has a field, named $T.f^{-1}$
which contains the set of objects of type $T$, whose $f$ field
points to $o$.

These ghost fields are updated by the program logic using the inference rules
for assignment.

These sorts of backpointers are not suitable for our use for a number of
reasons: explicit references to field name and object type on
which references may be stored limit the flexibility of pointer tracking,
although it is suitable for this case of reference counting, it is not suitable
for more a general security analysis. Secondly, the set of pointers recorded is
exactly those in existence, it may be useful for the logic to be more flexible
about this definition, say for those objects in the set to be \emph{at least}
those that point to the tracked object.

Using the ``at most'' semantics allows for the rule of consequence to be used to
add new items to the set at any time. \emph{Note: should probably consider the
impact of this on reachability, as well as non-reachability analysis.}

\section{Proofs}
\subsection{Revocable Reference}
Used to provide a restricted execution context with a reference to an object
that may be revoked by the provider.
\emph{Note: By itself, this is not safe, since accessed references are returned
  raw. See next section, Membrane, for solution.}

\begin{verbatim}
var RevocableRef = function(ref) {
  var protected = ref;
  var access = function(field) { return protected[field]; }
  var kill = function() { protected = null; }
  return {access: access, kill: kill};
}
\end{verbatim}

% Proof for declaration of RevocableRef is incomplete, and possibly wrong
%\[
%  \begin{array}{l}
%    \logic{
%      P_1 = \scope(Ls_1, \ls, \js{RevocableRef}, L_1) \sepish \getValue(Ls_2,
%      \fld{L_1}{\js{RevocableRef}}, V_1) \\
%      \tr{P_1}{\js{RevocableRef}}{P_1 \sep \rv\doteq\fld{L_1}{\js{RevocableRef}}}\\
%      \\
%      P_2 = \exists L_3, L_4 \st \lop \bp s_1 \cup \{(L_3,@proto)\} \sep \lfp \bp s_2 \cup
%      \{(L_4,@proto)\} \sep \forall l' \in elem(\ls) \st l' \bp \{(L_4,@scope)\}
%      \cup s' \\
%      S = \exists L_3,L_4 \st \newobj(L_3,@proto) \sep (L_3,@proto) \pointsto \lop
%      \sep \newobj(L_4,@proto, \js{prototype}, @scope, @body) \sep {}\\
%      L_4 \bp \{\} \sep \fun(L_4, \ls, x, e, L_3) \sep \rv \doteq L_4 \sep
%      P \sep L_3 \bp \{(L_4, \js{prototype})\} \\
%
%      \tr{P_2}{\js{function(x) \{$b_r$\}}}{Q \sep (L_2,X) \mapsto V_4 \sep \rv
%        \doteq V_2} \\
%      Q = S \sep \getValue(Ls_3, V_2, V_3) \sep \RW(L_2) \sep \bpGen(V_3, L_2, X, s) \\
%    } \\
%    \js{var RevocableRef = function(x) \{$b_r$\}} \\
%    \logic{
%
%    }
%  \end{array}
%\]

% RevocableRef body call
%
% I've generally unwrapped all \scope, \proto, \getValue operations down to
%   their requirements
% Introduction of new elements into an existing backpointer set seems clumsy
% There must be better ways of generating these proofs other than by hand?
\[
  \begin{array}{l}
    \js{var RevocableRef = function(ref) \{}\\
    \begin{array}{@{\qquad}l}
    \logic{
      % function
      \obj_R(@body: \lambda\js{ref}.\{\dots\} , @scope: Ls)
        \sep {} \\
      % ar
        \exists L \st \ls \doteq L:Ls \sep {} \\
        \obj_L\left(
          \begin{array}{l}
            \js{ref}: V,@this: \_,@proto: \nil,@frozen: \false,\\
            \js{protected}: \und,\js{access}: \und,\js{kill}: \und %  and defs()
          \end{array}
        \right) \sep {} \\
      % bp
        L \bp \{\} \sep V \bp s_1 \cup \{(L,\js{ref})\} \sep
        \lop \bp s_3 \sep \lfp \bp s_4 \sep
        (\bigsep_{0\leq i<\length(\ls)} \lstitem(i,\ls) \bp s'_i)
    } \\
    \step{Frame/elim/cons ($V \bp s_1 \impl V \bp s_1 \cup s_2$)} \\
    \logic{
      % var *2
      (L, \js{protected}) \pointsto \_ \sep (L, \js{ref}) \pointsto V \sep {} \\
      % assign
      (L, @frozen) \pointsto \false \sep
        V \bp s_1 \cup \{(L,\js{ref}), (L, \js{protected})\} \sep \ls\doteq{L:Ls}
    } \\
    \js{var protected = ref;} \\
    \logic{
      % var *2
      (L, \js{protected}) \pointsto V \sep (L, \js{ref}) \pointsto V \sep {} \\
      % assign
      (L, @frozen) \pointsto \false \sep
        V \bp s_1 \cup \{(L,\js{ref}), (L, \js{protected})\}\sep \ls\doteq{L:Ls}
    } \\
    \step{Frame(s)/cons} \\
    \logic{
      % var
      (L, \js{access}) \pointsto \_ \sep
      % assign
      (L,@frozen) \pointsto \false \sep {} \\
      % fun pre
      \lop \bp s_3 \sep \lfp \bp s_4 \sep
        (\bigsep_{0\leq i<\length(\ls)} \lstitem(i,\ls) \bp s'_i)\sep \ls\doteq{L:Ls}
    } \\
    \js{var access = function(field) \{$b_a$\};} \\
    \logic{
      \exists A, A_p \st \left(\begin{array}{l}
      % var
      (L, \js{access}) \pointsto A \sep {} \\
      % fun pre
      \lop \bp s_3 \cup \{(A_p, @proto)\} \sep \lfp \bp s_4
        \cup \{(A, @proto)\} \sep {} \\
      (\bigsep_{0\leq i<\length(\ls)} \lstitem(i,\ls) \bp s'_i \cup \{(A,@scope)\}) \sep {} \\
      % fun post
      \newobj(A_p,@proto) \sep (A_p,@proto) \pointsto \lop \sep {} \\
      \newobj(A, @proto, \js{prototype}, @scope, @body) \sep {} \\
      \fun(A, \ls, \js{field}, b_a, A_p) \sep %A \bp \{\} \sep % see below
        A_p \bp \{(A, \js{prototype})\} \sep {} \\
      % assign
      (L,@frozen) \pointsto \false \sep A \bp \{(L, \js{access})\}
      \end{array}\right) \sep \ls\doteq{L:Ls}
    } \\
    \step{} \\
    \logic{
      % var
      (L, \js{kill}) \pointsto \_ \sep
      % assign
      (L,@frozen) \pointsto \false \sep {} \\
      % fun pre
      \lop \bp s_5 \sep \lfp \bp s_6 \sep
        (\bigsep_{0\leq i<\length(\ls)} \lstitem(i,\ls) \bp s'_i) \sep \ls\doteq{L:Ls}
    } \\
    \js{var kill = function() \{$b_k$\};} \\
    \logic{
      \exists K, K_p \st
      \left(\begin{array}{l}
      % var
      (L, \js{kill}) \pointsto K \sep {} \\
      % fun pre
      \lop \bp s_5 \cup \{(K_p, @proto)\} \sep \lfp \bp s_6
        \cup \{(K, @proto)\} \sep {} \\
      (\bigsep_{0\leq i<\length(\ls)} \lstitem(i,\ls) \bp s'_i \cup \{(K,@scope)\}) \sep {} \\
      % fun post
      \newobj(K_p,@proto) \sep (K_p,@proto) \pointsto \lop \sep {} \\
      \newobj(K, @proto, \js{prototype}, @scope, @body) \sep {} \\
      \fun(K, \ls, \js{field}, b_k, K_p) \sep %K \bp \{\} \sep % see below
        K_p \bp \{(K, \js{prototype})\} \sep {} \\
      % assign
      (L,@frozen) \pointsto \false \sep K \bp \{(L, \js{kill})\}
      \end{array}\right)\sep \ls\doteq{L:Ls}
    } \\
    \step{} \\
    \logic{
      (L, \js{access}) \pointsto A \sep (L, \js{kill}) \pointsto K \sep {} \\
      A \bp s_7 \sep K \bp s_8 \sep \lop \bp s_9
    } \\
    \js{return \{access: access, kill: kill\};} \\
    \logic{
      \exists O \st
      \left(\begin{array}{l}
      (L, \js{access}) \pointsto A \sep (L, \js{kill}) \pointsto K \sep {} \\
      \newobj(O, @proto, \js{access}, \js{kill}) \sep (O,\js{access}) \pointsto
        A \sep (O,\js{kill}) \pointsto K \sep {} \\
      A \bp s_7 \cup \{(O, \js{access}\} \sep K \bp s_8 \cup \{(O, \js{kill})\}
        \sep \lop \bp s_9 \cup \{(O,@proto)\} \sep {} \\
      (O,@proto) \pointsto \lop \sep O \bp \{\} \sep \rv \doteq O
      \end{array}\right)
    } \\
    \step{} \\
    \logic{

    }
  \end{array}
\\
    \js{\}}
  \end{array}
\]

% RevocableRef#kill body call
\[
  \begin{array}{l}
    \js{var kill = function() \{} \\
    \logic{
      (K, @body) \mapsto \lambda \_.\{b_k\} \sep (K, @scope) \mapsto L:Ls \sep {} \\
      \exists L' \st \ls \doteq L' : L : Ls \sep (L',@this) \mapsto \_ \sep {} \\
      (L',@proto) \mapsto \nil \sep (L',@frozen) \mapsto \false \sep L' \bp \{\}
    } \\
    \step{} \\
    \logic{
      % var
      (L',\js{protected}) \mapsto \none \sep (L',@proto) \mapsto \nil \sep {} \\
      (L, \js{protected}) \mapsto V \sep
      % assign
      (L,@frozen) \mapsto \false
    } \\
    \js{protected = null;} \\
    \logic{
      % var
      (L',\js{protected}) \mapsto \none \sep (L',@proto) \mapsto \nil \sep {} \\
      (L, \js{protected}) \mapsto \nil \sep
      % assign
      (L,@frozen) \mapsto \false \sep \rv \doteq \nil
    } \\
    \step{} \\
    \logic{

    } \\
    \js{\}}
  \end{array}
\]

% RevocableRef#access body call
\[
  \begin{array}{l}
    \js{var access = function(field) \{} \\
    \logic{
      (A, @body) \mapsto \lambda \js{field}.\{b_a\} \sep (A, @scope) \mapsto L:Ls \sep {} \\
      \exists L' \st \ls \doteq L' : L : Ls \sep (L',@this) \mapsto \_ \sep
      (L', \js{field}) \mapsto X \sep {} \\
      (L',@proto) \mapsto \nil \sep (L',@frozen) \mapsto \false \sep {} \\
      L' \bp \{\} \sep X \bp s \cup \{(L', \js{field})\}
    } \\
    \step{} \\
    \logic{
      % var protected
      (L',\js{protected}) \mapsto \none \sep (L',@proto) \mapsto \nil \sep {} \\
      (L, \js{protected}) \mapsto P \sep
      % comp access
      P \not\doteq \nil \sep P \dotin \loc \sep {} \\
      % var field
      (L',\js{field}) \mapsto X \sep X \dotin \uvars
    } \\
    \js{return protected[field];} \\
    \logic{
      % var protected
      (L',\js{protected}) \mapsto \none \sep (L',@proto) \mapsto \nil \sep {} \\
      (L, \js{protected}) \mapsto P \sep
      % comp access
      P \not\doteq \nil \sep P \dotin \loc \sep {} \\
      % var field
      (L',\js{field}) \mapsto X \sep \rv \doteq \fld{P}{X}
    } \\
    \step{} \\
    \logic{

    } \\
    \js{\}}
  \end{array}
\]


Proof derivations are given for the declaration, and each function call.

\subsection{Membrane}
A Membrane is a transitive Revocable Reference. In addition to the standard
Revocable Reference, all returned objects are also wrapped in a Revocable
Reference that shares its kill switch with its parent. All references to the
parent object and anything it created are removed simultaneously.

\TODO{Check prototype chain for leaks? proxies/simpleMembrane.js}
\begin{verbatim}
var Membrane = function(ref) {
  var killSwitch = false;
  var MembraneRef = function MembraneRef(r) {
    var access = function(field) {
      if(!killSwitch) return MembraneRef(r[field]);
      else throw();
    }
    var kill = function() { killSwitch = true; }

    if(primitive(r)) return r;
    else return {access: access, kill: kill};
  }
  return MembraneRef(ref);
}
\end{verbatim}

\bibliography{bibliography}
\bibliographystyle{babplain}

\end{document}
