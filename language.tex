\documentclass[a4paper]{article}
\usepackage[usenames,dvipsnames,svgnames,x11names]{xcolor}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{wasysym}
\usepackage{xspace}
\usepackage{fullpage}
\usepackage{hyperref}
\usepackage{etoolbox}
\usepackage{separationlogic}
\usepackage[english]{babel}
\usepackage[fixlanguage]{babelbib}

\begin{document}

\section{SES Syntax and Description}

\newcommand{\editlabel}[3]{~\vg\colorbox{#2}{\textbf{#1:}}\tabfill{\textrm{ #3}}\\}
\newcommand{\FIXME}[1]{\editlabel{FIXME}{red}{#1}}
\newcommand{\TODO}[1]{\editlabel{TODO}{yellow}{#1}}
\newcommand{\COMMENT}[1]{\editlabel{COMMENT}{YellowGreen}{#1}}
\newcommand{\gds}[1]{\editlabel{GDS}{Orange}{#1}}

\newcommand{\syntaxline}[3][\pipe]{#1 & \js{#2} & \textit{#3}\\}
\begin{display}{Syntax of SES values and expressions, \js{v}, \js{e}}
  $\begin{array}{rll}
    \syntaxline[\js{v} ::=]{\js{n}}{Number}
    \syntaxline{s}{String}
    \syntaxline{\und}{Undefined}
    \syntaxline{\nil}{Null}
    \syntaxline{\true \pipe \false}{Booleans}
    \syntaxline[\js{e} ::=]{v}{Value}
    \syntaxline{x}{Identifier}
    \syntaxline{\{x_1:e_1, \ldots, x_n:e_n\}}{Object creation}
    \syntaxline{e; e}{Sequence}
    \syntaxline{e \oplus e}{Binary operator}
    \syntaxline{if(e) \{e\} else \{e\}}{Conditional}
    \syntaxline{while(e) \{e\}}{Looping}
    \syntaxline{\jsvar{x}}{Variable declaration}
    \syntaxline{e = e}{Assignment}
    \syntaxline{e.x}{Member access}
    \syntaxline{e[e]}{Computed member access}
    \syntaxline{e(e)}{Function call}
    \syntaxline{this}{this}
    \syntaxline{\jsfun{e}{e}}{Function creation}
    \syntaxline{\jsfun[x]{e}{e}}{Named function creation}
    \syntaxline{\jsnew{e}{e}}{Object construction}
    \syntaxline{reval(e, e)}{Restricted evaluation}
    \syntaxline{freeze(e)}{Freeze}
    \syntaxline{def(e)}{Recursive freeze}
  \end{array}$
\end{display}

An object is a location in the heap, it contains a set of
values indexed by fields.

\paragraph{Object creation}  The Object Construction syntax produces a new object
with fields named \js{x_1, \ldots, x_n} which map to the values of expressions
\js{e_1, \ldots, e_n} when evaluated in order at creation.

\paragraph{Sequence} The sequencing operator specifies that the expression on the left should be
evaluated, followed by the expresion on the right.

\paragraph{Binary operator} Binary operations are evaluated left-to-right, and includes standard
mathematical and string operations. Formalisation of semantics for all of these
are beyond the scope of this project, but will correspond closely to similar
works on the JavaScript family of languages.

\paragraph{Conditional} The conditional expression evaluates the first sub-expression, if it evaluates
to \js{true} under a boolean casting operation, the second sub-expression is
evaluated and result returned, otherwise the third sub-expression is evaluated
and result returned.
%gds{Be prepared to defend the lack of object-level casting. At the moment our
%  simple semantics only cast primitive values.}

\paragraph{Looping} The looping expression executes the body sub-expression
whilst the condition sub-expression evaluates to true. \und is returned. (ES6
semantics, and for simplicity - return type of loop not obeservable from
parsable code).

\paragraph{Variable declaration} Variable declarations are used during activation
record creation to determine free-variables when constructing a new scope. They
are no-ops during evaluation. For simplicity of this specification, combined
declaration/assignment instructions are forbidden (they may be desugared to two
separate instructions during parsing).

\paragraph{Assignment} Assigns the value on the right hand side to the named
field on the left. Assignments to undeclared variables are forbidden (enforced
by the Variable rule), this is consistent with ES5-strict.

\paragraph{Member access} Returns the value of the named field of the object referenced by
the subexpression.

\paragraph{Computed member access} As Member access, but the field name is derived from
the expression in \js{[]}.

\paragraph{Function creation} Creates a function object, assigning the body, parameter
declarations and the current scope to internal fields. A new object is also
created and assigned to the \js{prototype} field for use as the prototype of
objects produced by using this function as a constructor (this permits
emulation of a class-based language).

\paragraph{Named function creation} This syntax is the same as standard function creation,
but also adds the name and a self-reference to the function to the function's
scope record. This permits recursive functions to be created. \emph{Note:} the
name of the function is not added to the current scope, it is permitted in the
actual language, but is considered to be syntactic sugar, combining creation and
assignment.

\paragraph{Function call} Executes the body of the function, using the passed expression
as the value to bind to the parameter. The body of the function is executed in
the scope stored with the function, any variables defined within the function
body are defined on an activation record so that they are lexically scoped.

\paragraph{Object construction} Constructs an object using the given function, an object
is created as usual, it's prototype is assigned to that of the function's
\js{prototype} field. The body of the function is then exectuted, commonly used
to initialize the newly created object.

% ES5-Strict definition, plus reval global - matches caja impl (and intuition).
\paragraph{\js{this}} The \js{this} expression is context-dependent. When used
outside of a
function, it should evaluate to the most global accessible scope.
When used within a function, if the function is called using Member Access, it
will evaluate to the object on which that function was called. Otherwise
(most likely function call directly via scope),
\js{this} returns undefined. Note that this is particularly
problematic because functions can easily be aliased off of the object on which
they appear to be defined.

\paragraph{Restricted evaluation} Parse the first given expression as SES code.
A new scope chain is prepared, its root is the
object specified by the second parameter, the \emph{imports} to the restricted
environment.
An activation record which initializes any variables declared in the parsed
source is then appended. This may cause imported objects to be shadowed.
The return value of the restricted evaluation statement is the same as that of
the final statement of the source to be executed.

\paragraph{Freeze} Makes the provided object read-only, prevents field additions,
modifications and deletions.
Note that the ES5 spec has a bug, meaning that frozen fields on an object's
prototype are not permitted to be overridden\footnote{See
ses/repairES5.js\#makeTamperProof()}, some browsers opt to ``fix'' the spec bug.
This bug does not occur in these semantics.

\paragraph{Recursive freeze} Recursively calls freeze on all objects reachable
via user-defined fields from the given object.

\section{Operational Semantics}
\newcommand{\auxf}[2]{#1 & \triangleq & #2}
\begin{display}{Auxillary Functions}
  $\begin{array}{lcl}
  \auxf{\obj(l,l')}{l \pointsto \{@proto: l', @frozen: \false\}}\\
  \auxf{\istrue(v)}{v\not\in\{0,\emptystr,\nil,\und,\false\}}\\
  \auxf{\isfalse(v)}{v\in   \{0,\emptystr,\nil,\und,\false\}}\\
  \auxf{\fun(l',L,\js x,\js e,l)}{l'\mapsto\{@proto: \lfp, \js{prototype}:
        l, @scope: L, @body: \lambda \js{x.e}, @frozen: \false\}}\\
  \auxf{\pickThis(H, \fld{l}{x})}{l \phantom{\und} \quad
        \text{if } (l,@this) \in \dom(H)}\\
  \auxf{\pickThis(H, r)}{\und \phantom{l} \quad \text{otherwise}}\\
  \auxf{\objOrGlob(l)}{l\phantom{_{op}} \quad l\in \loc}\\
  \auxf{\objOrGlob(v)}{\lop \quad v\not\in\loc}\\
  \auxf{\getBase(l,l')}{l' \qquad l \in \loc}\\
  \auxf{\getBase(l,v)}{v \qquad v\not\in\loc}\\

  \auxf{\act(l,\js{x},v,\js{e},l'')}{l\pointsto\{\js{x}:
    v,@this: l'',@proto: \nil\}\disju \defs(\js{x},l,\js{e})}\\

  \auxf{\auxDef(H,l,s)}{\begin{cases}
    \emp & l \in s \lor l \not\in \loc\\
    (l,@frozen) \mapsto \true \cup \bigcup_{(l,x_n) \in H, x_n \in \uvars}
    \auxDef(H,H(l,x_n),s \cup\{l\}) & \mbox{otherwise} \\
  \end{cases}}\\
  \end{array}$
\end{display}

  \TODO{Requirements for minimal heap $H_\emptyset$ soundness $H(\lgo, @this)$}

  \begin{display}{Local Variable Declarations}
    \jaxiom{\defs(\js{x},l,\jsvar{y})}{(l,y) \pointsto \und \quad$ \= if
      $\js{x} \neq \js{y}} \\
    \jaxiom{\defs(\js{x},l,\js{e_1 = e_2})}{\defs(\js{x},l,\js{e_1})} \\
    \jaxiom{\defs(\js{x},l,\js{e_1;e_2})}{\defs(\js{x},l,\js{e_1}) \cup
      \defs(\js{x},l,\js{e_2})} \\
    \jaxiom{\defs(\js{x},l,\js{if(e_1)\{e_2\}\{e_3\}})}
      {\defs(\js{x},l,\js{e_2}) \cup \defs(\js{x},l,\js{e_3})} \\
    \jaxiom{\defs(\js{x},l,\js{while(e_1)\{e_2\}})}{\defs(\js{x},l,\js{e_2})} \\
    \jaxiom{\defs(\js{x},l,\js{e})}{\emp$ \> otherwise$}
  \end{display}

  \begin{display}{Heap Update $H[H']$}
    \jaxiom{H[\emp]}{H} \\
    \jaxiom{H[(l,x) \pointsto v]}{H \disju (l,x) \pointsto v \qquad \mbox{if }
      (l,x) \not\in \dom(H)} \\
    \jaxiom{H[(l,x) \pointsto v \disju H']}{H[(l,x) \pointsto v][H']}
  \end{display}

  \begin{display}{Scope resolution: $\scope(H,l,x)$.}
    \jaxiom{\scope(H,{\emptylist},\njs{x})}{\nil}{}\vg
    \jrule{\scope(H,l\cons L,\njs{x})}{l}{\proto(H,l,\njs{x}) \neq \nil}\rsep
    \jrule{\scope(H,l\cons L,\njs{x})}{\scope(H,L,\njs{x})}{\proto(H,l,\njs{x}) = \nil}
  \end{display}
  %
  \begin{display}{Prototype resolution: $\proto(H,l,x)$.}
    \jaxiom{\proto(H,\nil,\njs{x})}{\nil}{}\vg
    \jrule{\proto(H,l,\njs{x})}{l}{(l,\njs{x}) \in\dom(H)}\rsep
    \jrule{\proto(H,l,\njs{x})}{\proto(H,l',\njs{x})}{(l,\njs{x}) \not\in\dom(H) \qquad H(l,@proto) = l'}
  \end{display}
  %
  \begin{display}{Dereferencing values: $\getValue(H,r)$.}
    \jrule{\getValue(H,\njs{r})}{\njs{r}}{\njs{r}\neq \fld{l}{\js{x}}}~
    \jrule{\getValue(H,\fld{l}{\js{x}})}{\und}{\proto(H,l,\js{x}) = \nil\\ l\neq \nil}~
    \jrule{\getValue(H,\fld{l}{\js{x}})}{H(l',\js{x})}{\proto(H,l,\js{x}) = l'\\ l\neq \nil}
  \end{display}

\begin{display}{Operational semantics: $H,L,\js e \evalsto H',v$}
  Dereferencing notation: $H,L,\js{e} \gevalsto H',v \triangleq \exists r. (H,L,\js{e} \evalsto H',r \wedge \getValue(H',r) = v)$.
\vg

  \stateaxiom{(Value)}
  {H,L,\js{v} \evalsto H,v}
\vg

  \stateaxiom{(Variable declaration)}
  {H,L,\jsvar{x} \evalsto H,\und}
\vg

  \staterule{(Object creation)}
    {H_0 = H \disju \obj(l,\lop)\\
     \forall i\in 1..n \st \left(\begin{array}{l}
      H_{i-1},L,\js{e_i}\gevalsto H_i',v_i \\
      H_i = H_i' [ (l,\js{x_i}) \pointsto v_i]\end{array}\right)}
    {H,L,\js{\{x_1:e_1,\dots,x_n:e_n\}} \evalsto H_n,l}
\vg

  \staterule{(Sequence)}
    {H,L,\js{e_1} \evalsto H'',r' \\
     H'',L,\js{e_2} \evalsto H',r}
   {H,L,\js{e_1; e_2} \evalsto H',r}
\vg

  \staterule{(Binary operator)}
    {H,L,\js{e_1} \gevalsto H'',v_1 \\
     H'',L,\js{e_2} \gevalsto H',v_2\\
     v_1 \oplus v_2 = v}
   {H,L,\js{e_1 \oplus e_2} \evalsto H',v}
\vg

  \staterule{(Conditional true)}
  {H,L,\js{e_1} \gevalsto H'',v \quad \istrue(v) \\
   H'',L,\js{e_2} \evalsto H',r}
  {H,L,\js{if(e_1)\{e_2\} else \{e_3\}} \evalsto H',r}
\qquad

  \staterule{(Conditional false)}
  {H,L,\js{e_1} \gevalsto H'',v \quad \isfalse(v) \\
   H'',L,\js{e_3} \evalsto H',r}
  {H,L,\js{if(e_1)\{e_2\} else \{e_3\}} \evalsto H',r}
\vg

  \staterule{(While true)}
  {H,L,\js{e_1} \gevalsto H'', v \quad \istrue(v) \\
   H'',L,e_2\js{;while(e_1)\{e_2\}} \evalsto H', v''}
  {H,L,\js{while(e_1)\{e_2\}} \evalsto H',\und}
\qquad

  \staterule{(While false)}
  {H,L,\js{e_1} \gevalsto H', v \quad \isfalse(v)}
  {H,L,\js{while(e_1)\{e_2\}} \evalsto H',\und}
\vg

  % l' \neq \nil condition given in ES5-8.7.2.3.a Strict-mode null SetValue (and
  % all-mode GetValue)
  \staterule{(Variable)}
    {\scope(H,L,x) = l' \quad l' \neq \nil}
    {H,L,\js x \evalsto H, \fld{l'}{x}}
\vg

  \staterule{(Member access)}
  {H,L,\js e \gevalsto H',l' \\
   l' \neq \nil}
  {H,L,\js{e.x} \evalsto H', \fld{l'}{x}}
\qquad

  \staterule{(Computed member access)}
  {H,L,\js{e_1} \gevalsto H'',l' \\
   l' \neq \nil \\
   H'',L,\js{e_2} \evalsto H', x}
  {H,L,\js{e_1[e_2]} \evalsto H',\fld{l'}{x}}
\vg

  \staterule{(Assignment)}
  {H,L,\js{e_1} \evalsto H_1,\fld{l}{x} \qquad
   H_1(l, @frozen) \neq \true \\
   H_1,L,\js{e_2} \gevalsto H_2, v \\
   H' = H_2[(l,x) \pointsto v]}
  {H,L,\js{e_1 = e_2} \evalsto H', v}
\vg

  \staterule{(Function creation)}
  {H' = H \disju \obj(l,\lop) \disju \fun(l',L,\js{x},\js{e},l)}
  {H,L,\jsfun{x}{e} \evalsto H',l'}
\vg

  \staterule{(Named function creation)}
  {H' = H \disju \obj(l,\lop) \disju \fun(l',l_1 \cons L,\js{x},\js{e},l) \disju
    l_1 \pointsto \{@proto:\nil, y:l'\}}
  {H,L,\jsfun[y]{x}{e} \evalsto H',l'}
\vg

%\COMMENT{There's no need to $\proto$ in this now that we've disallowed prototype
%  chains from scope lists (we hit the base AR before we need to start
%  traversing) (Also assume that $\lgo$ has $@this$ set directly) We can also drop
%  $\getValue$ to just use $\scope$?}
  \staterule{(This)}
  {\scope(H,L,@this)=l}
  {H,L,\js{this} \evalsto H,l}
\vg

  \staterule{(Function call)}
  {H,L,\js{e_1} \evalsto H_1,r_1\qquad
   \pickThis(H_1,r_1)=l_2\qquad
   \getValue(H_1,r_1)=l_1\\
   H_1(l_1,@body)=\lambda \js{x.e_3}\qquad
   H_1(l_1,@scope)= L'\\
   H_1,L,\js{e_2} \gevalsto H_2,v\\
   H_3 = H_2\disju\act(l,\js x,v,\js{e_3},l_2) \\
   H_3,l \cons L',\js{e_3} \gevalsto H',v'}
  {H,L,\js{e_1(e_2)} \evalsto H',v'}
\vg

  \staterule{(Object construction)}
  {H,L,\js{e_1} \gevalsto H_1,l_1 \qquad
   l_1\neq \nil\qquad
   H_1(l_1,@body)=\lambda \js{x.e_3}\\
   H_1(l_1,@scope)= L'\qquad
   H_1(l_1,\js{prototype})= v\\
   H_1,L,\js{e_2} \gevalsto H_2,v_1  \qquad
   l_2 = \objOrGlob(v) \\
   H_3 = H_2\disju \obj(l_3,l_2) \disju\act(l,\js x,v_1,\js{e_3},l_3)\\
   H_3,l \cons L',\js{e_3} \gevalsto H',v_2\qquad
   \getBase(l_3,v_2) = l'}
  {H,L,\jsnew{e_1}{e_2} \evalsto H',l'}
\vg

\COMMENT{Shadow imports}
  \staterule{(Restricted evaluation)}
  {H,L,\js{e_1} \gevalsto H_1,v \qquad
   \js{e_3} = \parse(v) \\
   H_1,L,\js{e_2} \gevalsto H_2, l \\
   H_3 = H_2 \disju l' \pointsto \{@this:l, @proto:\nil\} \disju
     \defs(\_, l', \js{e_3}) \\
   H_3, l' \cons [l], \js{e_3} \gevalsto H',v }
  {H,L,\js{reval(e_1, e_2)} \evalsto H',v}
\vg

  \staterule{(Freeze)}
  {H,L,\js{e} \gevalsto H'', l\\
   H' = H''[(l, @frozen) \pointsto \true]}
  {H,L,\js{freeze(e)} \evalsto H', l}
\vg

  \staterule{(Recursive freeze)}
  {H,L,\js{e} \gevalsto H'', l \\
   H' = H''[\auxDef(H'', l, \{\})]}
  {H,L,\js{def(e)} \evalsto H', l}
\end{display}

\subsection{Notes}
The semantics presented here are based on the ES3 program logic paper. I've
decided to use the scope chain as the scoping and heap accessibility model as I
think it quite neatly captures the functions-as-closures semantics of the
language.

Prototype chain traversal has become more less of an issue \emph{for scope
resolution} with the removal of the
\js{with} statement, the only place a normal object (with a prototype chain) is
placed into the scope chain is at the root, either as the global object $l_g$,
or as the `fake global' imports object during restricted execution. For the case
of \js{this} we ensure that the internal $@this$ field is always set on $\lgo$
(to $\lgo$), and on the activation record for a restricted evaluation
envrionment (to mask the imported object at the root). At all other
times, objects placed into the scope chain are controlled by the language, and
will \emph{never} have a prototype set.

Progress was
made between ES3 and ES5 to remove the need to represent references internally
(they were originally specified only as the result of an implementation
decision). According to Mark Miller, of the TC39 ES standardisation body,
references should no longer be needed in the ES5 spec and later revisions.
References remain in use by the ES5 spec for the purpose of simplifying the
assignment rule, and because browser-extensions may internally use them. They
should never be visible to executed code. We retain references, as they are a
useful abstraction in this model of the language -- they greatly simplify the
number of assignment rules required.

The \js{def} function is definable in the full SES language using the
\js{for..each} construct. As this poses formalisation issues (non-determinism),
it has been decided to not model \js{for..each}, but \js{def} directly in the
operational semantics.

SES permits more granular properties than we model here. We only model
per-object freezing, SES permits this on a per-field basis. We also do not make
the distinction between data and accessor properties, (SES permits values of
accessor properties to be modified through the accessor after the object is
frozen). This choice may need to be reviewed at a later point.

\section{Program Logic}

\newcommand{\defline}[2]{#1 & \qquad & \text{#2}\\}
\begin{display}{Definitions}
  $\begin{array}{lll}
    \defline{h,h_g \in}{Abstract heap}
    \defline{h,h_g,L,\env \satisfies P}{Satisfaction relation}
    \defline{\tr{P}{\js{x}}{Q}}{Hoare triple}
  \end{array}$
\end{display}

\newcommand{\asrtline}[3][\pipe]{#1 & #2 & \text{#3}\\}
\begin{display}{Assertions}
  $\begin{array}{rll}
    \asrtline[P ::=]{P \land P \pipe P \lor P \pipe \lnot P \pipe \true \pipe
    \false}{Boolean formulas}
    \asrtline{P \sep P \pipe P \wand P \pipe P \sepish P}{Structural formulas}
    \asrtline{\bigsep_{x \in \T{set}} P(x)}{Iterative $\sep$}
    \asrtline{P \boxwand Q}{Global `hypothesis' formula}
    \asrtline{(E,E) \pointsto E \pipe \lemp}{Heap formulas}
    \asrtline{E \bp E}{Backpointer formula}
    \asrtline{E = E}{Expression equality}
    \asrtline{\forall X \st P \pipe \exists X \st P}{First-order formulas}
  \end{array}$
\end{display}

\newcommand{\assaxiom}[1]{\>$h,h_g,L,\env \satisfies #1$}
\newcommand{\asssat}[3]{\assaxiom{#1}\>$\iff$\>$#2$\\%
\ifblank{#3}{}{\>\>\>\quad$#3$\\}}
\begin{display}{Assertion satisfaction relation}
\hspace{1.5em} \= $h,h_g,L,\env \satisfies (E_1,E_2) \pointsto E_3$ \= $\iff$ \= \kill

\assaxiom{\true} \\
%    h,h_g,L,\env \not\satisfies \false \\
\asssat{P \land Q}{(h,h_g,L,\env \satisfies P) \land (h,h_g,L,\env \satisfies Q)}{}
\asssat{P \lor Q}{(h,h_g,L,\env \satisfies P) \lor (h,h_g,L,\env \satisfies Q)}{}
\asssat{\lnot P}{\lnot(h,h_g,L,\env \satisfies P)}{}
\asssat{P \sep Q}{\exists h_1,h_2 \st h \equiv h_1 \sep h_2 \land{}}
  {(h_1,h_g,L,\env \satisfies P) \land (h_2,h_g,L,\env \satisfies Q)}
\asssat{P \sepish Q}{\exists h_1,h_2,h_3 \st
    h \equiv h_1 \disju h_2 \disju h_3 \land{}}
  {(h_1 \disju h_3, h_g, L, \env \satisfies P) \land
    (h_2 \disju h_3, h_g, L, \env \satisfies Q)}
\asssat{P \wand Q}{\forall h' \st (h',h_g,L,\env \satisfies P) \land h \disj h'
    \land h' \subseteq h_g}
  {\impl (h \disju h', h_g, L, \env \satisfies Q)}
%h,h_g,L,\env \satisfies \upd P}{h, h_g[h], L, \env \satisfies P }\\
%h,h_g,L,\env \satisfies P?Q}{h, h_g[h], L, \env \satisfies P }\\
%P \boxwand Q & \triangleq & P \wand P ? Q }\\
\asssat{P \boxwand Q}{\forall h' \st (h',h_g[h'],L,\env \satisfies P)
    \land h \disj h'}
  {\impl (h \disju h', h_g[h'], L, \env \satisfies Q)}
\asssat{(E_1,E_2) \pointsto E_3}{h \equiv (\evalle{E_1}, \evalle{E_2}) \pointsto
  \evalle{E_3}}{}
\asssat{E_1 \bp E_2}{\forall (l,x) \in \dom(h_g) \st h_g(l,x) = \evalle{E_1}}
  {\impl (l,x) \in \evalle{E_2}}
\asssat{\lemp}{h = \emp}{}
\asssat{\exists\V X \st P}{\exists \V{v} \st h,h_g,L,[{\env} | \V X\takes \V{v}]
  \satisfies P}{}
\asssat{\forall\V X \st P}{\forall \V{v} \st h,h_g,L,[{\env} | \V X\takes \V{v}]
  \satisfies P}{}
\asssat{\bigsep_{x\in\{\}}P(x)}{h,h_g,L,{\env}\satisfies\lemp}{}
\asssat{\bigsep_{x\in\T{set}}P(x)}{y\in\T{set} \land h,h_g,L,{\env} \satisfies
  P(y)\sep(\bigsep_{x\in(\T{set}\setminus y)}P(x))}{}
\end{display}

\FIXME{Give $\bp$ a footprint to prevent contradictory assertions/implication}

The definition of $\wand$ is awkward, by introducing the global view of the
heap, we cannot keep both the right-adjoint property of $\sep$
($P \sep Q \vdash R \iff P \vdash Q \wand R$)
and maintain use of $\wand$ as the weakest precondition for a command.

The definition of $\wand$ here is that which maintins the right-adjoint property. The
ability to express weakest preconditions is enabled through the introduction
% of $\upd P$ to maintain consistency between local and global views of the heap.
of box-wand, $\boxwand$, a modified version of $\wand$ that also updates the
state of the global heap used for evaluation of sub-expressions.

% By using it in conjunction with the $\wand$ operator,
It can be used to apply
a \emph{hypothesis} about a future state of the heap to the global view of the
heap. This maintains the ability to express conditions like ``if I make
the heap look like P, then Q will hold''.

\subsection{Hoare Triples}
Definition:
\[ \tr{P}{\js{e}}{Q} \]
Soundness:
\[ (h, h \disju h_f, L, \env \satisfies P) \land h, L, \js{e} \leadsto h', v
  \impl (h', h' \disju h_f, L, \env \satisfies Q) \]
Fault avoidance:
\[ h, h_g, L, \env \satisfies P \land h\subseteq h_g \impl h, L, \js{e} \not\leadsto \fault \]
Safety monoticity:
\[ (h, h_g, L, \env \satisfies P) \land h \disj h' \land h, L, \js{e} \not\leadsto
  \fault \land h\subseteq h_g \impl h \disju h', L, \js{e} \not\leadsto \fault \]
Frame property:
\[ (h, h_g, L, \env \satisfies P) \land h, L, \js{e} \not\leadsto \fault \land
  h \disju h', L, \js{e} \leadsto h_2' \land h\subseteq h_g\impl h, L, \js{e} \leadsto h_2 \land
  h_2' = h_2 \disju h' \]

An alternative formulation which emphasises the relationship between the global
view of the heap and the framing property ($h_g = h \disju h_f$) can also be
produced, it should be noted that the meaning is subtly different (in that $h'
\neq h_g$ in all cases).

\TODO{More Auxiliary predicates}
\begin{display}{Auxiliary Predicates}
  \jaxiom{\bpGen(V,\_,\_,\_)}{V \notdotin \loc} \\
  \jaxiom{\bpGen(V,L,x,s)}{V \dotin \loc \sep V \bp \{(L,x)\} \cup s} \\
  \jaxiom{\auxDef(V,s,\_)}{\lemp \quad \mbox{if } V \notdotin \loc \lor V \dotin
    s} \\
  \jaxiom{\auxDef(V,s,b)}{(V, @frozen) \pointsto b \sep (\bigsepish_{x_n \in
    \uvars} (V,x_n) \pointsto V' \sepish \auxDef(V', s\cup\{V\}, b))}
\end{display}

\begin{display}{Inference Rules}
  \stateaxiom{(Declaration)}
    {\tr {\lemp} {\jsvar{x}} {\rv \doteq \und}}
  \vg

  \stateaxiom{(Value)}
    {\tr {\lemp} {\js{v}} {\rv \doteq \js{v}}}
  \vg

  \staterule{(Variable)}
    {P = \scope(Ls_1, \ls, \js{x}, L) \sepish \getValue(Ls_2, \fld{L}{\js{x}}, V)}
    {\tr P {\js{x}} {P \sep \rv \doteq \fld{L}{\js{x}}}}
  \vg

  \staterule{(Member Access)}
    {\tr P {\js{e}} {Q \sep \rv \doteq V} \quad Q = R \sep \getValue(Ls, V, L)
      \sep L \not\doteq \nil \sep L\dotin\loc}
    {\tr P {\js{e.x}} {Q \sep \rv \doteq \fld{L}{\js{x}}}}
  \vg

  \staterule{(Computed Access)}
    {
      \tr {P} {\js{e_1}} {R \sep \rv \doteq V_1} \quad R = S_1 \sep
      \getValue(Ls_1, V_1, L) \sep L \not\doteq \nil \sep L\dotin\loc\\
      \tr {R} {\js{e_2}} {Q \sep X \dotin \uvars \sep \rv \doteq V_2}
      \quad Q = S_2 \sep \getValue(Ls_2, V_2, X)
    }
    {\tr {P} {\js{e_1[e_2]}} {Q \sep \rv \doteq \fld{L}{X}}}
  \vg

  \staterule{(Bin Op)}
    {
      \tr P {\js{e_1}} {R \sep \rv \doteq V_1} \quad R = S_1 \sep \getValue(Ls,
      V_1, V_3) \\
      \tr R {\js{e_2}} {Q \sep \rv \doteq V_2} \quad Q = S_2 \sep \getValue(Ls,
      V_2, V_4) \\
      V = V_3 \mathbin{\bar\oplus} V_4
    }
    {\tr P {\js{e_1} \oplus \js{e_2}} {Q \sep \rv \doteq V}}
  \vg

  \staterule{(Assign)}
    {
      \tr P {\js{e_1}} {R \sep \rv \doteq \fld{L}{X}} \\
      \tr R {\js{e_2}} {Q \sep (L,X) \pointsto V_3 \sep \rv \doteq V_1} \\
      Q = S \sep \getValue(Ls, V_1, V_2) \sep \ReadWrite(L) \sep
      \bpGen(V_2, L, X, s)
    }
    {\tr P {\js{e_1 = e_2}} {Q \sep (L,X) \pointsto V_2 \sep \rv \doteq V_2}}
  \vg

  \staterule{(This)}
  { P = \scope(Ls, \ls, @this, L_1) \sepish \proto(Ls_2, L_1, @this, L_2)
    \sepish (L_2,@this) \pointsto V }
  {\tr P {\js{this}} {P \sep \rv \doteq V}}
  \vg

  \staterule{(Function)}
  {
    P = \lop \bp s_1 \sep \lfp \bp s_2 \sep \bigsep_{0\leq i<\length(\ls)} \lstitem(i,\ls) \bp s'_i \\
      Q = \left(\begin{array}{l}
          \exists L_1,L_2 \st \newobj(L_1,@proto) \sep (L_1,@proto) \pointsto \lop
    \sep \newobj(L_2,@proto, \js{prototype}, @scope, @body) \sep {}\\
    L_2 \bp \{\} \sep \fun(L_2, \ls, x, e, L_1) \sep \rv \doteq L_2 \sep
    L_1 \bp \{(L_2, \js{prototype})\} \sep {} \\
    \lop \bp s_1 \cup \{(L_1,@proto)\} \sep \lfp \bp s_2 \cup
      \{(L_2,@proto)\} \sep \bigsep_{0\leq i<\length(\ls)} \lstitem(i,\ls) \bp \{(L_2,@scope)\} \cup s'_i
    \end{array}\right)
  }
  {\tr P {\jsfun{x}{e}} Q}
  \vg

  \staterule{(Named Function)}
    {
      P = \lop \bp s_1 \sep \lfp \bp s_2 \sep
        \bigsep_{0\leq i<\length(\ls)} \lstitem(i,\ls) \bp s'_i \\
      Q = \left(\begin{array}{l}
      \exists L_1, L_2, L_3 \st \newobj(L_1, @proto) \sep (L_1, @proto)
      \pointsto \lop \sep \newobj(L_3,@proto,y) \sep (L_3, @proto) \pointsto
      \nil \sep {} \\
      (L_3,\js{y}) \pointsto L_2 \sep L_2 \bp \{(L_3,\js{y})\} \sep
      L_3 \bp \{(L_2,@scope)\} \sep
      \newobj(L_2,@proto,\js{prototype},@scope,@body) \sep {} \\
      \fun(L_2,(L_3:\ls), \js{x}, \js{e}, L_1) \sep \rv \doteq L_2 \sep
      L_1 \bp \{(L_2, \js{prototype})\} \sep {} \\
      \lop \bp \{(L_1, @proto)\} \cup s_1 \sep \lfp \bp \{(L_2, @proto)\}
      \cup s_2 \sep  \bigsep_{0\leq i<\length(\ls)} \lstitem(i,\ls) \bp \{(L_2,@scope)\} \cup s'_i
      \end{array}\right)
    }
    {\tr P {\jsfun[y]{x}{e}} Q}
  \vg

  \staterule{(Object)}
    {
      \forall i \in 1..n \st \left(\begin{array}{l}
        P_i = R_i \sep \getValue(Ls_i, Y_i, X_i) \sep
          X_i \bp s_i \\
        \tr {P_{i-1}} {\js{e_i}} {P_i \sep \rv \doteq Y_i} \\
      \end{array}\right) \\
      P_n = R \sep \lop \bp s_{op} \\
      Q = R \sep
      \exists L \st \left(\begin{array}{l}
        \newobj(L, @proto, \js{x_1} \ldots \js{x_n}) \sep {} \\
        \bigsep_{1 \leq i \leq n} (
          (L, \js{x_i}) \pointsto X_i \sep \bpGen(X_i, L,\js{x_i}, s_i)
        ) \sep {} \\
        (L,@proto) \pointsto \lop \sep \lop \bp s_{op} \cup \{(L,@proto)\} \sep {} \\
        \rv \doteq L \sep L \bp \{\} \\
      \end{array}\right) \\
      \js{x_1} \neq \dots \neq \js{x_n} \qquad \rv \not\in \fv(P_n)
    }
    {\tr {P_0} {\js{\{x_1:e_1, ..., x_n:e_n\}}} Q}
  \TODO{Consider situations when $X_n = X_{n+1}$ for bp sets. Also consider if
    subexpression \js{ei} modifies the $\lop$ bp set (eg, object creation,
    assigns $\lop$ to $@proto$), since we expressly update
    it again in $P_n$ (eg: \js{\{x:\{\}\}}). Must ensure we retain inclusion
    relationships between $s_n$s during iteration}
  \COMMENT{I \emph{think} the $\lop$ bp should work as specified here - we get
    the $\lop$ bp set out of $P_n$ as $s_{op}$ - it may have been updated
    multiple times in the precondition loop.}
  \vg

  \staterule{(Function Call)}
    {
      \tr P {\js{e_1}} {R_1 \sep \rv \doteq F_1} \\
      R_1 = \left(\begin{array}{l}
          S_1 \sepish \pickThis(F_1, T) \sepish \getValue(Ls_1, F_1, F_2) \sep {} \\
          (F_2, @body) \pointsto \lambda X.\js{e_3} \sep (F_2, @scope) \pointsto
          Ls_2
      \end{array}\right) \\
      \tr {R_1} {\js{e_2}} {R_2 \sep T \bp s \sep \bpGen(V_2,\_,\_,s') \sep
        \ls \doteq Ls_3 \sep \rv \doteq V_1} \\
      R_2 = S_2 \sep \getValue(Ls_4, V_1, V_2) \\
      R_3 = \left(\begin{array}{l}
          R_2 \sep \exists L \st \ls \doteq L:Ls_2 \sep (L, X) \pointsto V_2
          \sep (L, @this) \pointsto T \sep (L, @proto) \pointsto \nil \sep
          \defs(X,L,\js{e_3}) \sep {} \\
          \newobj(L,@proto,@this,\js{x},\vardecls(X, L, \js{e_3})) \sep
          L \bp \{\} \sep T \bp \{(L,@this)\} \cup s \sep
          \bpGen(V_2, L, X, s')
      \end{array}\right) \\
      \tr {R_3} {\js{e_3}} {\exists L \st Q \sep \ls \doteq L:Ls_2} \qquad
      \ls \notin \fv(Q) \cup \fv(R_2)
    }
    {\tr P {\js{e_1(e_2)}} {\exists L \st Q \sep \ls \doteq Ls_3}}
  \vg

  \staterule{(New)}
    {}
    {}
%  \vg

  % SES-specific
  \COMMENT{Work in progress}
  \staterule{(Restricted evaluation)}
    {
      \tr{P}{\js{e_1}}{R_1 \sep \rv \doteq V_1} \\
      R_1 = S_1 \sep \getValue(\_, V_1, V_2) \sep V_2 \dotin \text{String} \\ %% FIXME: STRING
      \parse(V_2) = \js{e_3} \\
      \tr{R_1}{\js{e_2}}{R_2 \sep \rv \doteq V_3 \sep \ls \doteq Ls \sep \gv \doteq g} \\
      R_2 = \left(\begin{array}{l}
        S_2 \sep \getValue(\_, V_3, V_4) \sep V_4 \dotin \loc \sep {} \\
        \exists L \st R_3 \sep
        \newobj_L(@proto,@this,\vardecls(...,\js{e_3})) \sep {} \\
        \obj_L(@this: V_2, @proto: \nil) \sep \defs(...,\js{e_3}) \\
      \end{array}\right) \\
      R_3 = (\ls \doteq L:[V_2] \sep \gv \doteq V_2) \\
      \tr{R_2}{\js{e_3}}{\exists L \st Q \sep R_3}
    }
    {\tr{P}{\js{reval(e_1,e_2)}}{\exists L \st Q \sep \ls \doteq Ls \sep \gv \doteq g}}
  \vg

  \staterule{(Freeze)}
    {
      \tr{P}{\js{e}}{Q \sep \rv \doteq V_1 \sep (V_2, @frozen) \pointsto V_3} \\
      Q = \getValue(\_,V_1,V_2) \sep S
    }
    {\tr{P}{\js{freeze(e)}}{Q \sep (V_2, @frozen) \pointsto \true \sep \rv \doteq V_2}}
  \vg

  \staterule{(Recusive freeze)}
    {
      \tr{P}{\js{e}}{Q \sep \rv \doteq V_2 \sep \auxDef(V_2, \{\}, \_)} \\
      Q = \getValue(\_,V_1,V_2) \sep S
    }
    {\tr{P}{\js{def(e)}}{Q \sep \rv \doteq V_2 \sep \auxDef(V_2, \{\}, \true)}}
  \vg

  % Control flow
  \staterule{(Sequence)}
    {\tr P {\js{e_1}} R \quad \tr R {\js{e_2}} Q}
    {\tr P {\js{e_1; e_2}} Q}
  \vg

  \staterule{(If True)}
    {\tr P {\js{e_1}}{S\sep \istrue(\E{V_2})\sep\rv\doteq\E{V_1}} \qquad
     S = R \sep \getValue(Ls,\E{V_1},\E{V_2})\\
     \tr {S}{\js{e_2}} Q}
    {\tr P {\js{if(e_1)\{e_2\}\{e_3\}}} Q}
  \vg

  \staterule{(If False)}
    {\tr P {\js{e_1}}{S\sep \isfalse(\E{V_2})\sep\rv\doteq\E{V_1}} \qquad
     S = R \sep \getValue(Ls,\E{V_1},\E{V_2})\\
     \tr {S}{\js{e_3}} Q}
    {\tr P {\js{if(e_1)\{e_2\}\{e_3\}}} Q}
  \vg

  \staterule{(While)}
    {\tr P {\js{e_1}} {S\sep\rv\doteq\E{V_1}} \qquad
    S = R \sep \getValue(Ls,\E{V_1},\E{V_2})\\
     \tr {S \sep \istrue(\E{V_2})} {\js{e_2}} P\\
     Q = S \sep \isfalse(\E{V_2})\sep\rv\doteq\und\qquad
     \rv\not\in \fv(R)}
    {\tr P {\js{while(e_1)\{e_2\}}} Q}
  \vg

  % Standard
  \staterule{(Frame)}
    {\tr P {\js{e}} Q}
    {\tr {P \sep R} {\js{e}} {Q \sep R}}

  \staterule{(Consequence)}
    {\tr {P'} {\js{e}} {Q'} \\
     P \impl P' \quad Q' \impl Q}
    {\tr P {\js{e}} Q}
  \vg

  \staterule{(Elimination)}
    {\tr P {\js{e}} Q}
    {\tr {\exists X \st P} {\js{e}} {\exists X \st Q}}

  \staterule{(Disjunction)}
    {\tr{P_1}{\js{e}}{Q_1} \quad \tr{P_2}{\js{e}}{Q_2}}
    {\tr{P_1 \lor P_2}{\js{e}}{Q_1 \lor Q_2}}

\end{display}

\subsection{Notes}
The existing backpointers paper\cite{KassiosKritikos12} is the first case in
which we've seen the concept of a backpointer being used with separation logic
to count references. However, these backpointers are implemented as \emph{ghost
fields} as members of the data structures under examination in the Chalice
tool.

Each object that is being tracked for pointers $o$, has a field, named $T.f^{-1}$
which contains the set of objects of type $T$, whose $f$ field
points to $o$.

These ghost fields are updated by the program logic using the inference rules
for assignment.

These sorts of backpointers are not suitable for our use for a number of
reasons: explicit references to field name and object type on
which references may be stored limit the flexibility of pointer tracking,
although it is suitable for this case of reference counting, it is not suitable
for more a general security analysis. Secondly, the set of pointers recorded is
exactly those in existence, it may be useful for the logic to be more flexible
about this definition, say for those objects in the set to be \emph{at least}
those that point to the tracked object.

Using the ``at most'' semantics allows for the rule of consequence to be used to
add new items to the set at any time. \emph{Note: should probably consider the
impact of this on reachability, as well as non-reachability analysis.}

\section{Proofs}
\subsection{Revocable Reference}
Used to provide a restricted execution context with a reference to an object
that may be revoked by the provider.
\emph{Note: By itself, this is not safe, since accessed references are returned
  raw. See next section, Membrane, for solution.}

\begin{verbatim}
var RevocableRef = function(ref) {
  var protected = ref;
  var access = function(field) { return protected[field]; }
  var kill = function() { protected = null; }
  return {access: access, kill: kill};
}
\end{verbatim}

Proofs are given in Figures~\ref{rr-main}-\ref{rr-access}.

\begin{displaymath}
  \begin{array}{rcl}
  \fullobj_{E}(E_1:E_1',\dots,E_n:E_n') &\triangleq&
    \obj_{E}(E_1:E_1',\dots,E_n:E_n') \sep \newobj_{E}(E_1,\dots,E_n) \\
  \newfun_{E}(E_1,E_2,E_3,E_4) &\triangleq& \fun_{E}(E_1,E_2,E_3,E_4) \sep
    \newobj_{E}(@proto, \js{prototype}, @scope, @body) \\
  \scopePtrs(Ls, s, s', n) &\triangleq& \bigsep_{0\leq i<\length(Ls)}
    \lstitem(i,Ls) \bp \lstitem(i,s') \sep \lstitem(i,s') \doteq \lstitem(i,s) \cup n
\end{array}
\end{displaymath}

% RevocableRef body call
%
% I've generally unwrapped all \scope, \proto, \getValue operations down to
%   their requirements
% Introduction of new elements into an existing backpointer set seems clumsy
% There must be better ways of generating these proofs other than by hand?
\begin{figure}
\[
  \begin{array}{l}
    \js{var RevocableRef = function(ref) \{}\\
    \begin{array}{@{\qquad}l}
      \logic{
        % function
        \obj_R(@body: \lambda\js{ref}.\{\dots\} , @scope: Ls) \sep {} \\
        % ar
          \exists L \st \ls \doteq L:Ls \sep {} \\
          \fullobj_L\left(
            \begin{array}{l}
              \js{ref}: V,@this: \_,@proto: \nil,@frozen: \false,\\
              \js{protected}: \und,\js{access}: \und,\js{kill}: \und %  and defs()
            \end{array}
          \right) \sep {} \\
        % bp
          L \bp \{\} \sep V \bp s_1 \cup \{(L,\js{ref})\} \sep
          \lop \bp s_3 \sep \lfp \bp s_4 \sep
          % L <- {} and L <- s'_1 through scopePtrs!
          \scopePtrs(\ls, s', s', \{\})
      } \\
      \step{Frame/elim/cons ($V \bp s_1 \impl V \bp s_1 \cup s_2$)} \\
      \logic{
        % var(protected,ref), assign(@frozen)
          \obj_L(\js{protected}: \und, \js{ref}: V, @frozen: \false) \sep {} \\
        % assign
          V \bp s_1 \cup \{(L,\js{ref}), (L, \js{protected})\} \sep \ls\doteq{L:Ls}
      } \\
      \js{var protected = ref;} \\
      \logic{
        % var *2
          \obj_L(\js{protected}: V, \js{ref}: V, @frozen: \false) \sep {} \\
        % assign
          V \bp s_1 \cup \{(L,\js{ref}), (L, \js{protected})\}\sep \ls\doteq{L:Ls}
      } \\
      \step{Frames/cons} \\
      \logic{
        % var(access), assign(@frozen)
          \obj_L(\js{access}: \und, @frozen: \false) \sep {} \\
        % fun pre
        \lop \bp s_3 \sep \lfp \bp s_4 \sep
          \scopePtrs(\ls,s',s',\{\}) \sep \ls\doteq{L:Ls}
      } \\
      \js{var access = function(field) \{b_a\};} \\
      \logic{
        \exists A, A_p \st \left(\begin{array}{l}
          % var, assign
          \obj_L(\js{access}: A, @frozen: \false) \sep
            A \bp s_7 \sep s_7 \doteq \{(L, \js{access})\} \sep {} \\
          % fun pre
          \lop \bp s_5 \sep s_5 \doteq s_3 \cup \{(A_p, @proto)\} \sep \lfp \bp s_6 \sep s_6 \doteq s_4
            \cup \{(A, @proto)\} \sep {} \\
            \scopePtrs(\ls, s', s'_1, \{(A,@scope)\}) \sep {} \\
          % fun post
          \fullobj_{A_p}(@proto: \lop) \sep A_p \bp \{(A, \js{prototype})\} \sep {}\\
          \newfun_A(\ls, \js{field}, b_a, A_p)
        \end{array}\right) \sep \ls\doteq{L:Ls}
      } \\
      \step{Frames/cons} \\
      \logic{
        % var(access), assign(@frozen)
          \obj_L(\js{kill}: \und, @frozen: \false) \sep {} \\
        % fun pre
        \lop \bp s_5 \sep \lfp \bp s_6 \sep
        \scopePtrs(\ls, s'_1, s'_1,\{\}) \sep \ls\doteq{L:Ls}
      } \\
      \js{var kill = function() \{b_k\};} \\
      \logic{
        \exists K, K_p \st
        \left(\begin{array}{l}
          % var, assign
          \obj_L(\js{kill}: K, @frozen: \false) \sep
            K \bp s_8 \sep s_8 \doteq \{(L, \js{kill})\} \sep {} \\
          % fun pre
          \lop \bp s_9 \sep s_9 \doteq s_5 \cup \{(K_p, @proto)\} \sep \lfp \bp s_6
            \cup \{(K, @proto)\} \sep {} \\
          \scopePtrs(\ls, s'_1, s'_2, \{(K,@scope)\}) \sep {} \\
          % fun post
          \fullobj_{K_p}(@proto: \lop) \sep K_p \bp \{(K, \js{prototype})\} \sep {} \\
          \newfun_K(\ls, \_, b_k, K_p)
        \end{array}\right)\sep \ls\doteq{L:Ls}
      } \\
      \step{Frames} \\
      \logic{
        \obj_L(\js{access}:A, \js{kill}:K) \sep
        A \bp s_7 \sep K \bp s_8 \sep \lop \bp s_9 \sep \ls \doteq L : Ls
      } \\
      \js{return \{access: access, kill: kill\};} \\
      \logic{
        \exists O \st
        \left(\begin{array}{l}
          \obj_L(\js{access}:A, \js{kill}:K) \sep {} \\
          \fullobj_O(@proto: \lop, \js{access}: A, \js{kill}: K) \sep {} \\
          A \bp s_7 \cup \{(O, \js{access}\} \sep K \bp s_8 \cup \{(O, \js{kill})\}
            \sep {} \\
          \lop \bp s_9 \cup \{(O,@proto)\} \sep O \bp \{\} \sep \rv \doteq O
        \end{array}\right)
        \sep \ls \doteq L : Ls
      } \\
      \step{Frames} \\
      \logic{
        \obj_R(@body: \lambda\js{ref}.\{\dots\} , @scope: Ls) \sep {} \\
        \exists L, A, A_p, K, K_p, O \st {} \\
        \fullobj_L\left(\begin{array}{l}
          \js{ref}: V,@this: \_,@proto: \nil,@frozen: \false,\\
          \js{protected}: V,\js{access}: A,\js{kill}: K
        \end{array}\right) \sep {} \\
        \fullobj_{A_p}(@proto: \lop) \sep \fullobj_{K_p}(@proto: \lop) \sep {} \\
        \newfun_A(\ls,\js{field},b_a,A_p) \sep \newfun_K(\ls,\_,b_k,K_p) \sep {} \\
        \fullobj_O(@proto: \lop, \js{access}: A, \js{kill}: K) \sep {} \\

        \lop \bp s_3 \cup \{(A_p,@proto),(K_p,@proto),(O,@proto)\} \sep {} \\
        \lfp \bp s_4 \cup \{(A,@proto),(K,@proto)\} \sep {} \\
        A   \bp \{(L,\js{access}),(O,\js{access})\} \sep
          A_p \bp \{(A,\js{prototype}) \sep {} \\
        K   \bp \{(L,\js{kill}),(O,\js{kill})\} \sep
          K_p \bp \{(K,\js{prototype}) \sep {} \\
        V   \bp s_1 \cup \{(L,\js{ref}),(L,\js{protected})\} \sep
          \scopePtrs(\ls,s'_2,s'_2,\{\}) \sep {} \\
        O   \bp \{\} \sep

        \rv \doteq O \sep \ls \doteq L : Ls
      }
    \end{array} \\
    \js{\}}
  \end{array}
\]
\caption{RevocableRef: Main body}
\label{rr-main}
\end{figure}

% RevocableRef#kill body call
\begin{figure}
\[
  \begin{array}{l}
    \js{var kill = function() \{} \\
    \begin{array}{@{\qquad}l}
      \logic{
        (K, @body) \mapsto \lambda \_.\{b_k\} \sep (K, @scope) \mapsto L:Ls \sep {} \\
        \exists L' \st \ls \doteq L' : L : Ls \sep L' \bp \{\} \sep {} \\
        \fullobj_{L'}(@proto:\nil, @frozen:\false, @this:\_) \sep {} \\
        \obj_L(\js{protected}: V, @frozen: \false)
      } \\
      \step{Frame/exists} \\
      \logic{
        obj_{L'}(\js{protected}: \none, @proto: \nil) \sep {} \\
        obj_L(\js{protected}: V, @frozen: \false) \sep {} \\
        \ls \doteq L':L:Ls
      } \\
      \js{protected = null;} \\
      \logic{
        obj_{L'}(\js{protected}: \none, @proto: \nil) \sep {} \\
        obj_L(\js{protected}: \nil, @frozen: \false) \sep {} \\
        \ls \doteq L':L:Ls \sep \rv \doteq \nil
      } \\
      \step{Frame/exists} \\
      \logic{
        (K, @body) \mapsto \lambda \_.\{b_k\} \sep (K, @scope) \mapsto L:Ls \sep {} \\
        \exists L' \st \ls \doteq L' : L : Ls \sep L' \bp \{\} \sep {} \\
        \fullobj_{L'}(@proto:\nil, @frozen:\false, @this:\_) \sep {} \\
        \obj_L(\js{protected}: \nil, @frozen: \false) \sep \rv \doteq \nil
      } \\
    \end{array} \\
    \js{\}}
  \end{array}
\]
\caption{RevocableReference kill function body}
\label{rr-kill}
\end{figure}

\begin{figure}
% RevocableRef#access body call
\[
  \begin{array}{l}
    \js{var access = function(field) \{} \\
    \begin{array}{@{\qquad}l}
      \logic{
        (A, @body) \mapsto \lambda \js{field}.\{b_a\} \sep
          (A, @scope) \mapsto L:Ls \sep {} \\
        \exists L' \st \ls \doteq L' : L : Ls \sep
          L' \bp \{\} \sep \bpGen(X, L', \js{field}, s) \sep {} \\
        \fullobj_{L'}(@this: \_, @proto: \nil, @frozen: \false, \js{field}: X)
          \sep {} \\
        (L, \js{protected}) \mapsto P \sep P \not\doteq \nil \sep P \dotin \loc
          \sep X \dotin \uvars
      } \\
      \step{Frame/exists} \\
      \logic{
        \obj_{L'}(\js{protected}: \none, @proto: \nil, \js{field}: X) \sep {} \\
        (L, \js{protected}) \mapsto P \sep P \not\doteq \nil \sep P \dotin \loc
          \sep {} \\
        X \dotin \uvars \sep \ls \doteq L':L:Ls
      } \\
      \js{return protected[field];} \\
      \logic{
        \obj_{L'}(\js{protected}: \none, @proto: \nil, \js{field}: X) \sep {} \\
        (L, \js{protected}) \mapsto P \sep
        P \not\doteq \nil \sep P \dotin \loc \sep {} \\
        X \dotin \uvars \sep \ls \doteq L':L:Ls \sep \rv \doteq \fld{P}{X}
      } \\
      \step{Frame/exists} \\
      \logic{
        (A, @body) \mapsto \lambda \js{field}.\{b_a\} \sep
          (A, @scope) \mapsto L:Ls \sep {} \\
        \exists L' \st \ls \doteq L' : L : Ls \sep
          L' \bp \{\} \sep \bpGen(X, L', \js{field}, s) \sep {} \\
        \fullobj_{L'}(@this: \_, @proto: \nil, @frozen: \false, \js{field}: X)
          \sep {} \\
        (L, \js{protected}) \mapsto P \sep P \not\doteq \nil \sep P \dotin \loc
          \sep X \dotin \uvars \sep \rv \doteq \fld{P}{X}
      } \\
    \end{array} \\
    \js{\}}
  \end{array}
\]
\caption{RevocableReference access function body}
\label{rr-access}
\end{figure}

\FIXME{$L \bp \{\}$ conflicts with use of $\scopePtrs$ in overall precondition.}
\TODO{Extend to writing to objects via the proxy. Take careful note of
  \href{https://mail.mozilla.org/pipermail/es-discuss/2011-November/017981.html}
{Nov-11 es-discuss thread} (theft of \js{protected} by using \js{\_\_proto\_\_}
or through redefining/hiding a \emph{trusted prototypical} method (eg on Array))}

\subsection{Membrane}
\label{sec:membrane}
\gds{Remember to protect arguments to function calls as well as return values. This may also apply to ``set'' thingamies.}
A Membrane is a transitive Revocable Reference. In addition to the standard
Revocable Reference, all returned objects are also wrapped in a Revocable
Reference that shares its kill switch with its parent. All references to the
parent object and anything it created are removed simultaneously.

\TODO{THIS}
Introduce a predicate ProtectedLocation(Loc,Set,FuncP) which takes a
Location Loc, and the set of things that point to it Set, and gives you a
membrane function(thing) FuncP that protects it. (So the $\bp$ set will be
increased by the closure in the FuncP).

When you call access, it takes a ProtectedLocation and a location pointed to
by the ProtectedLocation, and returns a new ProtectedLocation for the inner
one.
\TODO{THAT}
\TODO{Check prototype chain for leaks? proxies/simpleMembrane.js}
\begin{verbatim}
var Membrane = function(ref) {
  var killSwitch = false;
  var MembraneRef = function MembraneRef(r) {
    var access = function(field) {
      if(!killSwitch) return MembraneRef(r[field]);
      else throw();
    }
    var kill = function() { killSwitch = true; }

    if(primitive(r)) return r;
    else return {access: access, kill: kill};
  }
  return MembraneRef(ref);
}
\end{verbatim}

\section{Abstraction Layers}
\TODO{Add abstraction layers to cope with the intuitions in Mark's diagrams}

\subsection{Eg: Membrane Proof Predicate}
. (ProtectedLoc? See Section~\ref{sec:membrane})
\subsection{Spiders}

For user variables only, for internal variables also. Useful for reval code?

\section{Future Work}
\subsection{Uberchallenge}
Page 13 of
  \url{http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/en/us/pubs/archive/40673.pdf}:
  prove the program with a temporary variable for the updated balance. Find the
  bug.  Not a concurrency issue. Ignore Q. Use the version from Mark's slides.

\subsection{makeContractHost}
      It's not all about code equality. We actually want the mutually
      agreed contracts to have compatible specifications, not
      necessarily be equal.

      We can use footprint disjointness to automatically negotiate
      multi-party contracts between many mutually untrusting and
      unaware parties.

      Code equality is a degenerate form of spec equality.

      There is some relationship between these ideas and the e
      auditor.

\bibliography{bibliography}
\bibliographystyle{babplain}

\end{document}
