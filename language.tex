\documentclass[a4paper]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{wasysym}
\usepackage{xspace}
\usepackage{fullpage}
\usepackage{hyperref}
\usepackage{separationlogic}
\usepackage[english]{babel}
\usepackage[fixlanguage]{babelbib}

\begin{document}

\section{SES Syntax and Description}

\newcommand{\gds}[1]{\ifmmode \textbf{**** gds: }\textrm{#1}\textbf{****}\else
  \textbf{\\************************************\\
    gds: }#1\\\textbf{************************************}
  \fi}

\newcommand{\syntaxline}[3][\pipe]{#1 & \js{#2} & \textit{#3}\\}
\begin{display}{Syntax of SES values and expressions, $v, e$}
  $\begin{array}{rll}
    \syntaxline[v ::=]{$n$}{Number}
    \syntaxline{$s$}{String}
    \syntaxline{undefined}{Undefined}
    \syntaxline{null}{Null}
    \syntaxline[e ::=]{$v$}{Value}
    \syntaxline{$x$}{Identifier}
    \syntaxline{\{$x_1$:$e_1$, $\ldots$, $x_n$:$e_n$\}}{Object creation}
    \syntaxline{$e$; $e$}{Sequence}
    \syntaxline{$e \oplus e$}{Binary operator}
    \syntaxline{if($e$) \{$e$\} else \{$e$\}}{Conditional}
    \syntaxline{while($e$) \{$e$\}}{Looping}
    \syntaxline{var $x$}{Variable declaration}
    \syntaxline{$e$ = $e$}{Assignment}
    \syntaxline{$e$.$x$}{Member access}
    \syntaxline{$e$[$e$]}{Computed member access}
    \syntaxline{$e$($e$)}{Function call}
    \syntaxline{this}{this}
    \syntaxline{function($e$) \{$e$\}}{Function creation}
    \syntaxline{function $x$($e$) \{$e$\}}{Named function creation}
    \syntaxline{new $e$($e$)}{Object construction}
    \syntaxline{reval($e$, $e$)}{Restricted evaluation}
    \syntaxline{freeze($e$)}{Object freeze}
    \syntaxline{def($e$)}{Recursive \js{freeze}}
  \end{array}$
\end{display}

An object is a location in the heap, it contains a set of
values indexed by fields.
For the purposes of this semantics, \js{null} and \js{undefined} behave
interchangably.
\gds{You say this, but then you don't mention \js{null} until you get to
  inference rules (where it'd better not be just like \js{undefined}), and you
  only mention \js{undefined} when talking about \js{this}. I think you just
  don't need that last sentence.}

\paragraph{Object creation}  The Object Construction syntax produces a new object
with fields named $x_1, \ldots, x_n$ which map to the values of expressions
$e_1, \ldots, e_n$ when evaluated in order at creation.

\paragraph{Sequence} The sequencing operator specifies that the expression on the left should be
evaluated, followed by the expresion on the right.

\paragraph{Binary operator} Binary operations are evaluated left-to-right, and includes standard
mathematical and string operations. Formalisation of semantics for all of these
are beyond the scope of this project, but will correspond closely to similar
works on the JavaScript family of languages.

\paragraph{Conditional} The conditional expression evaluates the first sub-expression, if it evaluates
to \js{true} under a boolean casting operation, the second sub-expression is
evaluated and result returned, otherwise the third sub-expression is evaluated
and result returned.
\gds{Be prepared to defend the lack of object-level casting. At the moment our
  simple semantics only cast primitive values.}

\paragraph{Looping} The looping expression executes the body sub-expression whilst the condition
sub-expression evaluates to true. The most-recently returned value of the body
is returned.
\gds{...or \js{undefined}}

\paragraph{Variable declaration} Variable declarations are used during activation
record creation
to determine free-variables when constructing a new scope. They are no-ops
during evaluation.

\paragraph{Assignment} Assigns the value on the right hand side to the named field on the
left.

\paragraph{Member access} Returns the value of the named field of the object referenced by
the subexpression.

\paragraph{Computed member access} As Member access, but the field name is derived from
the expression in \js{[]}.

\paragraph{Function creation} Creates a function object, assigning the body, parameter
declarations and the current scope to internal fields. A new object is also
created and assigned to the \js{prototype} field for use as the prototype of
objects produced by using this function as a constructor (this permits
emulation of a class-based language).

\paragraph{Named function creation} This syntax is the same as standard function creation,
but also adds the name and a self-reference to the function to the function's
scope record. This permits recursive functions to be created. \emph{Note:} the
name of the function is not added to the current scope, it is permitted in the
actual language, but is considered to be syntactic sugar, combining creation and
assignment.

\paragraph{Function call} Executes the body of the function, using the passed expression
as the value to bind to the parameter. The body of the function is executed in
the scope stored with the function, any variables defined within the function
body are defined on an activation record so that they are lexically scoped.

\paragraph{Object construction} Constructs an object using the given function, an object
is created as usual, it's prototype is assigned to that of the function's
\js{prototype} field. The body of the function is then exectuted, commonly used
to initialize the newly created object.

\paragraph{\js{this}} The \js{this} expression is context-dependent. When used outside of a
function, it should evaluate to the most global accessible scope.
When used within a function, it will evaluate to the object
on which that function was called. The root of a scope chain should poin In % <---- GDSGDSGDS
other cases, \js{this} returns undefined. Note that this is particularly
problematic because functions can easily be aliased off of the object on which
they appear to be defined.
\gds{``poin''?}

\paragraph{Restricted evaluation} Parse the first given expression as SES code. A new
scope chain is prepared, its root is the object specified by the second
parameter (the \emph{imports} to the restricted environment), an activation
record is then appended which initializes any variables declared in the parsed
source -- declared variables will hide imports of the same name. The return
value of the restricted evaluation statement is the same as that of the final
statement of the source to be executed.

\paragraph{Object freeze} Makes the provided object read-only, prevents field additions,
modifications and deletions.

\paragraph{Recursive freeze} Recursively calls freeze on all objects reachable
from the given object.
\gds{Reachable through user-accessible fields. Closure internal-fields are
  exempted.}

\section{Operational Semantics}
\begin{display}{Operational semantics: $H,L,\js e \evalsto H',v$}
  \stateaxiom{(Value)}
    {H,L,v \evalsto H,v}
\vg

  \stateaxiom{(Variable declaration)}
  {H,L,\js{var}\ x \evalsto H,\und}
\vg

  \staterule{(Object creation)}
    {H_0 = H \sep \obj(l,\lop)\\
     \forall i\in 1..n \st \left(\begin{array}{l}
      H_{i-1},L,\js{ei}\evalsto H_i',v_i \\
      H_i = H_i' [ (l,\js{xi}) \pointsto v_i]\end{array}\right)}
    {H,L,\{\js{x1:e1},\dots, \js{xn:en}\} \evalsto H_n,l}
\vg\gds{\\You need to define \obj somewhere. You might also want it to add a default value for @frozen}\vg

  \staterule{(Sequence)}
    {H,L,e_1 \evalsto H_1,v_1 \\
     H_1,L,e_2 \evalsto H',v}
    {H,L,e_1\js; e_2 \evalsto H',v}
\vg

  \staterule{(Binary operator)}
    {H,L,e_1 \evalsto H_1,v_1 \\
     H_1,L,e_2 \evalsto H',v_2\\
     v_1 \oplus v_2 = v}
    {H,L,e_1 \oplus e_2 \evalsto H',v}
\vg

  \staterule{(Conditional true)}
  {H,L,e_1 \evalsto H'',v' \quad \istrue(v') \\
   H'',L,e_2 \evalsto H',v}
  {H,L,\js{if($e_1$)\{$e_2$\} else \{$e_3$\}} \evalsto H',v}
\qquad

  \staterule{(Conditional false)}
  {H,L,e_1 \evalsto H'',v' \quad \isfalse(v') \\
   H'',L,e_3 \evalsto H',v}
  {H,L,\js{if($e_1$)\{$e_2$\} else \{$e_3$\}} \evalsto H',v}
\vg\gds{\\You need to define \istrue and \isfalse somewhere.}\vg

  \staterule{(While true)}
  {H,L,e_1 \evalsto H'', v \quad \istrue(v) \\
   H'',L,e_2\js{; while($e_1$)\{$e_2$\}} \evalsto H', v''}
  {H,L,\js{while($e_1$)\{$e_2$\}} \evalsto H',\und}
\qquad

  \staterule{(While false)}
  {H,L,e_1 \evalsto H', v \quad \isfalse(v)}
  {H,L,\js{while($e_1$)\{$e_2$\}} \evalsto H',\und}
\vg\gds{\\This doesn't match your description of loops. You said it returned the last value, not always \und.}\vg

  \staterule{(Variable)}
    {\scope(H,L,x) = l'}
    {H,L,\js x \evalsto H, \fld{l'}{x}}
\vg

  \staterule{(Member access)}
  {H,L,\js e \evalsto H',l' \\
   l' \neq \nil}
  {H,L,e\js{.}x \evalsto H', \fld{l'}{x}}
\qquad

  \staterule{(Computed member access)}
  {H,L,e_1 \evalsto H'',l' \\
   l' \neq \nil \\
   H'',L,e_2 \evalsto H', x}
  {H,L,e_1\js{[}e_2\js{]} \evalsto H',\fld{l'}{x}}
\vg

  \staterule{(\emph{Implicit} Dereference)}
  {\gamma(H,\fld{l}{x}) = v}
  {H,L,\fld{l}{x} \evalsto H,v}
  \vg\gds{\\Hm - this is a small-step technique. To see why it won't work in a big step setting, try drawing\\
    out the full derivation tree for an execution of \js{x=y} in the state ${\{(l,x)\pointsto3\sep(l,y)\pointsto4\},[l]}$}\vg

  \staterule{(Assignment)}
  {H,L,e_1 \evalsto H_1,\fld{l}{x} \qquad
   H_1(l, @frozen) \neq \true \\
   H_1,L,e_2 \evalsto H_2, v \\
   H' = H_2[(l,x) \pointsto v]}
  {H,L,e_1\js = e_2 \evalsto H', v}
\vg

  \staterule{(Function creation)}
  {H' = H \sep \obj(l,\lop) \sep \fun(l',L,x,e,l)}
  {H,L,\js{function($x$)\{$e$\}} \evalsto H',l'}
\vg

  \staterule{(Named function creation)}
  {H' = H \sep \obj(l,\lop) \sep \fun(l',l_1 \cons L,x,e,l) \sep l_1 \pointsto
    \{@proto:\nil, y:l'\}}
  {H,L,\js{function $y$($x$)\{$e$\}} \evalsto H',l'}
\vg

  \staterule{(Object construction)}
  {H,L,\js{e1} \evalsto H_1,{l_1} \qquad
   l_1\neq \nil\qquad
   H_1(l_1,@body)=\lambda \js{x.e3}\\
   H_1(l_1,@scope)= L'\qquad
   H_1(l_1,\js{prototype})= v\\
   H_1,L,\js{e2} \evalsto H_2,{v_1}  \qquad
   l_2 = \objOrGlob(v) \\
   H_3 = H_2\sep \obj(l_3,l_2) \sep\act(l,\js x,v_1,\js{e3},l_3)\\
   H_3,l \cons L',\js{e3} \evalsto H',v_2\qquad
   \getBase(l_3,v_2) = l'}
  {H,L,\js{new e1(e2)} \evalsto H',{l'}}
\vg

  \staterule{(Function call)}
  {H,L,\js{e1} \evalsto H_1,r_1\qquad
   \pickThis(H_1,{r_1})=l_2\qquad
   \getValue(H_1,r_1)=l_1\\
   H_1(l_1,@body)=\lambda \js{x.e3}\qquad
   H_1(l_1,@scope)= L'\\
   H_1,L,\js{e2} \evalsto H_2,{v}\\
   H_3 = H_2\sep\act(l,\js x,v,\js{e3},l_2) \\
   H_3,l \cons L',\js{e3} \evalsto H',{v'}}
  {H,L,\js{e1(e2)} \evalsto H',{v'}}
\vg

  \staterule{(This)}
  {\scope(H,L,@this)=l_1 \\ \proto(H,l_1,@this)=l_2\\ H(l_2,@this)=l'}
  {H,L,\js{this} \evalsto H,l'}
\vg

  \staterule{(Restricted evaluation)}
  {H,L,e_1 \evalsto H_1,v \qquad
   \parse(v) = e \\
   H_2 = H_1 \sep l \pointsto \{@this:l, @proto:\nil\} * \defs(x, l, e) \\
   H_2,L,e_2 \evalsto H_3, l' \\
   H_3, l \cons [l'], e \evalsto H',v }
  {H,L,\js{reval($e_1$, $e_2$)} \evalsto H',v}
\vg\gds{\\I think you want to evaluate $e$ in the scope chain $l'\cons[l]$}\vg

  \staterule{(Object freeze)}
  {H,L,e \evalsto H'', l\\
   H' = H''[(l, @frozen) \pointsto \true]}
  {H,L,\js{freeze($e$)} \evalsto H', l}
\vg

  \staterule{(Recursive freeze)}
  {H,L,\js{freeze($e$)} \evalsto H_0, l \\
  \forall l' \in \dom(H'', l) \st (H,L,\js{def($l'$)} \evalsto H_n, l'')}
  {H,L,\js{def($e$)} \evalsto H', l}
  TODO: reformulate this to cope with cyclic heaps (and ordering of heap ops)!
\end{display}

\subsection{Notes}
The semantics presented here are based on the ES3 program logic paper. I've
decided to use the scope chain as the scoping and heap accessibility model as I
think it quite neatly captures the functions-as-closures semantics of the
language.

Prototype chain traversal has become more irrelevant with the removal of the
\js{with} statement, the only place a normal object (with a prototype chain) is
placed into the scope chain is at the root, either as the global object $l_g$,
or as the `fake global' imports object during restricted execution. At all other
times, objects placed into the scope chain are controlled by the language, and
will \emph{never} have a prototype set.
\gds{\\
  \js{var super=\{x:1\} ; }\\
  \js{var f = function()\{\} ; }\\
  \js{f.prototype = super ; }\\
  \js{var ob = new f() ; } \\
  \js{ob.x ; // The prototype chain is traversed here}}

Dereferencing syntax has been modified to change the gamma arrows into a
dereferencing rule, this is used implicitly in all cases except for assignment,
where a reference is required to the object that holds the field. (It's a bit
annoying, apart from that, it could be dropped entirely, but that's the way it
is, even in the C++ languages also studied this year...)
Progress was
made between ES3 and ES5 to remove the need to represent references internally
(they were originally specified only as the result of an implementation
decision). According to Mark Miller, of the TC39 ES standardisation body,
references should no longer be needed in the ES5 spec and later revisions. As a
result of this information, they have been removed from this operational
semantics for simplification purposes.

The \js{def} function is definable in the full SES language using the
\js{for..each} construct. As this poses formalisation issues (non-determinism),
it has been decided to not model \js{for..each}, but \js{def} directly in the
operational semantics.

SES permits more granular properties than we model here. We only model
per-object freezing, SES permits this on a per-field basis. We also do not make
the distinction between data and accessor properties, (SES permits values of
accessor properties to be modified through the accessor after the object is
frozen). This choice may need to be reviewed at a later point.

\section{Program Logic}

\newcommand{\defline}[2]{#1 & \qquad & \text{#2}\\}
\begin{display}{Definitions}
  $\begin{array}{lll}
    \defline{h,h_g \in}{Abstract heap}
    \defline{h,h_g,L,\env \satisfies P}{Satisfaction relation}
    \defline{h[h']}{Heap $h$ updated to be consistent with heap $h'$}
    \defline{h[h'](x) \triangleq h'(x)}{iff $x \in \dom(h')$}
    \defline{h[h'](x) \triangleq h(x)}{otherwise}
    \defline{\tr{P}{\js{x}}{Q}}{Hoare triple}
  \end{array}$
\end{display}

\newcommand{\asrtline}[3][\pipe]{#1 & #2 & \text{#3}\\}
\begin{display}{Assertions}
  $\begin{array}{rll}
    \asrtline[P ::=]{P \land P \pipe P \lor P \pipe \lnot P \pipe \true \pipe
    \false}{Boolean formulae}
    \asrtline{P \sep P \pipe P \wand P \pipe P \sepish P}{Structural formulae}
    \asrtline{\upd P \pipe P \hysep Q}{Global hypothesis formulae}
    \asrtline{(E,E) \pointsto E \pipe \lemp}{SES formulae}
    \asrtline{E \bp E}{Backpointer formula}
    \asrtline{E = E}{Expression equality}
  \end{array}$
\end{display}

\begin{display}{Assertion satisfaction relation}
  $\begin{array}{lcl}
    h,h_g,L,\env \satisfies \true \\
    h,h_g,L,\env \not\satisfies \false \\
    h,h_g,L,\env \satisfies P \land Q & \iff & (h,h_g,L,\env \satisfies
      P) \land (h,h_g,L,\env \satisfies Q) \\
    h,h_g,L,\env \satisfies P \lor Q & \iff & (h,h_g,L,\env \satisfies
      P) \lor (h,h_g,L,\env \satisfies Q) \\
    h,h_g,L,\env \satisfies \lnot P & \iff & \lnot(h,h_g,L,\env
      \satisfies P)\\
    h,h_g,L,\env \satisfies P \sep Q & \iff & \exists h_1,h_2 \st h \equiv h_1
      \sep h_2 \land (h_1,h_g,L,\env \satisfies P) \land (h_2,h_g,L,\env
      \satisfies Q) \\
    h,h_g,L,\env \satisfies P \sepish Q & \iff & \exists h_1,h_2,h_3 \st
      h \equiv h_1 \disju h_2 \disju h_3 \land {} \\
      && (h_1 \disju h_3, h_g, L, \env \satisfies P) \land
      (h_2 \disju h_3, h_g, L, \env \satisfies Q) \\
    h,h_g,L,\env \satisfies P \wand Q & \iff & \forall h' \st
      (h',h_g,L,\env \satisfies P) \land h \disj h' \land h' \subseteq h_g  \\
      & & \impl (h \disju h', h_g, L, \env \satisfies Q) \\
    %h,h_g,L,\env \satisfies \upd P & \iff & h, h_g[h], L, \env \satisfies P \\
    %h,h_g,L,\env \satisfies P?Q & \iff & h, h_g[h], L, \env \satisfies P \\
    %P \hysep Q & \triangleq & P \wand P ? Q \\
    h,h_g,L,\env \satisfies P \hysep Q & \iff &
      \forall h' \st (h',h_g[h'],L,\env \satisfies P) \land h \disj h' \\
      & & \impl (h \disju h', h_g[h'], L, \env \satisfies Q) \\
      & & \text{\emph{(Where $h_g[h']$ is function-update notation, to ensure
          consistency)}} \\
    h,h_g,L,\env \satisfies (E_1,E_2) \pointsto E_3 & \iff &
      h \equiv (\evalle{E_1}, \evalle{E_2}) \pointsto \evalle{E_3} \\
    % TODO: Give \bp a footprint to prevent contradictory assertions/implication
    h,h_g,L,\env \satisfies E_1 \bp E_2 & \iff & \forall (l,x) \in \dom(h_g) \st
      h_g(l,x) = \evalle{E_1} \\
      & & \impl (l,x) \in \evalle{E_2} \\
    h,h_g,L,\env \satisfies \lemp & \iff & h = \emp
  \end{array}$
\end{display}

The definition of $\wand$ is awkward, by introducing the global view of the
heap, we cannot keep both the right-adjoint property of $\sep$
($P \sep Q \vdash R \iff P \vdash Q \wand R$)
and maintain use of $\wand$ as the weakest precondition for a command.

The definition of $\wand$ here is that which maintins the right-adjoint property. The
ability to express weakest preconditions is enabled through the introduction
% of $\upd P$ to maintain consistency between local and global views of the heap.
of $\hysep$, a modified version of $\wand$ that also updates the state of the
global heap used for evaluation of sub-expressions.

% By using it in conjunction with the $\wand$ operator,
It can be used to apply
a \emph{hypothesis} about a future state of the heap to the global view of the
heap. This maintains the ability to express conditions like ``if I make
the heap look like P, then Q will hold''.
% This combined operator is written as $\hysep$ and pronounced \emph{blargh}.

\subsection{Hoare Triples}
Definition:
\[ \tr{P}{\js{e}}{Q} \]
Soundness:
\[ (h, h \disju h_f, L, \env \satisfies P) \land h, L, \js{e} \leadsto h', v
  \impl (h', h' \disju h_f, L, \env \satisfies Q) \]
Fault avoidance:
\[ h, h_g, L, \env \satisfies P \land h\subseteq h_g \impl h, L, \js{e} \not\leadsto \fault \]
Safety monoticity:
\[ (h, h_g, L, \env \satisfies P) \land h \disj h' \land h, L, \js{e} \not\leadsto
  \fault \land h\subseteq h_g \impl h \disju h', L, \js{e} \not\leadsto \fault \]
Frame property:
\[ (h, h_g, L, \env \satisfies P) \land h, L, \js{e} \not\leadsto \fault \land
  h \disju h', L, \js{e} \leadsto h_2' \land h\subseteq h_g\impl h, L, \js{e} \leadsto h_2 \land
  h_2' = h_2 \disju h' \]

An alternative formulation which emphasises the relationship between the global
view of the heap and the framing property ($h_g = h \disju h_f$) can also be
produced, it should be noted that the meaning is subtly different (in that $h'
\neq h_g$ in all cases).

\begin{display}{Inference Rules}
  \stateaxiom{(Declaration)}
    {\tr {\lemp} {\js{var x}} {\rv \doteq \und}}
  \vg

  \stateaxiom{(Value)}
    {\tr {\lemp} {\js{v}} {\rv \doteq \js{v}}}
  \vg

  \staterule{(Variable)}
    {P = \scope(Ls_1, \ls, \js{x}, L) \sepish \getValue(Ls_2, \fld{L}{\js{x}}, V)}
    {\tr P {\js{x}} {P \sep \rv \doteq \fld{L}{\js{x}}}}
  \vg

  \staterule{(Member Access)}
    {\tr P {\js{e}} {Q \sep \rv \doteq V} \quad Q = R \sep \getValue(Ls, V, L)
      \sep L \not\doteq \nil \sep L\dotin\loc}
    {\tr P {\js{e.x}} {Q \sep \rv \doteq \fld{L}{\js{x}}}}
  \vg

  \staterule{(Computed Access)}
    {
      \tr {P} {\js{e1}} {R \sep \rv \doteq V_1} \quad R = S_1 \sep
      \getValue(Ls_1, V_1, L) \sep L \not\doteq \nil \sep L\dotin\loc\\
      \tr {R} {\js{e2}} {Q \sep X \dotin \sortstyle{X}^U \sep \rv \doteq V_2}
      \quad Q = S_2 \sep \getValue(Ls_2, V_2, X)
    }
    {\tr {P} {\js{e1[e2]}} {Q \sep \rv \doteq \fld{L}{X}}}
  \vg

  \staterule{(Bin Op)}
    {
      \tr P {\js{e1}} {R \sep \rv \doteq V_1} \quad R = S_1 \sep \getValue(Ls,
      V_1, V_3) \\
      \tr R {\js{e2}} {Q \sep \rv \doteq V_2} \quad Q = S_2 \sep \getValue(Ls,
      V_2, V_4) \\
      V = V_3 \mathbin{\bar\oplus} V_4
    }
    {\tr P {\js{e1} \oplus \js{e2}} {Q \sep \rv \doteq V}}
  \vg

  \staterule{(Assign Val)}
    {
      \tr P {\js{e1}} {R \sep \rv \doteq \fld{L}{X}} \\
      \tr R {\js{e2}} {Q \sep (L,X) \pointsto V_3 \sep \rv \doteq V_1} \\
      Q = S \sep \getValue(Ls, V_1, V_2) \sep \ReadWrite(L) \sep V_2 \notdotin
      \loc
    }
    {\tr P {\js{e1 = e2}} {Q \sep (L,X) \pointsto V_2 \sep \rv \doteq V_2}}
  \vg

  \staterule{(Assign Loc)}
    {
      \tr P {\js{e1}} {R \sep \rv \doteq \fld{L}{X}} \\
      \tr R {\js{e2}} {Q \sep (L,X) \mapsto \none \sep \rv \doteq V_2} \\
      Q = S \sep \getValue(Ls, V_1, V_2) \sep \ReadWrite(L) \sep V_2 \dotin
      \loc \sep V_2 \bp s \cup \{(L,X)\}
    }
    {\tr P {\js{e1 = e2}} {Q \sep (L, X) \pointsto V_2 \sep \rv \doteq V_2}}
  \vg

  \staterule{(This)}
  { P = \scope(Ls, \ls, @this, L_1) \sepish \proto(Ls_2, L_1, @this, L_2)
    \sepish (L_2,@this) \pointsto V }
  {\tr P {\js{this}} {P \sep \rv \doteq V}}
  \vg

  \staterule{(Fun)}
  {
    Q = \exists L_1,L_2 \st \newobj(L_1,@proto) \sep (L_1,@proto) \pointsto \lop
    \sep \newobj(L_2,@proto, \js{prototype}, @scope, @body) \sep {}\\
    L_2 \bp \{\} \sep \fun(L_2, \ls, x, e, L_1) \sep \rv \doteq L_2 \sep
    P \sep L_1 \bp \{(L_2, \js{prototype})\} \\

    P = \lop \bp s_1 \cup \{(L_1,@proto)\} \sep \lfp \bp s_2 \cup
    \{(L_2,@proto)\} \sep \forall l' \in elem(\ls) \st l' \bp \{(L_2,@scope)\}
    \cup \exists s'
  }
  {\tr P {\js{function(x) \{e\}}} Q}
  \vg

  \staterule{(Named Fun)}
    {
      Q = \exists L_1, L_2, L_3 \st \newobj(L_1, @proto) \sep (L_1, @proto)
      \pointsto \lop \sep \newobj(L_3,@proto,y) \sep (L_3, @proto) \pointsto
      \nil \sep {} \\
      (L_3,\js{y}) \pointsto L_2 \sep L_2 \bp \{(L_3,\js{y})\} \sep
      L_3 \bp \{(L_2,@scope)\} \sep
      \newobj(L_2,@proto,\js{prototype},@scope,@body) \sep {} \\
      \fun(L_2,(L_3:\ls), \js{x}, \js{e}, L_1) \sep \rv \doteq L_2 \sep P \\
      P = \lop \bp \{(L_1, @proto)\} \cup s_1 \sep \lfp \bp \{(L_2, @proto)\}
      \cup s_2 \sep \forall l' \in elem(\ls) \st \exists s' \st l' \bp
      \{(L_2,@scope)\} \cup s'
    }
    {\tr P {\js{function y(x) \{e\}}} Q}
  \vg

  \staterule{(Obj)}
    {
      \exists L \st \left(\begin{array}{l}
        % FIXME: \bpGen repeated sepping will fail when footprint added to
        %        backpointer, consider case when {x:O,y:O}
        \forall i \in 1..n \st \left(\begin{array}{l}
          P_i = R_i \sep \getValue(Ls_i, Y_i, X_i) \sep
            \bpGen(X_i, L, \js{xi}, s_i) \\
          \tr {P_{i-1}} {\js{ei}} {P_i \sep \rv \doteq Y_i} \\
        \end{array}\right) \\
        Q = P_n \sep \newobj(L, @proto, \js{x1} \ldots \js{xn}) \sep
        (L, \js{xi}) \pointsto X_i \sep \dots \sep (L, \js{xn}) \pointsto
        X_n \sep {} \\
        (L,@proto) \pointsto \lop \sep \rv \doteq L \sep L \bp \{\} \\
        P_0 = R \sep \lop \bp \{(L,@proto)\} \cup s_0
      \end{array}\right) \\
      \js{x1} \neq \dots \neq \js{xn} \qquad \rv \not\in \fv(P_n)
    }
    {\tr {P_0} {\js{\{x1:e1, ..., xn:en\}}} Q}
  \vg

  $\bpGen(V,\_,\_,\_) \triangleq V \notdotin \loc$ \\
  $\bpGen(V,L,x,s) \triangleq V \dotin \loc \sep V \bp \{(L,x)\} \cup s$
  \vg

  \staterule{(Fun Call)}
    {
      \tr P {\js{e1}} {R_1 \sep \rv \doteq F_1} \\
      R_1 = \left(\begin{array}{l}
          S_1 \sepish \pickThis(F_1, T) \sepish \getValue(Ls_1, F_1, F_2) \sep {} \\
          (F_2, @body) \pointsto \lambda X.\js{e3} \sep (F_2, @scope) \pointsto
          Ls_2
      \end{array}\right) \\
      \tr {R_1} {\js{e2}} {R_2 \sep \ls \doteq Ls_3 \sep \rv \doteq V_1} \\
      R_2 = S_2 \sep \getValue(Ls_4, V_1, V_2) \\
      R_3 = \left(\begin{array}{l}
          R_2 \sep \exists L \st \ls \doteq L:Ls_2 \sep (L, X) \pointsto V_2
          \sep (L, @this) \pointsto T \sep (L, @proto) \pointsto \nil \sep
          \defs(X,L,\js{e3}) \sep {} \\
          \newobj(L,@proto,@this,\js{x},\vardecls(X, L, \js{e3}) \sep
          L \bp \{\} \sep T \bp \{(L,@this)\} \cup s \sep
          \bpGen(V_2, L, X, s')
      \end{array}\right) \\
      \tr {R_3} {\js{e3}} {\exists L \st Q \sep \ls \doteq L:Ls_2} \qquad
      \ls \notin \fv(Q) \cup \fv(R_2)
    }
    {\tr P {\js{e1(e2)}} {\exists L \st Q \sep \ls \doteq Ls_3}}

\end{display}

\subsection{Notes}
The existing backpointers paper\cite{KassiosKritikos12} is the first case in
which we've seen the concept of a backpointer being used with separation logic
to count references. However, these backpointers are implemented as \emph{ghost
fields} as members of the data structures under examination in the Chalice
language.

Each object that is being tracked for pointers $o$, has a field, named $T.f^{-1}$
which contains the set of objects of type $T$, whose $f$ field
points to $o$.

These ghost fields are updated by the program logic using the inference rules
for assignment.

These sorts of backpointers are not suitable for our use for a number of
reasons: explicit references to field name and object type on
which references may be stored limit the flexibility of pointer tracking,
although it is suitable for this case of reference counting, it is not suitable
for more a general security analysis. Secondly, the set of pointers recorded is
exactly those in existence, it may be useful for the logic to be more flexible
about this definition, say for those objects in the set to be \emph{at least}
those that point to the tracked object.

Using the at least semantics allows for the rule of consequence to be used to
add new items to the set at any time. \emph{Note: should probably consider the
impact of this on reachability, as well as non-reachability analysis.}

\bibliography{bibliography}
\bibliographystyle{babplain}

\end{document}
