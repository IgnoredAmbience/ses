\documentclass[a4paper,notitlepage]{report}
\usepackage[usenames,dvipsnames,svgnames,x11names]{xcolor}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{wasysym}
\usepackage{xspace}
\usepackage{fullpage}
\usepackage{hyperref}
\usepackage{etoolbox}
\usepackage{separationlogic}
\usepackage[numbers]{natbib}
\usepackage[nottoc]{tocbibind} % add bibliography to toc
\usepackage{parskip}

\usepackage[sc]{mathpazo}
\linespread{1.05}         % Palatino needs more leading (space between lines)
\usepackage[T1]{fontenc}

\begin{document}
\begin{titlepage}
\begin{center}
  \textsc{\Large Imperial College London} \\[0.1cm]
  \textsc{\Large Department of Computing}

  \vfill

  % Still rough title
  {\Huge A Program Logic for Verification of Security Properties in Secure
  ECMAScript} \\[1cm]

  {\LARGE Thomas Wood} \\[1cm]

  {\large Supervisors:\\
  Dr. Gareth Smith \\
  Prof. Philippa Gardner}
  \\[2cm]

  \begin{abstract}
    \begin{center}
      We present an Operational Semantics of the Secure ECMAScript (SES) language.
      We extend Separation Logic with a backpointer operator to permit reasoning
      about reachability in the object graph whilst maintaining local reasoning.
      We define inference rules in the extended logic for SES. Finally, we prove
      the correctness of the Membrane design pattern.
    \end{center}
  \end{abstract}

  \vfill

  {\Large June 2013} \\[0.5cm]

  Submitted in partial fulfilment of the requirements for the\\
  MEng Degree in Computing of Imperial College London
\end{center}
\end{titlepage}

%\chapter*{Acknowledgements}
%  Thanks to...
%
%  Gareth, Philippa.
%
%  Mark Miller.
%
%  Housemates.
%
%  Lecturers this year.

\tableofcontents

\chapter{Background}
\section{Introduction}

% * Clear statement of what the project is about, nature and scope to be
%   understood by a lay reader
% * Summarise goals
% * Summarise background
% * Summarise relevance, main contributions
%   * Highlight sections of report for contributions
% * Explain motivation, identify issues to be addressed in remainder of report

  Historically, the JavaScript language was developed with very little intent
  for it to be used for much more than form validation on web pages.
  However, in recent years, web technologies have become a central part of
  day-to-day computer use, an ever growing number of applications now target the
  web as their platform of choice.
  This increase in popularity has forced the JavaScript language to mature
  considerably, through syntax, semantics, and standard library support.

  It is extremely common
  that multiple different programs from different sources may be loaded and
  executed in a single environment. This combination of different code poses
  some interesting problems regarding code-correctness and security. JavaScript
  provides no easy means to isolate different modules of code from one another,
  all data stored is potentially accessible to any code loaded on the page,
  which must therefore be implicitly trusted.

  Some attempts have been made to solve this problem by statically rewriting
  source code, or more recently by making clever use of
  a mixture of JavaScript's deprecated and modern language features.
  Examples of such attempts include AdSafe~\cite{AdSafe}, FBJS, and
  Google Caja~\cite{miller2008caja}.
  All of these have suffered from some security
  flaws in their histories as a
  result of insufficient understanding of the JavaScript language or knowledge
  of one of the myriad of differences that \emph{legitimately} exist between
  common JavaScript implementations~
  \cite{maffeis2009jsisolation, maffeis2010object-cap, ses-semantics}.
  It is therefore beneficial to introduce more security features to the core
  language specification.

  Secure ECMAScript (SES) is a proposed revision of the ECMAScript (ES)
  specification that introduces changes to the language to permit programs to be
  executed within a restricted context, safe from the possibility of unintended
  leak.
  Restricted execution permits fine-grained control over the permissions that
  untrusted executing code has by restricting the set of accessible references
  to other objects.
  This is a particularly powerful method as it is possible for unrestricted code
  to interact with code under restricted execution, it is in this situation that
  it is envisaged that lapses in the encapsulation could inadvertently occur due
  to programmer error.

  \FIXME{EDIT INTO SHAPE}
  It is useful to be able to verify that a program is correct according to a
  given specification.

  Hence need a logic to express the program states and the specification.

  Up to now, we've got the logic to express program states and can prove
  functional properties of programs.

  However, we're unable to express the security properties in the existing
  separation logic system - we need to be able to reason about the entire heap,
  separation logic forces that we only reason about a small part of the heap
  that a given instruction touches. We could expand the footprint of
  instructions, but this would cause separation logic to quickly lose its
  advantages over normal boolean logics.

  It is useful to be able to reason about security properties at the same time
  as functional properties as the function of a program directly impacts which
  security properties hold.


  Project aims:

  Semantics of SES - to understand the language, differences from JavaScript, in
  style of previous ES3 semantics for direct comparison.

  Add bp to Separation Logic.

  Produce axiomatic rules for SES instructions including bp assertions. Again,
  direct comparison to ES3 logic and Operational Semantics.

  Prove some fundamental programming patterns used in objcap world (Caretaker,
  Membrane)

  Opted not to discuss decidability of logic, nor to prove soundness against
  operational semantics, nor completeness... Basically nothing very formal
  \FIXME{}

% TODO: Consider following for inclusion in introduction

% The language's structure already poses some interesting problems for
% researchers producing formal models of programming languages due to its memory
% structure.  A formal logic for ECMAScript 3 has been recently developed by
% researchers at Imperial College. This project aims to extend this program
% logic to effectively model the restricted execution support proposed by the
% Secure ECMAScript language specification. This will permit proofs asserting
% that the language constructs are secure, and that programs written using the
% restricted execution construct do not accidentally leak private data or
% permissions to untrusted code, especially during interactions between two
% contexts.

% The formal logic for ECMAScript 3 is based upon Separation Logic, an extension
% of Hoare Logic which permits efficient reasoning about data contained within
% heaps by splitting the heap into smaller discrete portions. However, to reason
% about restricted execution, we need to reason about the \emph{entire}
% heap. The first aim of the project is to extend Separation logic with a
% backpointer operator to allow reasoning about which objects point to an
% object of interest.

\section{Hoare Logic}
  This style of reasoning about the functionality and correctness of computer
  programs was first presented in his 1969 paper ``An Axiomatic Basis for
  Computer Programming''\cite{Hoare1969Axiom}, the principles presented were
  based on earlier work by Floyd\cite{floyd1967assigning} for flowchart
  representations of programs, and by others in other branches of mathematics;
  Hoare developed the style of the reasoning to fit textual representation of
  programs.

  Hoare's reasoning depends on the basis that commands used in programming
  languages should be well-defined and thus the consequences of a computer
  program should be determinable directly from the program's text by deductive
  means. Program proofs are deduced through the application of inference rules
  to sets of axioms.

  The main contribution of the paper was to introduce the notation, now known as
  a Hoare triple:
    \[ \{P\} C \{Q\} \]
  $P$ and $Q$ are logical assertions and $C$ is some command or program. The
  triple is interpreted by Hoare as ``if the assertion $P$ is true before
  initiation of a program $C$, then the assertion $Q$ will be true on its
  completion.'' Other interpretations of triples are possible, as will be shown
  later.

  The axioms selected for use in the reasoning alter the semantics of the system
  being reasoned about. Hoare exemplifies this by presenting axioms that apply
  to arithmetic under all sets of integers, followed by three alternative axioms
  that describe different semantics for overflow in sets of finite integers.

  A number of axioms and inference rules are universal or common to nearly all
  imperative languages, Hoare presents four of these:
  \begin{display}{}
    \stateaxiom{(Assign)}
    {\tr{P[f/x]}{x := f}{P}} \qquad

    \staterule{(Consequence)}
    {\tr{P'}{C}{Q'} \quad P \impl P' \quad Q' \impl Q}
    {\tr{P}{C}{Q}} \\
    \\
    \staterule{(Iteration)}
    {P \quad \tr{B}{S}{P}}
    {\tr{P}{\textbf{while } B \textbf{ do } S}{\lnot B \land P}} \qquad

    \staterule{(Composition)}
    {\tr{P}{C_1}{Q} \quad \tr{Q}{C_2}{R}}
    {\tr{P}{C_1; C_2}{R}}
  \end{display}

  The consequence and composition rules are straight-forward. The iteration rule
  is also reasonably simple once it is noted that the $P$ term is the loop
  invariant. The assignment axiom is the most subtle of the set when not taken
  in the context of a proof. The axiom asserts that the post-condition will hold
  if the \emph{precondition} has the variable replaced by
  the assigned value. This axiom makes more sense if it is considered to be used
  whilst reasoning backwards. For example, to prove $\tr{\ltrue}{r := x; q :=
  0}{x = r + y \times q}$:

  \begin{tabular}{ll}
    $\{\ltrue \impl x = x + y \times 0 \}$ & Axiom \\
    $\tr{x = x + y \times 0}{r:=x}{x = r + y \times 0}$ & Assignment \\
    $\tr{x = r + y \times 0}{q:=0}{x = r + y \times q}$ & Assignment \\
    $\tr{\ltrue}{r:=x}{x = r + y \times 0}$ & Consequence \\
    $\tr{\ltrue}{r:=x; q:=0}{x = r + y \times q}$ & Composition\\
  \end{tabular}

  It is noted that proofs in this format are long and tedious, but it is
  possible to derive more useful rules from the given ones which would somewhat
  reduce the length of these proofs. This is now the generally accepted method
  of presenting proofs in Hoare's system, so the above proof could also be
  presented as follows:

  \begin{tabular}{l}
    $\{\ltrue\}$ \\
    $\{x = x + y \times 0\}$ \\
    $\ r:=x$ \\
    $\{x = r + y \times 0\}$ \\
    $\ q:=0$ \\
    $\{x = r + y \times q\}$
  \end{tabular}

  Indeed, in his 1971 paper~\cite{Hoare1971proof}, Hoare presents a proof in
  such a style for the non-trivial \textsc{Find} algorithm.

  %Hoare closes his paper by reinforcing the need for formal proof and
  %specification of computer programs and languages.

\section{Separation Logic}

  Whilst Hoare's methodology is suitable for reasoning about programs which only
  operate within the stack, it is not suitable for reasoning about programs that
  use the heap. This is because that data structures within the heap are more
  prone to being shared in some manner (for example, multiple pointers to the
  same heap location, or even arbitrary pointer arithmetic).

  Reasoning about these shared data structures using conventional logics has been attempted by a number of
  researchers, but no solution was particularly adequate. The main issue with
  verification of shared data structures was that a global view of the data, and
  attempts to axiomatize use of the heap would result in assertions
  that rapidly grew in complexity, both in terms of length, but also from
  universal quantification, for the need to assert that the rest of the heap was
  not modified along with the location of interest.

  Burstall considered a local approach to this reasoning in 1972
  \cite{burstall1972some}, but the approach featured little further research and
  was unable to reason about data structures such as doubly-linked lists
  \cite{reynolds2000intuitionistic}. Reynolds began further research into the
  use of a spatial logic to permit local reasoning about the heap and in
  collaboration with O'Hearn, Ishtiaq and Yang produced Separation Logic, a
  combination of the spatial Bunched Implication logic with Hoare's methods for
  reasoning about programs
  \cite{Ishtiaq2001BI,OHearn2001Local,reynolds2000intuitionistic,Reynolds2002Separation}.

  \subsection{Semantics of Separating Operators}

  Separation Logic introduces the separating conjunction operator, $P \sep Q$,
  which can be thought of as splitting the heap into two disjoint portions, in
  which $P$ holds in one and $Q$ the other. To denote the contents of the
  heap, the $\mapsto$ operator is also introduced to relate heap locations with
  values, $(x \mapsto 4, y)$ denotes that the pair of the value $4$ and a pointer
  to the heap location $y$ is stored in the heap location $x$.

  The separating conjunction only enforces disjointedness of the storage
  locations of values, it is permitted to point to other heap locations from
  within the heap. For example $(x \mapsto 4, y) \sep (y \mapsto 3, x)$ is
  permissible and required to be able to build complex data structures.

  % diagram of (x -> 4, y) * (y -> 3, x) ?

  $x \mapsto -$ is shorthand meaning that there is some value stored at heap
  location $x$.

  The disjointedness enforced by the $\sep$ operator provides a very powerful
  means of reasoning about operations made to the heap. Take for example the
  assertion $x \mapsto 1 \sep P$ and the command $x := 2$, since we have $x$
  explicitly defined on the left of the $\sep$, we know that it cannot occur
  within $P$. We can therefore safely conclude that $P$ is not modified and that
  the postcondition must be $x \mapsto 2 \sep P$.

  A counterpart for implication also exists,
  the separating implication operator, $\wand$ (commonly known as the
  \emph{magic wand}). The assertion $((x
  \mapsto 7) \wand P)$ has the meaning that if $x$ is updated to contain the
  value $7$, then $P$ will be true. So: $(x \mapsto 7) \sep ((x \mapsto 7) \wand
  P) \impl P$.

  This operator can thus, in effect, be
  used to generate the weakest precondition for a command given a desired
  postcondition. This is often used for backwards reasoning, where a
  postcondition for a command is known, but the precondition is not.

  \subsection{Program Reasoning}

  Just as Hoare's logic was built atop of classical logic, we can extend
  Hoare's logic to the spatial logic including the separating conjunction,
  the combined system is known as Separation Logic.

  The first concept to translate is that of the Hoare triple, $\tr{P}{C}{Q}$.
  For the remainder of this report, we will consider Separation Logic to use
  \emph{fault-avoiding} semantics for the triple. Under these semantics, then the
  requirements for $C$ are strengthened, such that ``if $C$ is executed in a
  state satisfying $P$, then it will \emph{not fault}, and if it terminates it
  will do so in a state satisfying $Q$''.

  Separation Logic extends the standard Hoare inference rules and axioms, the
  rules for Consequence, Composition, and Simple Assignment are used without
  modification.

  The obvious new axioms to introduce are those for heap access and
  modification, the following set are taken from \cite{OHearn2001Local}.

  \begin{display}{Axioms for heap access}
    $\begin{array}{ll}
      \stateaxiom{(Update)}{\tr{x \mapsto -} {x := v} {x \mapsto v}} &
      \stateaxiom{(Delete)}{\tr{x \mapsto -} {\js{delete}(x)} {\emp}} \\
      \stateaxiom{(Allocate)}{\tr{x \doteq v'} {x := v} {x \mapsto v[v'/x]}} &
      \stateaxiom{(Lookup)}{\tr{x \mapsto v} {y := [x]} {y = v \land x \mapsto v}} \\
    \end{array}$
  \end{display}
\gds{I'm used to seeing Allocate given as $\tr{\emp} {x := new()} {\exists L \st x=L \land L \mapsto\_}$. The $\exists$ is important, because otherwise we can use the frame rule to ``prove'' that we know already something about the allocated address.}
  These axioms may be expressed in other ways, for example, in a form suitable
  for backwards reasoning, or with use of existential quantifiers.

  There is one important new inference rule, the frame rule: \\

  $
    \staterule{(Frame Rule)}
    {\tr{P}{C}{Q}}
    {\tr{P \sep R}{C}{Q \sep R}}
    {\mathrm{modifies}(C) \disj \mathrm{free}(R)}
  $\\

  This rule is the prime reason why Separation Logic is suitable for local
  reasoning. It allows assertions to be split down to the \emph{footprint} of
  the command, just those heap locations that the command touches. The side condition
  guarantees that the command only touches the part of the assertion which is
  kept, it guarantees that nothing in $R$ can be modified by $C$.

  As a result of this, we are safe to temporarily disregard other portions of
  the heap. This permits rules to be easily composed without requiring an
  overwhelming number of predicates specifying that other portions of the heap
  haven't changed.

\section{JavaScript}

  JavaScript is a dynamically-typed, prototype-oriented language. The
  early development of the language was haphazard with rival implementations
  produced by Netscape and Microsoft for their browsers. The language's
  specification was later standardised as ECMA-262 and named ECMAScript (ES).
  The specification is unusual as it permits any
  implementation-specific extensions to the language. Even today, many
  JavaScript implementations do not conform to the ES specifications (as
  determined by the incomplete ES test suite), although this situation is slowly
  improving.

  Although originally targeted to be a programming language that was easy to
  learn and suitable for non-programmers to use, the language's variable scoping
  rules, semantics of the \js{this} keyword and \js{with} syntax are unusual
  and differ from most peoples' intuitions. In addition, the ability to
  redefine, or \emph{monkey-patch} many primitives that define the semantics of
  the language means that reasoning about programs can become impossible if
  some unknown code can execute within the same execution environment as the
  program under study.

  \subsection{Formalisation}
  There have been several efforts to formally specify various aspects of the
  JavaScript language, notable mentions include Maffeis, Mitchell and Taly's
  production of an operational semantics for a wide range of ES3
  implementations \cite{maffeis-jsopsem}, this work was continued by
  Gardner, Maffeis, Smith's \cite{gms-popl} by producing a
  Program Logic for JavaScript which is capable of expressing JavaScript
  program states with high precision. Since SES is based upon JavaScript,
  sharing many of the simple statements, this program logic was used as a
  starting point for the formalisation of SES.

  As with most formal models, they approximate and simplify actual behaviour
  where it does not impact the aspects of the language under study. JavaScript
  is a particularly large and awkward language, notable differences between the
  model and the full language are that the syntax is flattened to be purely
  expression-based and that the mechanism for automatic casting of types is
  avoided by requiring the primitive type is specified where needed in command
  pre-conditions.

  Once again, Hoare-style reasoning is adapted to suit the extensions of the
  logic. The fault-avoiding semantics for the Hoare triple are maintained. The
  basic set of Separation Logic axioms and inference rules (excluding those
  referring directly to the C-style heap implementation) are used. One notable
  difference is that the Frame rule loses its side condition as a result of all
  variables now being on the heap -- the footprint of $C$ will be expressed in
  the $P$ and $Q$ terms, so is necessarily disjoint from the framed $R$ portion of
  the rule.

  \subsection{Data Structure}
  \label{sec:intro:js:datastructure}

  A unique feature of the
  language is that the entire state is stored on the heap in a structure that
  loosely resembles the variable store in conventional programming languages. It
  thus follows that Separation Logic is likely to be a useful basis for the
  JavaScript program logic. However, a considerable number of complex predicates
  were required to accurately model the variable store and scoping rules.

  \TODO{diagram}

  A JavaScript object is identified by a location $l \in \loc$, each object may
  have fields $x \in \vars$ which map to values $v \in \vals$. The heap is
  represented by the partial function of locations and fields to
  values, $H \in \loc \times \vars \partialfunc \vals$.

  Field names are subdivided into user fields $\uvars$ and internal fields
  $\ivars$ (prefixed by an @ symbol). No internal fields are permitted to be
  directly accessed by executing code, they are used by the language to store
  contextual information on objects for purposes such as prototypical name
  resolution and function closures.

  Field lookup on an object proceeds by checking whether the field is present on
  the object, if not the \emph{prototypical} object stored on the $@proto$ field
  is recursively checked for the field. The list of
  objects checked for field lookup is known as the \emph{prototype chain}
  of an object. The object lookup operation is performed by the $\proto$
  predicate in the Operational Semantics and Program Logic, the corresponding
  value retrieval operation is performed by $\getValue$.

  During execution a \emph{scope chain}, an ordered list of object locations, is
  maintained. This structure is somewhat alike to stack frames in other languages.
  To perform a variable lookup, a prototypical field lookup is performed for
  each object in the scope chain in turn until a field is matched. This
  operation is performed by the $\scope$ predicate in the formalisations.

  To perform a write to a variable, a similar lookup is performed, except the
  field is modified on the \emph{scope object} for the prototype chain in which the
  variable was found -- this is so that the prototypical variable is overridden,
  but not overwritten.

  \TODO{both the above examples need diagrams}

\chapter{SES Language Syntax \& Operational Semantics}
  We now define the syntax and semantics of expressions in this model of the SES
  language. We present the English definition of each expression along with the
  Operational Semantics for the precise effect it has on the heap and program
  state. We also discuss how SES differs from JavaScript and the rationale for
  these differences.

  \section{Syntax}
  \label{sec:syntax}
  \newcommand{\syntaxline}[3][\pipe]{#1 & \js{#2} & \textit{#3}\\}
    \begin{display}{Syntax of SES values and expressions, \js{v}, \js{e}}
      $\begin{array}{rll}
        \syntaxline[\js{v} ::=]{n}{Number}
        \syntaxline{s}{String}
        \syntaxline{\und}{Undefined}
        \syntaxline{\nil}{Null}
        \syntaxline{\true \pipe \false}{Booleans}
        \syntaxline[\js{e} ::=]{v}{Value}
        \syntaxline{\jsvar{x}}{Variable declaration}
        \syntaxline{x}{Identifier}
        \syntaxline{\{x_1:e_1, \ldots, x_n:e_n\}}{Object creation}
        \syntaxline{e; e}{Sequence}
        \syntaxline{e \oplus e}{Binary operator}
        \syntaxline{if(e) \{e\} else \{e\}}{Conditional}
        \syntaxline{while(e) \{e\}}{Looping}
        \syntaxline{e = e}{Assignment}
        \syntaxline{e.x}{Member access}
        \syntaxline{e[e]}{Computed member access}
        \syntaxline{e(e)}{Function call}
        \syntaxline{this}{this}
        \syntaxline{\jsfun{e}{e}}{Function creation}
        \syntaxline{\jsfun[x]{e}{e}}{Named function creation}
        \syntaxline{\jsnew{e}{e}}{Object construction}
        \syntaxline{reval(e, e)}{Restricted evaluation -- similar to \js{eval} in JavaScript}
        \syntaxline{freeze(e)}{Freeze -- make one object immutable}
        \syntaxline{def(e)}{Recursive freeze -- make many objects immutable}
      \end{array}$
    \end{display}

  Numbers, strings, booleans and the special values of \und and \nil are the
  only primitive values.

  \FIXME{This paragraph should \emph{partially} go somewhere else}
  Although locations are values that are stored in the heap, they
  may not be directly referred to by user programs. This means that
  references to objects are not forgable. This is a key security concept in the
  SES language: an object must be passed a reference to another object to be
  able to access it.
  Since all functions (including standard libraries and resources) are
  themselves objects, the concept of access extends to one of privilege when a
  security-sensitive interface needs to be protected.

  We model SES as an expression-based language, the full language follows
  JavaScript's Strict Mode parsing and variable declaration rules. For this
  project, we assume that all programs proved additionally pass these checks.

  SES syntax differs from JS syntax only by removal and addition of several
  commands. The most notable removal is that of the \tjs{with} expression, this
  expression would add the given JS object into the scope chain for the duration
  of execution of the given block. This causes the scope chain to potentially
  have multiple prototype chains requiring traversal. Removal of this command
  ensures that all objects in the scope chain, other than the root, have no
  prototype chains. This removal considerably simplifies the reasoning required
  for variable lookup. The deprecation of the \tjs{with} syntax has also been
  started in the most recent ES specifications.

  We are modelling three additional primitives present in the SES language,
  these are restricted evaluation, \tjs{reval(e,e)}, and methods to make objects
  immutable, \tjs{freeze(e)} and \tjs{def(e)}.

  \section{Operational Semantics}
  \label{sec:opsems}

  We now describe the semantics of each expression given in the syntax, both
  informally in English, and formally with the big-step operational semantics
  rule, which precisely describes how the program state is modified by execution
  of each expression.

  Although daunting at first, the rules are quite simple to follow. The syntax
  $H,L,\js{e} \evalsto H',r$ means that the heap $H$, scope chain $L$, and
  expression $\js{e}$ will evaluate to the heap $H'$ and return value $r$. (A
  return value is a value, or a reference, $\fld{l}{\js{x}}$, to a location and
  a field).

  An expression will be evaluated iff the preconditions above the line hold,
  these may be evaluations of subexpressions, or involve the use of predicates
  that test or update the current state.
  Ordering of the evaluation of these preconditions is enforced through the
  labelling of the variables in each rule.

  The semantics make use of several auxiliary functions defined in
  Appendix~\ref{app:opsems} and described above in
  Section~\ref{sec:intro:js:datastructure}. Recall that $\getValue$ is used to
  dereferencing a JavaScript or SES reference value.
  As the dereferencing of references returned by subexpressions into values is a
  common activity, $\gevalsto$ is defined as shorthand for this:
  \[ H,L,\js{e} \gevalsto H',v \triangleq \exists r. (H,L,\js{e} \evalsto H',r
  \wedge \getValue(H',r) = v) \]

  \subsection{Structural Expressions}
  All of these semantics are common across most imperative languages.

  \stateaxiom{(Value)}{H,L,\js{v} \evalsto H,v}

  A value simply evaluates to itself, the heap is not modified. No preconditions
  are required.

  \stateaxiom{(Variable declaration)}{H,L,\jsvar{x} \evalsto H,\und}

  The variable declaration expression is only checked on entry to a function
  body, they are treated as a no-op during execution.

  \staterule{(Sequence)}
    {H,L,\js{e_1} \evalsto H'',r' \\
     H'',L,\js{e_2} \evalsto H',r}
   {H,L,\js{e_1; e_2} \evalsto H',r}
  \nopagebreak

  The sequencing operator specifies that the expression on the left should be
  evaluated, followed by the expression on the right. The result of the right
  subexpression is returned.

  \staterule{(Binary operator)}
    {H,L,\js{e_1} \gevalsto H'',v_1 \\
     H'',L,\js{e_2} \gevalsto H',v_2\\
     v_1 \oplus v_2 = v}
   {H,L,\js{e_1 \oplus e_2} \evalsto H',v}

  Binary operations are evaluated left-to-right, and include standard
  mathematical and string operations. Formalisation of semantics for all of these
  are beyond the scope of this project, but will correspond closely to similar
  works on the JavaScript family of languages.

  \staterule{(Conditional true)}
  {H,L,\js{e_1} \gevalsto H'',v \quad \istrue(v) \\
   H'',L,\js{e_2} \evalsto H',r}
  {H,L,\js{if(e_1)\{e_2\} else \{e_3\}} \evalsto H',r}
\qquad
  \staterule{(Conditional false)}
  {H,L,\js{e_1} \gevalsto H'',v \quad \isfalse(v) \\
   H'',L,\js{e_3} \evalsto H',r}
  {H,L,\js{if(e_1)\{e_2\} else \{e_3\}} \evalsto H',r}

  The conditional expression evaluates the first sub-expression, if it evaluates
  to \js{true} when cast to a boolean then the second
  sub-expression is evaluated and result returned, otherwise the third
  sub-expression is evaluated and result returned. This is the standard
  definition.


  \staterule{(While true)}
  {H,L,\js{e_1} \gevalsto H'', v \quad \istrue(v) \\
   H'',L,e_2\js{;while(e_1)\{e_2\}} \evalsto H', v''}
  {H,L,\js{while(e_1)\{e_2\}} \evalsto H',\und}
\qquad
  \staterule{(While false)}
  {H,L,\js{e_1} \gevalsto H', v \quad \isfalse(v)}
  {H,L,\js{while(e_1)\{e_2\}} \evalsto H',\und}

  Whilst the loop guard is true, the loop is syntactically unrolled once, and
  the resulting expression evaluated. When the guard condition evaluates to
  false, \und is returned. This is the standard loop unrolling definition.

  \subsection{Heap-based Expressions}
  \staterule{(Variable Resolution)}
    {\scope(H,L,x) = l' \quad l' \neq \nil}
    {H,L,\js x \evalsto H, \fld{l'}{x}}

  The $\scope$ predicate is used to search the scope chain for an object which
  contains the field matching the variable name. A reference to the \emph{scope}
  object and the field is returned.

  If the scope object cannot be found, fail to evaluate -- this
  behaviour differs from JS, which would return the reference
  $\fld{\nil}{\js{x}}$.  JS assigned write attempts to the \nil object to the
  \emph{global} object -- this posed an obvious isolation problem.
  This new behaviour enforces that all variables must be declared before use.

  \staterule{(Member access)}
  {H,L,\js e \gevalsto H',l' \\
   l' \neq \nil}
  {H,L,\js{e.x} \evalsto H', \fld{l'}{x}}
\qquad
  \staterule{(Computed member access)}
  {H,L,\js{e_1} \gevalsto H'',l' \\
   l' \neq \nil \\
   H'',L,\js{e_2} \evalsto H', x}
  {H,L,\js{e_1[e_2]} \evalsto H',\fld{l'}{x}}

  Returns a reference to the named field of the object referenced by the first
  subexpression. For the computed member access, the second subexpression is
  evaluated to a field name. In full JS and SES, these rules are additionally
  complicated with details about type casting. For simplicity, here we focus on
  the case where no type casting is necessary.

  \staterule{(Assignment)}
  {H,L,\js{e_1} \evalsto H_1,\fld{l}{x} \qquad
   \ReadWrite(H_1, l) \\
   H_1,L,\js{e_2} \gevalsto H_2, v \\
   H' = H_2[(l,x) \pointsto v]}
  {H,L,\js{e_1 = e_2} \evalsto H', v}

  Assigns the value on the right hand side to the subexpression evaluating to a
  reference on the left. The object being assigned to must be writable (see
  later).

  Assignments to undeclared variables are forbidden (enforced by the Variable
  rule).

  \staterule{(Object creation)}
    {H_0 = H \disju \obj(l,\lop)\\
     \forall i\in 1..n \st \left(\begin{array}{l}
      H_{i-1},L,\js{e_i}\gevalsto H_i',v_i \\
      H_i = H_i' [ (l,\js{x_i}) \pointsto v_i]\end{array}\right)}
    {H,L,\js{\{x_1:e_1,\dots,x_n:e_n\}} \evalsto H_n,l}
  \nopagebreak

  The Object Construction syntax produces a new object at the new location $l$,
  with fields named \js{x_1, \ldots, x_n} which map to the values of expressions
  \js{e_1, \ldots, e_n} when evaluated in order at creation. The location of the
  new object is returned.

  \subsection{Function-related Expressions}

  \staterule{(Function creation)}
  {H' = H \disju \obj(l,\lop) \disju \fun(l',L,\js{x},\js{e},l)}
  {H,L,\jsfun{x}{e} \evalsto H',l'}

  Creates a function object, assigning the body, parameter
  declarations and the current scope to internal fields. The shape of this
  function object is given by the $\fun$ auxiliary function, defined in
  Appendix~\ref{app:opsems}. A new object is also
  created and assigned to the \js{prototype} field for use as the prototype of
  objects produced by using this function as a constructor.

  \staterule{(Named function creation)}
  {H' = H \disju \obj(l,\lop) \disju \fun(l',l_1 \cons L,\js{x},\js{e},l) \disju
    l_1 \pointsto \{@proto:\nil, y:l'\}}
  {H,L,\jsfun[y]{x}{e} \evalsto H',l'}

  This is the same as standard function creation,
  but also adds the name and a self-reference to the function to the function's
  scope record. This permits recursive functions to be created. \emph{Note:} the
  name of the function is not added to the current scope, it is permitted in the
  actual language, but is considered to be syntactic sugar, combining creation and
  assignment.

  \staterule{(Function call)}
  {H,L,\js{e_1} \evalsto H_1,r_1\qquad
   \pickThis(H_1,r_1)=l_2\qquad
   \getValue(H_1,r_1)=l_1\\
   H_1(l_1,@body)=\lambda \js{x.e_3}\qquad
   H_1(l_1,@scope)= L'\\
   H_1,L,\js{e_2} \gevalsto H_2,v\\
   H_3 = H_2\disju\act(l,\js x,v,\js{e_3},l_2) \\
   H_3,l \cons L',\js{e_3} \gevalsto H',v'}
  {H,L,\js{e_1(e_2)} \evalsto H',v'}

Executes the body of the function, using the passed expression
as the value to bind to the parameter. The body of the function is executed in
the scope stored with the function, any variables defined within the function
body are defined on an activation record so that they are lexically scoped.

  \staterule{(Object construction)}
  {H,L,\js{e_1} \gevalsto H_1,l_1 \qquad
   l_1\neq \nil\qquad
   H_1(l_1,@body)=\lambda \js{x.e_3}\\
   H_1(l_1,@scope)= L'\qquad
   H_1(l_1,\js{prototype})= v\\
   H_1,L,\js{e_2} \gevalsto H_2,v_1  \qquad
   l_2 = \objOrGlob(v) \\
   H_3 = H_2\disju \obj(l_3,l_2) \disju\act(l,\js x,v_1,\js{e_3},l_3)\\
   H_3,l \cons L',\js{e_3} \gevalsto H',v_2\qquad
   \getBase(l_3,v_2) = l'}
  {H,L,\jsnew{e_1}{e_2} \evalsto H',l'}

Constructs an object using the given function, an object
is created as usual, it's prototype is assigned to that of the function's
\js{prototype} field. The body of the function is then executed, commonly used
to initialize the newly created object.

% ES5-Strict definition, plus reval global - matches caja impl (and intuition).
  \staterule{(This)}
  {\scope(H,L,@this)=l \\
   (l,@this) \pointsto l'}
  {H,L,\js{this} \evalsto H,l'}

The \js{this} expression is context-dependent. When used
outside of a
function, it should evaluate to the most global accessible scope.
When used within a function, if the function is called using Member Access (such
as \js{ob.f()}), it
will evaluate to the object on which that function was called (in this case: \js{ob}). Otherwise
(most likely a direct function call such as \js{f()}),
\js{this} returns undefined. Note that this is particularly
problematic because functions can easily be aliased off of the object on which
they appear to be defined. For this reason the code \js{g = ob.f ; ob.f()}
may behave significantly differently from the code \js{g = ob.f ; g()}

  \subsection{SES-specific Expressions}

  \staterule{(Restricted evaluation)}
  {H,L,\js{e_1} \gevalsto H_1,v \qquad
   \js{e_3} = \parse(v) \\
   H_1,L,\js{e_2} \gevalsto H_2, l \\
   H_3 = H_2 \disju l' \pointsto \{@this:l, @proto:\nil\} \disju
     \defs(\_, l', \js{e_3}) \\
   H_3, l' \cons [l], \js{e_3} \gevalsto H',v }
  {H,L,\js{reval(e_1, e_2)} \evalsto H',v}

Parse the first given expression as SES code.
A new scope chain is prepared. Its root is the
object specified by the second parameter, the \emph{imports} to the restricted
environment.
An activation record which initializes any variables declared in the parsed
source is then appended. This may cause imported objects to be shadowed.
The return value of the restricted evaluation statement is the same as that of
the final statement of the source to be executed.

  \staterule{(Freeze)}
  {H,L,\js{e} \gevalsto H'', l\\
   H' = H''[(l, @frozen) \pointsto \true]}
  {H,L,\js{freeze(e)} \evalsto H', l}

Makes the provided object read-only. This prevents field additions,
modifications and deletions.
Note that the ES5 spec has a bug, meaning that frozen fields on an object's
prototype are not permitted to be overridden, some browsers opt to ``fix'' the spec bug.
This bug does not occur in these semantics.

  \staterule{(Recursive freeze)}
  {H,L,\js{e} \gevalsto H'', l \\
   H' = H''[\auxDef(H'', l, \{\})]}
  {H,L,\js{def(e)} \evalsto H', l}

Recursively calls freeze on all objects reachable
via user-defined fields from the given object.

\chapter{Program Logics}
\label{chap:proglogic}
Although the operational semantics provide a precise description of how a
program will execute, their use for practical program verification is
long-winded, tedious and error-prone. Instead, we use a program logic, which
allows us to reason at the level of abstraction best suited to the particular
program we would like to verify. Since so much of the behaviour of JS and SES is
dependant on the state of the program heap, it is natural to start with
separation logic.

We first extend separation logic to be able to express not only what can be
accessed \emph{from} a given object, but also what paths exist to obtain access
\emph{to} a given object. We then produce a Hoare-style inference rule for each
expression in the syntax of the language.

\section{Extending Separation Logic}
\label{sec:extendingseplog}
To reason about the security properties of SES programs, we need to be able to
assert that only trusted objects contain references to sensitive data.
Separation logic is unable to make statements like this, since the
statement is inherently \emph{non-local}. If we attempt to make such a
statement, then at any time, we might use the frame rule to introduce an object
which contradicts the statement we made.

We extend the logic to support these sorts of statements by: reintroducing a global heap state to the
assertion satisfaction relation; redefining the existing logical operators to
carry around the global heap state without examining it; and introducing new
logical operators that allow us to make limited non-local assertions without
breaking the frame rule.

\subsection{Existing Separation Logic Operators}
The pure assertions, $\ltrue,\lfalse,\land,\lor,\lnot$ extend trivially with the
addition of the new heap state, for example,the new definition of $\land$ is:
\[
  h,h_g,L,\env \satisfies P \land Q \iff
    (h,h_g,L,\env \satisfies P) \land (h,h_g,L,\env \satisfies Q)
\]

The definitions of the separating conjunction $\sep$ and partially separating
conjunction $\sepish$ also simply extend by passing through the global heap state:
\[\begin{array}{c}
  h,h_g,L,\env \satisfies P \sep Q \iff
    \exists h_1,h_2 \st h \equiv h_1 \disju h_2 \land
    (h_1,h_g,L,\env \satisfies P) \land (h_2,h_g,L,\env \satisfies Q) \\
  h,h_g,L,\env \satisfies P \sepish Q \iff
    \exists h_1,h_2,h_3 \st h \equiv h_1 \disju h_2 \disju h_3 \land
    (h_1 \disju h_3, h_g, L, \env \satisfies P) \land
    (h_2 \disju h_3, h_g, L, \env \satisfies Q)
\end{array}\]

\subsection{Magic Wand}
\label{sec:wand}
The separating implication, or magic wand, operator, $\wand$, is usually defined
as follows:
\[
  h \satisfies P \wand Q \iff \forall h' \st (h' \satisfies P) \land h \disj
    h' \impl (h \disju h' \satisfies Q)
\]

It means that if the heap is extended by a disjoint portion that satisfies $P$,
then the resulting heap will satisfy $Q$.

* Also the right adjoint of $\sep$:
\newcommand{\entails}{\vdash}
\[
P \sep Q \entails R \text{ iff } P \entails Q \wand R
\]
% I think these two things may be equivalent - but I think staying at the logic
% level has two advantages:
%   1) I think it's easier to understand
%   2) It still makes sense when you have both local /and/ global heaps in the model.
% \[
%   h \disju h' \satisfies P \sep Q \impl R \text{ iff } h \satisfies P \impl Q
%   \wand R
% \]
* Used for extending footprint of heap
    ...for example, in the weakest precondition of object creation.

* Used for speculating/hypothesising different values in the existing heap
    ...for example, in the weakest precondition of over-writing assignment.

    ...or in the proof of the store predicate over-writing assignment case.

* Weakest preconditions of commands

* We claim that both uses are incompatible under a global view of the heap

    .... no - the incompatibility is between the adjoint property and the
    hypothesising use of the wand. If we define the adjoint wand in our context,
    we get the footprint-extending wand, but not the hypothesising one.

Since separation logic usually defines  $\wand$
as follows:
\[
  h \satisfies P \wand Q \iff \forall h' \st (h' \satisfies P) \land h \disj
    h' \impl (h \disju h' \satisfies Q)
\]

We might \emph{naively} define $\wand$ in our context like so:
\[
  h,h_g \satisfies P \wand Q \iff \forall h' \st (h',h_g \satisfies P) \land h \disj
    h' \impl (h \disju h',h_g \satisfies Q)
\]

Now consider $x \pointsto 1 \sep (x \pointsto 2 \wand Q)$

 In regular separation logic, this assertion is satisfiable. Consider the heap
 $x:1$ as follows:
\begin{align*}
           & x:1 \satisfies x \pointsto 1 \sep (x \pointsto 2 \wand Q) \\
\text{iff } & x:1 \satisfies x \pointsto 1 \land \lemp \satisfies (x \pointsto 2 \wand Q) \\
\text{iff } & x:1 \satisfies x \pointsto 1 \land x:2 \satisfies x \pointsto 2 \land (x:2 \disju \lemp) \satisfies Q
\end{align*}

But with our naive definition of $\wand$, this assertion is
\emph{unsatisfiable}. Consider again the heap $x:1$, which satisfied the regular
separation logic version of this assertion:
\begin{align*}
           & x:1,x:1 \satisfies x \pointsto 1 \sep (x \pointsto 2 \wand Q) \\
\text{iff } & x:1,x:1 \satisfies x \pointsto 1 \land \lemp,x:1 \satisfies (x \pointsto 2 \wand Q) \\
\text{iff } & x:1,x:1 \satisfies x \pointsto 1 \land x:2,x:1 \satisfies x \pointsto 2 \land (x:2 \disju \lemp,x:1) \satisfies Q
\end{align*}
Note that the local and global heap states do not agree in the derivation of the
sub-assertions. But the local portion of the heap should always be a subset of the
global portion! Since we cannot find local and global heaps for these
sub-derivations which agree, the heap $x:1$ does not satisfy our original assertion.

This behaviour prevents us from using $\wand$ for hypothetical heap update
operations. To support this use-case, we introduce a new logical operator.

The new operator to be defined is the \emph{box-wand}, $\boxwand$ or
``hypothesising separating implication''. In addition
to the behaviour of the standard wand, the box-wand maintains consistency
between the local and global heap states whilst evaluating the satisfaction of
sub-assertions of the operator. This permits a state to be hypothesised that
conflicts with the current global state of the heap.
\[
  h,h_g \satisfies P \boxwand Q \iff \forall h' \st (h',h_g[h'] \satisfies P)
  \land h \disj h' \impl (h \disju h', h_g[h'] \satisfies Q)
\]

The derivation our example now behaves as expected, and the assertion is
satisfied.
\begin{align*}
           & x:1,x:1 \satisfies x \pointsto 1 \sep (x \pointsto 2 \boxwand Q) \\
\text{iff } & x:1,x:1 \satisfies x \pointsto 1 \land \lemp,x:1 \satisfies (x \pointsto 2 \boxwand Q) \\
\text{iff } & x:1,x:1 \satisfies x \pointsto 1 \land x:2,x:2 \satisfies x \pointsto 2 \land (x:2 \disju \lemp,x:2) \satisfies Q
\end{align*}

\TODO{Need to find a complementary example to show why right-adjoint no longer
holds}

\subsection{Backpointer}
We also define new operators to work with the newly introduced global heap
state, the first of these is the \emph{backpointer}, $E_1 \bp E_2$, which
specifies that any heap cell that has the $E_1$ as its value must appear in the
set $E_2$. The set $E_2$ may additionally contain extra heap cell references to
express permission that a given cell may point to $E_1$.

\section{Hoare Triples}

\chapter{Program Proofs}
\section{Caretaker}
\section{Membrane}

\chapter{Evaluation}
\chapter{Conclusions \& Future Work}
\section{Conclusions}
\section{Future Work}

\bibliography{bibliography}
\bibliographystyle{plainnat}

\appendix
\chapter{Operational Semantics}
\label{app:opsems}
\newcommand{\auxf}[2]{#1 & \triangleq & #2}
\begin{display}{Auxillary Functions}
  $\begin{array}{lcl}
  \auxf{\obj(l,l')}{l \pointsto \{@proto: l', @frozen: \false\}}\\
  \auxf{\istrue(v)}{v\not\in\{0,\emptystr,\nil,\und,\false\}}\\
  \auxf{\isfalse(v)}{v\in   \{0,\emptystr,\nil,\und,\false\}}\\
  \auxf{\fun(l',L,\js x,\js e,l)}{l'\mapsto\{@proto: \lfp, \js{prototype}:
        l, @scope: L, @body: \lambda \js{x.e}, @frozen: \false\}}\\
  \auxf{\pickThis(H, \fld{l}{x})}{l \phantom{\und} \quad
        \text{if } (l,@this) \in \dom(H)}\\
  \auxf{\pickThis(H, r)}{\und \phantom{l} \quad \text{otherwise}}\\
  \auxf{\objOrGlob(l)}{l\phantom{_{op}} \quad l\in \loc}\\
  \auxf{\objOrGlob(v)}{\lop \quad v\not\in\loc}\\
  \auxf{\getBase(l,l')}{l' \qquad l \in \loc}\\
  \auxf{\getBase(l,v)}{v \qquad v\not\in\loc}\\

  \auxf{\act(l,\js{x},v,\js{e},l'')}{l\pointsto\{\js{x}:
    v,@this: l'',@proto: \nil\}\disju \defs(\js{x},l,\js{e})}\\

  \auxf{\auxDef(H,l,s)}{\begin{cases}
      \emp & l \in s \lor l \not\in \loc\\
      (l,@frozen) \mapsto \true \cup \bigcup_{(l,x_n) \in H, x_n \in \uvars}
      \auxDef(H,H(l,x_n),s \cup\{l\}) & \mbox{otherwise} \\
    \end{cases}}\\
  \auxf{\ReadWrite(H, l)}{H(l, @frozen) = \false} \\
  \end{array}$
\end{display}
  \begin{display}{Local Variable Declarations}
    \jaxiom{\defs(\js{x},l,\jsvar{y})}{(l,y) \pointsto \und \quad$ \= if
      $\js{x} \neq \js{y}} \\
    \jaxiom{\defs(\js{x},l,\js{e_1 = e_2})}{\defs(\js{x},l,\js{e_1})} \\
    \jaxiom{\defs(\js{x},l,\js{e_1;e_2})}{\defs(\js{x},l,\js{e_1}) \cup
      \defs(\js{x},l,\js{e_2})} \\
    \jaxiom{\defs(\js{x},l,\js{if(e_1)\{e_2\}\{e_3\}})}
      {\defs(\js{x},l,\js{e_2}) \cup \defs(\js{x},l,\js{e_3})} \\
    \jaxiom{\defs(\js{x},l,\js{while(e_1)\{e_2\}})}{\defs(\js{x},l,\js{e_2})} \\
    \jaxiom{\defs(\js{x},l,\js{e})}{\emp$ \> otherwise$}
  \end{display}

  \begin{display}{Heap Update $H[H']$}
    \jaxiom{H[\emp]}{H} \\
    \jaxiom{H[(l,x) \pointsto v]}{H \disju (l,x) \pointsto v \qquad \mbox{if }
      (l,x) \not\in \dom(H)} \\
    \jaxiom{H[(l,x) \pointsto v \disju H']}{H[(l,x) \pointsto v][H']}
  \end{display}

  \begin{display}{Scope resolution: $\scope(H,l,x)$.}
    \jaxiom{\scope(H,{\emptylist},\njs{x})}{\nil}{}\vg
    \jrule{\scope(H,l\cons L,\njs{x})}{l}{\proto(H,l,\njs{x}) \neq \nil}\rsep
    \jrule{\scope(H,l\cons L,\njs{x})}{\scope(H,L,\njs{x})}{\proto(H,l,\njs{x}) = \nil}
  \end{display}
  %
  \begin{display}{Prototype resolution: $\proto(H,l,x)$.}
    \jaxiom{\proto(H,\nil,\njs{x})}{\nil}{}\vg
    \jrule{\proto(H,l,\njs{x})}{l}{(l,\njs{x}) \in\dom(H)}\rsep
    \jrule{\proto(H,l,\njs{x})}{\proto(H,l',\njs{x})}{(l,\njs{x}) \not\in\dom(H) \qquad H(l,@proto) = l'}
  \end{display}
  %
  \begin{display}{Dereferencing values: $\getValue(H,r)$.}
    \jrule{\getValue(H,\njs{r})}{\njs{r}}{\njs{r}\neq \fld{l}{\js{x}}}~
    \jrule{\getValue(H,\fld{l}{\js{x}})}{\und}{\proto(H,l,\js{x}) = \nil\\ l\neq \nil}~
    \jrule{\getValue(H,\fld{l}{\js{x}})}{H(l',\js{x})}{\proto(H,l,\js{x}) = l'\\ l\neq \nil}
  \end{display}

\chapter{Program Logic}
\newcommand{\defline}[2]{#1 & \qquad & \text{#2}\\}
\begin{display}{Definitions}
  $\begin{array}{lll}
    \defline{h,h_g \in}{Abstract heap}
    \defline{h,h_g,L,\env \satisfies P}{Satisfaction relation}
    \defline{\tr{P}{\js{x}}{Q}}{Hoare triple}
  \end{array}$
\end{display}

\newcommand{\asrtline}[3][\pipe]{#1 & #2 & \text{#3}\\}
\begin{display}{Assertions}
  $\begin{array}{rll}
    \asrtline[P ::=]{P \land P \pipe P \lor P \pipe \lnot P \pipe \ltrue \pipe
    \lfalse}{Boolean formulas}
    \asrtline{P \sep P \pipe P \wand P \pipe P \sepish P}{Structural formulas}
    \asrtline{\bigsep_{x \in \T{set}} P(x)}{Iterative $\sep$}
    \asrtline{P \boxwand Q}{Global `hypothesis' formula}
    \asrtline{(E,E) \pointsto E \pipe \lemp}{Heap formulas}
    \asrtline{E \bp E}{Backpointer formula}
    \asrtline{E = E}{Expression equality}
    \asrtline{\forall X \st P \pipe \exists X \st P}{First-order formulas}
  \end{array}$
\end{display}

\newcommand{\assaxiom}[1]{\>$h,h_g,L,\env \satisfies #1$}
\newcommand{\asssat}[3]{\assaxiom{#1}\>$\iff$\>$#2$
  \ifblank{#3}{}{\\\>\>\>\quad$#3$}}
\begin{display}{Assertion satisfaction relation}
\hspace{1.5em} \= $h,h_g,L,\env \satisfies (E_1,E_2) \pointsto E_3$ \= $\iff$ \= \kill

\assaxiom{\ltrue} \\
%    h,h_g,L,\env \not\satisfies \false \\
\asssat{P \land Q}{(h,h_g,L,\env \satisfies P) \land (h,h_g,L,\env \satisfies
Q)}{} \\
\asssat{P \lor Q}{(h,h_g,L,\env \satisfies P) \lor (h,h_g,L,\env \satisfies
Q)}{} \\
\asssat{\lnot P}{\lnot(h,h_g,L,\env \satisfies P)}{} \\
\asssat{P \sep Q}{\exists h_1,h_2 \st h \equiv h_1 \disju h_2 \land{}}
  {(h_1,h_g,L,\env \satisfies P) \land (h_2,h_g,L,\env \satisfies Q)} \\
\asssat{P \sepish Q}{\exists h_1,h_2,h_3 \st
    h \equiv h_1 \disju h_2 \disju h_3 \land{}}
  {(h_1 \disju h_3, h_g, L, \env \satisfies P) \land
    (h_2 \disju h_3, h_g, L, \env \satisfies Q)} \\
\asssat{P \wand Q}{\forall h' \st (h',h_g,L,\env \satisfies P) \land h \disj h'
    \land h' \subseteq h_g}
  {\impl (h \disju h', h_g, L, \env \satisfies Q)} \\
%h,h_g,L,\env \satisfies \upd P}{h, h_g[h], L, \env \satisfies P }\\
%h,h_g,L,\env \satisfies P?Q}{h, h_g[h], L, \env \satisfies P }\\
%P \boxwand Q & \triangleq & P \wand P ? Q }\\
\asssat{P \boxwand Q}{\forall h' \st (h',h_g[h'],L,\env \satisfies P)
    \land h \disj h'}
  {\impl (h \disju h', h_g[h'], L, \env \satisfies Q)} %\\
\TODO{Infinite list handling}
\asssat{\bigsep_{x\in\{\}}P(x)}{h,h_g,L,{\env}\satisfies\lemp}{} \\
\asssat{\bigsep_{x\in\T{set}}P(x)}{y\in\T{set} \land h,h_g,L,{\env} \satisfies
  P(y)\sep(\bigsep_{x\in(\T{set}\setminus y)}P(x))}{} \\
\asssat{\lemp}{h = \emp}{} \\
\asssat{(E_1,E_2) \pointsto E_3}{h \equiv (\evalle{E_1}, \evalle{E_2}) \pointsto
  \evalle{E_3}}{} \\
\asssat{E_1 \bp E_2}{h \equiv (\evalle{E_1}, @bp) \pointsto v \land
  \forall (l,x) \in \dom(h_g) \st h_g(l,x) = \evalle{E_1}}
  {\impl (l,x) \in \evalle{E_2}} \\
\asssat{E_1 = E_2}{\evalle{E_1} = \evalle{E_2}}{} \\
\asssat{\exists\V X \st P}{\exists \V{v} \st h,h_g,L,[{\env} | \V X\takes \V{v}]
  \satisfies P}{} \\
\asssat{\forall\V X \st P}{\forall \V{v} \st h,h_g,L,[{\env} | \V X\takes \V{v}]
  \satisfies P}{}
\end{display}
\section{Hoare Triples}
Definition:
\[ \tr{P}{\js{e}}{Q} \]
Soundness:
\[ (h, h \disju h_f, L, \env \satisfies P) \land h, L, \js{e} \leadsto h', v
  \impl (h', h' \disju h_f, L, \env \satisfies Q) \]
Fault avoidance:
\[ h, h_g, L, \env \satisfies P \land h\subseteq h_g \impl h, L, \js{e} \not\leadsto \fault \]
Safety monoticity:
\[ (h, h_g, L, \env \satisfies P) \land h \disj h' \land h, L, \js{e} \not\leadsto
  \fault \land h\subseteq h_g \impl h \disju h', L, \js{e} \not\leadsto \fault \]
Frame property:
\[ (h, h_g, L, \env \satisfies P) \land h, L, \js{e} \not\leadsto \fault \land
  h \disju h', L, \js{e} \leadsto h_2' \land h\subseteq h_g\impl h, L, \js{e} \leadsto h_2 \land
  h_2' = h_2 \disju h' \]

An alternative formulation which emphasises the relationship between the global
view of the heap and the framing property ($h_g = h \disju h_f$) can also be
produced, it should be noted that the meaning is subtly different (in that $h'
\neq h_g$ in all cases).

\TODO{More Auxiliary predicates}
\begin{display}{Auxiliary Predicates}
  \jaxiom{\obj_E(E_1:E'_1,...,E_n:E'_n)}{(E,E_1) \pointsto E'_1 \sep ... \sep
    (E,E_n) \pointsto E'_n} \\
  \jaxiom{\newobj_L(V_1,...,V_n)}{\bigsep_{V \in \vars \setminus
    \{V_1,...,V_n\}} (L,V) \pointsto \none} \\
  \jaxiom{\fullobj_E(E_1:E_1',\dots,E_n:E_n')}
    {\obj_{E}(E_1:E_1',\dots,E_n:E_n') \sep \newobj_{E}(E_1,\dots,E_n)} \\
  \jaxiom{\fun_F(E_1,E_2,E_3,E_4)}{(F, @scope) \pointsto E_1 \sep
    (F, @body) \pointsto \lambda E_2.E_3 \sep (F, \js{prototype}) \pointsto E_4
    \sep (F, @proto) \pointsto \lfp} \\
  \jaxiom{\newfun_{E}(E_1,E_2,E_3,E_4)}{\fun_{E}(E_1,E_2,E_3,E_4) \sep
    \newobj_{E}(@proto, \js{prototype}, @scope, @body)} \\
  \jaxiom{\scopeBpsUpd(Ls, s, s', n)}{\bigsep_{0\leq i<\length(Ls)}(
    \lstitem(i,Ls) \bp \lstitem(i,s') \sep \lstitem(i,s') \doteq \lstitem(i,s)
    \cup n)} \\
  \jaxiom{\scopeBps(Ls, s)}{\scopeBpsUpd(Ls, s, s, \{\})} \\
  \jaxiom{\bpGen(V,\_,\_,\_)}{V \notdotin \loc} \\
  \jaxiom{\bpGen(V,L,x,s)}{V \dotin \loc \sep V \bp \{(L,x)\} \cup s} \\
  \jaxiom{\auxDefGet(V,s)}{\lemp \quad \mbox{if } V \notdotin \loc \lor V \dotin
    s} \\
  \jaxiom{\auxDefGet(V,s)}{(V, @frozen) \pointsto \_ \sep (\bigsepish_{x_n \in
    \uvars} (V,x_n) \pointsto V' \sepish \auxDefGet(V', s\cup\{V\}))} \\
  \jaxiom{\auxDefSet(V,s,b)}{\lemp \quad \mbox{if } V \notdotin \loc \lor V \dotin
    s} \\
  \jaxiom{\auxDefSet(V,s,b)}{(V, @frozen) \pointsto b \sep (\bigsepish_{x_n \in
    \uvars} (V,x_n) \pointsto V' \sepish \auxDefSet(V', s\cup\{V\}, b))} \\
  \jaxiom{\ReadWrite(L)}{(L, @frozen) \pointsto \false} \\
  \jaxiom{\decls(X,L,\js{e})}{\js{x_1},...,\js{x_n} \quad \text{where }
    (L,\js{x_i}) \in \dom(\defs(X,L,\js{e}))} \\
  \jaxiom{\pickThis(\fld{L}{\_},L)}{(L,@this) \pointsto \none} \\
  \jaxiom{\pickThis(\fld{L}{\_},\und)}{\exists V \st (L,@this) \pointsto V \sep V
    \not\doteq \none}
\end{display}

\begin{display}{Local Variable Definitions}
  \jaxiom{\defs(X,L,\jsvar{y})}{(l,y) \pointsto \und \sep X \not\doteq \js{y}} \\
  \jaxiom{\defs(X,L,\js{e_1 = e_2})}{\defs(X,L,\js{e_1})} \\
  \jaxiom{\defs(X,L,\js{e_1;e_2})}{\defs(X,L,\js{e_1}) \sepish
    \defs(X,L,\js{e_2})} \\
  \jaxiom{\defs(X,L,\js{if(e_1)\{e_2\}\{e_3\}})}
    {\defs(X,L,\js{e_2}) \sepish \defs(X,L,\js{e_3})} \\
  \jaxiom{\defs(X,L,\js{while(e_1)\{e_2\}})}{\defs(X,L,\js{e_2})} \\
  \jaxiom{\defs(X,L,\js{e})}{\lemp \quad \text{otherwise}}
\end{display}

\begin{display}{Inference Rules}
  \stateaxiom{(Declaration)}
    {\tr {\lemp} {\jsvar{x}} {\rv \doteq \und}}
  \vg

  \stateaxiom{(Value)}
    {\tr {\lemp} {\js{v}} {\rv \doteq \js{v}}}
  \vg

  \staterule{(Variable)}
    {P = \scope(Ls_1, \ls, \js{x}, L) \sepish \getValue(Ls_2, \fld{L}{\js{x}}, V)}
    {\tr P {\js{x}} {P \sep \rv \doteq \fld{L}{\js{x}}}}
  \vg

  \staterule{(Member Access)}
    {\tr P {\js{e}} {Q \sep \rv \doteq V} \quad Q = R \sep \getValue(Ls, V, L)
      \sep L \not\doteq \nil \sep L\dotin\loc}
    {\tr P {\js{e.x}} {Q \sep \rv \doteq \fld{L}{\js{x}}}}
  \vg

  \staterule{(Computed Access)}
    {
      \tr {P} {\js{e_1}} {R \sep \rv \doteq V_1} \quad R = S_1 \sep
      \getValue(Ls_1, V_1, L) \sep L \not\doteq \nil \sep L\dotin\loc\\
      \tr {R} {\js{e_2}} {Q \sep X \dotin \uvars \sep \rv \doteq V_2}
      \quad Q = S_2 \sep \getValue(Ls_2, V_2, X)
    }
    {\tr {P} {\js{e_1[e_2]}} {Q \sep \rv \doteq \fld{L}{X}}}
  \vg

  \staterule{(Bin Op)}
    {
      \tr P {\js{e_1}} {R \sep \rv \doteq V_1} \quad R = S_1 \sep \getValue(Ls_1,
      V_1, V_3) \\
      \tr R {\js{e_2}} {Q \sep \rv \doteq V_2} \quad Q = S_2 \sep \getValue(Ls_2,
      V_2, V_4) \\
      V = V_3 \mathbin{\bar\oplus} V_4
    }
    {\tr P {\js{e_1} \oplus \js{e_2}} {Q \sep \rv \doteq V}}
  \vg

  \staterule{(Assign)}
    {
      \tr P {\js{e_1}} {R \sep \rv \doteq \fld{L}{X}} \\
      \tr R {\js{e_2}} {Q \sep (L,X) \pointsto V_3 \sep \rv \doteq V_1} \\
      Q = S \sep \getValue(Ls, V_1, V_2) \sep \ReadWrite(L) \sep
      \bpGen(V_2, L, X, s)
    }
    {\tr P {\js{e_1 = e_2}} {Q \sep (L,X) \pointsto V_2 \sep \rv \doteq V_2}}
  \vg

  \staterule{(This)}
  { P = \scope(Ls_1, \ls, @this, L_1) \sepish \proto(Ls_2, L_1, @this, L_2)
    \sepish (L_2,@this) \pointsto V }
  {\tr P {\js{this}} {P \sep \rv \doteq V}}
  \vg

  \staterule{(Function)}
  {
    P = \lop \bp s_1 \sep \lfp \bp s_2 \sep \scopeBps(\ls, ss) \\
      Q = \exists L_1,L_2 \st \left(\begin{array}{l}
        % L_1 - prototype object
        \fullobj_{L_1}(@proto:\lop) \sep L_1 \bp \{(L_2, \js{prototype})\} \sep
          \lop \bp s_1 \cup \{(L_1,@proto)\}  \sep {} \\
        % L_2 - function
        \newfun_{L_2}(\ls, \js{x}, \js{e}, L_1) \sep L_2 \bp \{\} \sep
          \lfp \bp s_2 \cup \{(L_2,@proto)\} \sep {} \\
        % Other bits
        \rv \doteq L_2 \sep
        \scopeBpsUpd(\ls, ss, ss', \{(L_2, @scope)\})
    \end{array}\right)
  }
  {\tr P {\jsfun{x}{e}} Q}
  \vg

  \staterule{(Named Function)}
    {
      P = \lop \bp s_1 \sep \lfp \bp s_2 \sep \scopeBps(\ls, ss)  \\
      Q = \exists L_1, L_2, L_3 \st \left(\begin{array}{l}
        % L_1 - prototype object
        \fullobj_{L_1}(@proto:\lop) \sep L_1 \bp \{(L_2, \js{prototype})\} \sep
          \lop \bp s_1 \cup \{(L_1,@proto)\}  \sep {} \\
        % L_2 - function
        \newfun_{L_2}((L_3:\ls), \js{x}, e, L_1) \sep
          L_2 \bp \{(L_3,\js{y})\} \sep
          \lfp \bp s_2 \cup \{(L_2,@proto)\} \sep {} \\
        % L_3 - new scope object
        \fullobj_{L_3}(@proto:\nil,\js{y}:L_2) \sep L_3 \bp \{(L_2,@scope)\} \sep {} \\
        % Other bits
        \rv \doteq L_2 \sep
        \scopeBpsUpd(\ls, ss, ss', \{(L_2, @scope)\})
      \end{array}\right)
    }
    {\tr P {\jsfun[y]{x}{e}} Q}
  \vg

  \staterule{(Object)}
    {
      \forall i \in 1..n \st \left(\begin{array}{l}
        P_i = R_i \sep \getValue(Ls_i, Y_i, X_i) \sep
          X_i \bp s_i \\
        \tr {P_{i-1}} {\js{e_i}} {P_i \sep \rv \doteq Y_i} \\
      \end{array}\right) \\
      P_n = R \sep \lop \bp s_{op} \\
      Q = R \sep
      \exists L \st \left(\begin{array}{l}
        \newobj_L(@proto, \js{x_1},...,\js{x_n}) \sep {} \\
        \bigsep_{1 \leq i \leq n} (
          (L, \js{x_i}) \pointsto X_i \sep \bpGen(X_i, L,\js{x_i}, s_i)
        ) \sep {} \\
        (L,@proto) \pointsto \lop \sep \lop \bp s_{op} \cup \{(L,@proto)\} \sep {} \\
        \rv \doteq L \sep L \bp \{\} \\
      \end{array}\right) \\
      \js{x_1} \neq \dots \neq \js{x_n} \qquad \rv \not\in \fv(P_n)
    }
    {\tr {P_0} {\js{\{x_1:e_1, ..., x_n:e_n\}}} Q}
  \vg

  \staterule{(Function Call)}
    {
      \tr P {\js{e_1}} {R_1 \sep \rv \doteq F_1} \\
      R_1 = \left(\begin{array}{l}
          S_1 \sepish \pickThis(F_1, T) \sepish \getValue(Ls_1, F_1, F_2) \sep {} \\
          (F_2, @body) \pointsto \lambda X.\js{e_3} \sep (F_2, @scope) \pointsto
          Ls_2
      \end{array}\right) \\
      \tr {R_1} {\js{e_2}} {R_2 \sep T \bp s \sep \bpGen(V_2,\_,\_,s') \sep
        \ls \doteq Ls_3 \sep \rv \doteq V_1} \\
      R_2 = S_2 \sep \getValue(Ls_4, V_1, V_2) \\
      R_3 = R_2 \sep \exists L \st \left(\begin{array}{l}
          \ls \doteq L:Ls_2 \sep (L, X) \pointsto V_2
          \sep (L, @this) \pointsto T \sep (L, @proto) \pointsto \nil \sep
          \defs(X,L,\js{e_3}) \sep {} \\
          \newobj(L,@proto,@this,\js{x},\vardecls(X, L, \js{e_3})) \sep
          L \bp \{\} \sep T \bp \{(L,@this)\} \cup s \sep
          \bpGen(V_2, L, X, s')
      \end{array}\right) \\
      \tr {R_3} {\js{e_3}} {\exists L \st Q \sep \ls \doteq L:Ls_2} \qquad
      \ls \notin \fv(Q) \cup \fv(R_2)
    }
    {\tr P {\js{e_1(e_2)}} {\exists L \st Q \sep \ls \doteq Ls_3}}
  \vg

  \staterule{(New)}
    {}
    {}
%  \vg

  % SES-specific
  \staterule{(Restricted evaluation)}
    {
      \tr{P}{\js{e_1}}{R_1 \sep \rv \doteq V_1} \\
      R_1 = S_1 \sep \getValue(\_, V_1, V_2) \sep V_2 \dotin \text{String} \\ %% FIXME: STRING
      \parse(V_2) = \js{e_3} \\
      \tr{R_1}{\js{e_2}}{R_2 \sep \rv \doteq V_3 \sep \ls \doteq Ls \sep \gv \doteq g} \\
      R_2 = \left(\begin{array}{l}
        S_2 \sep \getValue(\_, V_3, V_4) \sep V_4 \dotin \loc \sep {} \\
        \exists L \st R_3 \sep
        \newobj_L(@proto,@this,\vardecls(...,\js{e_3})) \sep {} \\
        \obj_L(@this: V_2, @proto: \nil) \sep \defs(...,\js{e_3}) \\
      \end{array}\right) \\
      R_3 = (\ls \doteq L:[V_2] \sep \gv \doteq V_2) \\
      \tr{R_2}{\js{e_3}}{\exists L \st Q \sep R_3}
    }
    {\tr{P}{\js{reval(e_1,e_2)}}{\exists L \st Q \sep \ls \doteq Ls \sep \gv \doteq g}}
  \vg

  \staterule{(Freeze)}
    {
      \tr{P}{\js{e}}{Q \sep \rv \doteq V_1 \sep (V_2, @frozen) \pointsto V_3} \\
      Q = \getValue(Ls,V_1,V_2) \sep S
    }
    {\tr{P}{\js{freeze(e)}}{Q \sep (V_2, @frozen) \pointsto \true \sep \rv \doteq V_2}}
  \vg

  \staterule{(Recusive freeze)}
    {
      \tr{P}{\js{e}}{Q \sep \rv \doteq V_2 \sep \auxDefGet(V_2, \{\})} \\
      Q = \getValue(Ls,V_1,V_2) \sep S
    }
    {\tr{P}{\js{def(e)}}{Q \sep \rv \doteq V_2 \sep \auxDefSet(V_2, \{\}, \true)}}
  \vg

  % Control flow
  \staterule{(Sequence)}
    {\tr P {\js{e_1}} R \quad \tr R {\js{e_2}} Q}
    {\tr P {\js{e_1; e_2}} Q}
  \vg

  \staterule{(If True)}
    {\tr P {\js{e_1}}{S\sep \istrue(\E{V_2})\sep\rv\doteq\E{V_1}} \qquad
     S = R \sep \getValue(Ls,\E{V_1},\E{V_2})\\
     \tr {S}{\js{e_2}} Q}
    {\tr P {\js{if(e_1)\{e_2\}else\{e_3\}}} Q}
  \vg

  \staterule{(If False)}
    {\tr P {\js{e_1}}{S\sep \isfalse(\E{V_2})\sep\rv\doteq\E{V_1}} \qquad
     S = R \sep \getValue(Ls,\E{V_1},\E{V_2})\\
     \tr {S}{\js{e_3}} Q}
    {\tr P {\js{if(e_1)\{e_2\}else\{e_3\}}} Q}
  \vg

  \staterule{(While)}
    {\tr P {\js{e_1}} {S\sep\rv\doteq\E{V_1}} \qquad
    S = R \sep \getValue(Ls,\E{V_1},\E{V_2})\\
     \tr {S \sep \istrue(\E{V_2})} {\js{e_2}} P\\
     Q = S \sep \isfalse(\E{V_2})\sep\rv\doteq\und\qquad
     \rv\not\in \fv(R)}
    {\tr P {\js{while(e_1)\{e_2\}}} Q}
  \vg

  % Standard
  \staterule{(Frame)}
    {\tr P {\js{e}} Q}
    {\tr {P \sep R} {\js{e}} {Q \sep R}}

  \staterule{(Consequence)}
    {\tr {P'} {\js{e}} {Q'} \\
     P \impl P' \quad Q' \impl Q}
    {\tr P {\js{e}} Q}
  \vg

  \staterule{(Elimination)}
    {\tr P {\js{e}} Q}
    {\tr {\exists X \st P} {\js{e}} {\exists X \st Q}}

  \staterule{(Disjunction)}
    {\tr{P_1}{\js{e}}{Q_1} \quad \tr{P_2}{\js{e}}{Q_2}}
    {\tr{P_1 \lor P_2}{\js{e}}{Q_1 \lor Q_2}}

\end{display}

\chapter{Proofs}
\subsection{Revocable Reference}
Used to provide a restricted execution context with a reference to an object
that may be revoked by the provider.
\emph{Note: By itself, this is not safe, since accessed references are returned
  raw. See next section, Membrane, for solution.}

\begin{verbatim}
var RevocableRef = function(ref) {
  var protected = ref;
  var access = function(field) { return protected[field]; }
  var kill = function() { protected = null; }
  return {access: access, kill: kill};
}
\end{verbatim}

Proofs are given in Figures~\ref{rr-main}-\ref{rr-access}.

% RevocableRef body call
%
% I've generally unwrapped all \scope, \proto, \getValue operations down to
%   their requirements
% Introduction of new elements into an existing backpointer set seems clumsy
% There must be better ways of generating these proofs other than by hand?
\begin{figure}
\[
  \begin{array}{l}
    \jsvar{RevocableRef = function(ref) \{}\\
    \indblock{
      \logic{
        % function
        \obj_R(@body: \lambda\js{ref}.\{\dots\} , @scope: Ls) \sep {} \\
        % ar
          \exists L \st \ls \doteq L:Ls \sep {} \\
          \fullobj_L\left(
            \begin{array}{l}
              \js{ref}: V,@this: \_,@proto: \nil,@frozen: \false,\\
              \js{protected}: \und,\js{access}: \und,\js{kill}: \und %  and defs()
            \end{array}
          \right) \sep {} \\
        % bp
          L \bp \{\} \sep V \bp s_1 \cup \{(L,\js{ref})\} \sep
          \lop \bp s_3 \sep \lfp \bp s_4 \sep
          \scopeBps(Ls, ss)
      } \\
      \step{Frame/elim/cons ($V \bp s_1 \impl V \bp s_1 \cup s_2$)} \\
      \logic{
        % var(protected,ref), assign(@frozen)
          \obj_L(\js{protected}: \und, \js{ref}: V, @frozen: \false) \sep {} \\
        % assign
          V \bp s_1 \cup \{(L,\js{ref}), (L, \js{protected})\} \sep \ls\doteq{L:Ls}
      } \\
      \jsvar{protected = ref;} \\
      \logic{
        % var *2
          \obj_L(\js{protected}: V, \js{ref}: V, @frozen: \false) \sep {} \\
        % assign
          V \bp s_1 \cup \{(L,\js{ref}), (L, \js{protected})\}\sep \ls\doteq{L:Ls}
      } \\
      \step{Frames/cons} \\
      \logic{
        % var(access), assign(@frozen)
          \obj_L(\js{access}: \und, @frozen: \false) \sep {} \\
        % fun pre
        \lop \bp s_3 \sep \lfp \bp s_4 \sep
        L \bp \{\} \sep \scopeBps(Ls,ss) \sep \ls\doteq{L:Ls}
      } \\
      \jsvar{access = function(field) \{b_a\};} \\
      \logic{
        \exists A, A_p \st \left(\begin{array}{l}
          % var, assign
          \obj_L(\js{access}: A, @frozen: \false) \sep
            A \bp s_7 \sep s_7 \doteq \{(L, \js{access})\} \sep {} \\
          % fun pre
          \lop \bp s_5 \sep s_5 \doteq s_3 \cup \{(A_p, @proto)\} \sep \lfp \bp s_6 \sep s_6 \doteq s_4
            \cup \{(A, @proto)\} \sep {} \\
            L \bp \{(A,@scope)\} \sep \scopeBpsUpd(Ls, ss, ss_1, \{(A,@scope)\}) \sep {} \\
          % fun post
          \fullobj_{A_p}(@proto: \lop) \sep A_p \bp \{(A, \js{prototype})\} \sep {}\\
          \newfun_A(\ls, \js{field}, b_a, A_p)
        \end{array}\right) \sep \ls\doteq{L:Ls}
      } \\
      \step{Frames/cons} \\
      \logic{
        % var(access), assign(@frozen)
          \obj_L(\js{kill}: \und, @frozen: \false) \sep {} \\
        % fun pre
        \lop \bp s_5 \sep \lfp \bp s_6 \sep
        L \bp \{(A, @scope)\} \sep \scopeBpsUpd(Ls, ss_1) \sep \ls\doteq{L:Ls}
      } \\
      \jsvar{kill = function() \{b_k\};} \\
      \logic{
        \exists K, K_p \st
        \left(\begin{array}{l}
          % var, assign
          \obj_L(\js{kill}: K, @frozen: \false) \sep
            K \bp s_8 \sep s_8 \doteq \{(L, \js{kill})\} \sep {} \\
          % fun pre
          \lop \bp s_9 \sep s_9 \doteq s_5 \cup \{(K_p, @proto)\} \sep \lfp \bp s_6
            \cup \{(K, @proto)\} \sep {} \\
            L \bp \{(A,@scope),(K,@scope)\} \sep {} \\
            \scopeBpsUpd(Ls, ss_1, ss_2, \{(K,@scope)\}) \sep {} \\
          % fun post
          \fullobj_{K_p}(@proto: \lop) \sep K_p \bp \{(K, \js{prototype})\} \sep {} \\
          \newfun_K(\ls, \_, b_k, K_p)
        \end{array}\right)\sep \ls\doteq{L:Ls}
      } \\
      \step{Frames} \\
      \logic{
        \obj_L(\js{access}:A, \js{kill}:K) \sep
        A \bp s_7 \sep K \bp s_8 \sep \lop \bp s_9 \sep \ls \doteq L : Ls
      } \\
      \js{return\ \{access: access, kill: kill\};} \\
      \logic{
        \exists O \st
        \left(\begin{array}{l}
          \obj_L(\js{access}:A, \js{kill}:K) \sep {} \\
          \fullobj_O(@proto: \lop, \js{access}: A, \js{kill}: K) \sep {} \\
          A \bp s_7 \cup \{(O, \js{access}\} \sep K \bp s_8 \cup \{(O, \js{kill})\}
            \sep {} \\
          \lop \bp s_9 \cup \{(O,@proto)\} \sep O \bp \{\} \sep \rv \doteq O
        \end{array}\right)
        \sep \ls \doteq L : Ls
      } \\
      \step{Frames} \\
      \logic{
        \obj_R(@body: \lambda\js{ref}.\{\dots\} , @scope: Ls) \sep {} \\
        \exists L, A, A_p, K, K_p, O \st {} \\
        \fullobj_L\left(\begin{array}{l}
          \js{ref}: V,@this: \_,@proto: \nil,@frozen: \false,\\
          \js{protected}: V,\js{access}: A,\js{kill}: K
        \end{array}\right) \sep {} \\
        \fullobj_{A_p}(@proto: \lop) \sep \fullobj_{K_p}(@proto: \lop) \sep {} \\
        \newfun_A(\ls,\js{field},b_a,A_p) \sep \newfun_K(\ls,\_,b_k,K_p) \sep {} \\
        \fullobj_O(@proto: \lop, \js{access}: A, \js{kill}: K) \sep {} \\

        \lop \bp s_3 \cup \{(A_p,@proto),(K_p,@proto),(O,@proto)\} \sep {} \\
        \lfp \bp s_4 \cup \{(A,@proto),(K,@proto)\} \sep {} \\
        A   \bp \{(L,\js{access}),(O,\js{access})\} \sep
        A_p \bp \{(A,\js{prototype}) \sep {} \\
        K   \bp \{(L,\js{kill}),(O,\js{kill})\} \sep
        K_p \bp \{(K,\js{prototype}) \sep {} \\
        V   \bp s_1 \cup \{(L,\js{ref}),(L,\js{protected})\} \sep {} \\
        \scopeBpsUpd(Ls,ss,ss_2,\{(A,@scope),(K,@scope))\}) \sep {} \\
        L   \bp \{(A,@scope),(K,@scope)\} \sep
        O   \bp \{\} \sep

        \rv \doteq O \sep \ls \doteq L : Ls
      }
    }
    \js{\}}
  \end{array}
\]
\caption{RevocableRef: Main body}
\label{rr-main}
\end{figure}

% RevocableRef#kill body call
\begin{figure}
\[
  \begin{array}{l}
    \jsvar{kill = function() \{} \\
    \indblock{
      \logic{
        (K, @body) \mapsto \lambda \_.\{b_k\} \sep (K, @scope) \mapsto L:Ls \sep {} \\
        \exists L' \st \ls \doteq L' : L : Ls \sep L' \bp \{\} \sep {} \\
        \fullobj_{L'}(@proto:\nil, @frozen:\false, @this:\_) \sep {} \\
        \obj_L(\js{protected}: V, @frozen: \false)
      } \\
      \step{Frame/exists} \\
      \logic{
        obj_{L'}(\js{protected}: \none, @proto: \nil) \sep {} \\
        obj_L(\js{protected}: V, @frozen: \false) \sep {} \\
        \ls \doteq L':L:Ls
      } \\
      \js{protected = null;} \\
      \logic{
        obj_{L'}(\js{protected}: \none, @proto: \nil) \sep {} \\
        obj_L(\js{protected}: \nil, @frozen: \false) \sep {} \\
        \ls \doteq L':L:Ls \sep \rv \doteq \nil
      } \\
      \step{Frame/exists} \\
      \logic{
        (K, @body) \mapsto \lambda \_.\{b_k\} \sep (K, @scope) \mapsto L:Ls \sep {} \\
        \exists L' \st \ls \doteq L' : L : Ls \sep L' \bp \{\} \sep {} \\
        \fullobj_{L'}(@proto:\nil, @frozen:\false, @this:\_) \sep {} \\
        \obj_L(\js{protected}: \nil, @frozen: \false) \sep \rv \doteq \nil
      }
    }
    \js{\}}
  \end{array}
\]
\caption{RevocableReference kill function body}
\label{rr-kill}
\end{figure}

\begin{figure}
% RevocableRef#access body call
\[
  \begin{array}{l}
    \jsvar{access = function(field) \{} \\
    \indblock{
      \logic{
        (A, @body) \mapsto \lambda \js{field}.\{b_a\} \sep
          (A, @scope) \mapsto L:Ls \sep {} \\
        \exists L' \st \ls \doteq L' : L : Ls \sep
          L' \bp \{\} \sep \bpGen(X, L', \js{field}, s) \sep {} \\
        \fullobj_{L'}(@this: \_, @proto: \nil, @frozen: \false, \js{field}: X)
          \sep {} \\
        (L, \js{protected}) \mapsto P \sep P \not\doteq \nil \sep P \dotin \loc
          \sep X \dotin \uvars
      } \\
      \step{Frame/exists} \\
      \logic{
        \obj_{L'}(\js{protected}: \none, @proto: \nil, \js{field}: X) \sep {} \\
        (L, \js{protected}) \mapsto P \sep P \not\doteq \nil \sep P \dotin \loc
          \sep {} \\
        X \dotin \uvars \sep \ls \doteq L':L:Ls
      } \\
      \js{return\ protected[field];} \\
      \logic{
        \obj_{L'}(\js{protected}: \none, @proto: \nil, \js{field}: X) \sep {} \\
        (L, \js{protected}) \mapsto P \sep
        P \not\doteq \nil \sep P \dotin \loc \sep {} \\
        X \dotin \uvars \sep \ls \doteq L':L:Ls \sep \rv \doteq \fld{P}{X}
      } \\
      \step{Frame/exists} \\
      \logic{
        (A, @body) \mapsto \lambda \js{field}.\{b_a\} \sep
          (A, @scope) \mapsto L:Ls \sep {} \\
        \exists L' \st \ls \doteq L' : L : Ls \sep
          L' \bp \{\} \sep \bpGen(X, L', \js{field}, s) \sep {} \\
        \fullobj_{L'}(@this: \_, @proto: \nil, @frozen: \false, \js{field}: X)
          \sep {} \\
        (L, \js{protected}) \mapsto P \sep P \not\doteq \nil \sep P \dotin \loc
          \sep X \dotin \uvars \sep \rv \doteq \fld{P}{X}
      }
    }
    \js{\}}
  \end{array}
\]
\caption{RevocableReference access function body}
\label{rr-access}
\end{figure}

\TODO{Extend to writing to objects via the proxy. Take careful note of
  \href{https://mail.mozilla.org/pipermail/es-discuss/2011-November/017981.html}
{Nov-11 es-discuss thread} (theft of \js{protected} by using \js{\_\_proto\_\_}
or through redefining/hiding a \emph{trusted prototypical} method (eg on Array))}

\COMMENT{Idea: Pre-set $\lop \bp \loc \times \vars$, since anything can
potentially point at our frozen language globals. How does this interact with
the consequence rule? (I'd guess that without an explicit $(a,b) \not\pointsto
\lop$, then we cannot remove it from the set?) This is inspired by the use of
$\top$ in Abstract Interpretation...}

\subsection{Membrane}
\label{sec:membrane}
A Membrane is a transitive Revocable Reference, in addition to protecting all
interactions with a particular object, a Membrane also protects all subsequent
products of interactions with the protected object.

This is achieve by wrapping all returned objects in a Membrane Reference that
shares its kill switch with its parent. When the Membrane is killed, all
references to the parent object and anything it created are blocked
simultaneously.

\begin{verbatim}
var Membrane = function(ref) {
  var killed = false;

  var MembraneRef = function(ref) {
    var access = function(field) {
      if(!killed) return MembraneRef(ref[field]);
    }
    if(primitive(ref)) { return ref; } else { return access; }
  }

  var access = MembraneRef(ref);
  var kill = function() { killed = true; }
  return {access: access, kill: kill};
}
\end{verbatim}

Notation:
\begin{itemize}
  \item $MRef_{MR}(M,r,F_A,S,T)$ \qquad Membrane reference for Membrane $M$ protecting object
$r$, corresponding access function $F_A$, (safe-side) backpointer set $S$ for
$r$, membrane-constructed backpointer set $T$.
\begin{align*}
  MRef_{MR}(M,r,F_A,S,T) &= \fun_{F_A}(MR:M:\_, \js{field}, \lambda_A, \_) \sep {} \\
                         & \fullobj_{MR}(\js{ref}: r, \js{access}: F_A, @this: \_, @proto: \nil) \sep
    r \bp S \cup T
\end{align*}

Note: We cannot use the $\newfun$ predicate here as we return this function out
to the usercode, it may be tampered with by having fields added, this does not
impact upon the function call, since all the information used by the proofs is
placed into internal fields, or within the function's scope chain.
(The corresponding $\newobj$ produced in proofs is framed off for clarity)

  \item $MRset_M(Ls,T)$ \qquad Membrane-backpointer constructor. Given a list of
constructed $MR$s (access functions thereon?), provide (maximal) backpointer set
for protected references for the Membrane $M$.
\[ MRset_M([], \{(M, \js{ref})\}) = \lemp \]
\[ MRset_M(L:Ls, Ts') = MRset_M(Ls, Ts) \sep Ts' \doteq Ts \cup \{(L, \js{ref})\}\]

  \item $alive(M, F_{MR})$ and $dead(M, F_{MR})$ \qquad encapsulates Membrane data object (AR),
    on which is contained initial reference to $r$, the killswitch, (kill
    function), MembraneRef constructor. (Use $membraneInstance$?)
    \begin{align*}
      MembraneInstance(M, F_{MR}) =& \obj_M(\js{ref}: \_, @this: \_, @proto: \nil,
      \js{MembraneRef}: F_{MR}, \js{kill}: F_{K}) \sep {} \\
  & \newfun_{F_{MR}}(M:\_, \js{ref}, \lambda_{MR}, \_) \\
alive(M, F_{MR}) =& MembraneInstance(M, F_{MR}) \sep (M, killed) \pointsto \false \\
 dead(M, F_{MR}) =& MembraneInstance(M, F_{MR}) \sep (M, killed) \pointsto \true
    \end{align*}

    Note: We are safe to use $\newfun$ here, as the $F_{MR}$ function is
    internal to the Membrane, it is guaranteed not to be tampered with.

  \item $kill(F_K, M)$ \qquad Represents the kill function $F_K$ for membrane $M$.
\[ kill(F_K, M) = \fun_{F_K}(M:\_, \_ , \lambda_K, \_) \]

\end{itemize}

We specify that the Membrane is not allowed to cause the creation of more
references to the protected object. And that a reference to the protected object
may not be returned.

Notes: our predicate needs to track all MembraneRefs created, we can do this
with rules in the proof that simply grow the set by the new objects.
This implies that security properties may require far larger footprints for
verification than safety properties.

Potential issue: Code within the membrane that creates new references to the
protected object during execution.

\begin{figure}[b]
  \[
    \begin{array}{l}
      \logic{
        ref \bp S \sep ref \dotin \loc \sep \ls \doteq Ls
      } \\
      \js{Membrane(ref);} \\
      \logic{
        \exists M, F_K, F_A, F_{MR}, MR, L \st \args{
          alive(M, F_{MR}) \sep
          kill(F_K,M) \sep
          MRef_{MR}(M, ref, F_A, S, T) \sep {} \\
          MRset([MR],T) \sep
          \fullobj_L(\js{access}:F_A,\js{kill}:F_K) \sep
          \rv \doteq L
        }
      } \\
      \\
      \tjs{var Membrane = function(ref) \{} \\
        \indblock{
          \logic{
            \fullobj_M \args{
              \js{ref}: ref, @this: \_, @proto: \nil, \js{killed}: \und, \\
              \js{MembraneRef}: \und, \js{access}: \und, \js{kill}: \und
            } \sep {} \\
            MRset_M([], T) \sep
            ref \bp S \cup T \sep
            ref \dotin \loc \sep
            \ls \doteq M:Ls
          } \\
          \tjs{var killed = false;} \\
          \tjs{var MembraneRef = function(ref) \{...\}} \\
          \tjs{var kill = function() \{...\}} \\
          \logic{
            alive(M, F_{MR}) \sep
            \newobj_M(\js{ref},@this,@proto,\js{killed},\js{MembraneRef},
                   \js{access},\js{kill}) \sep {} \\

            kill(F_K,M) \sep
            (M,\js{access}) \pointsto \und \sep {} \\

            MRset_M([], T) \sep
            ref \bp S \cup T \sep
            ref \dotin \loc \sep
            \ls \doteq M:Ls
          } \\
          \tjs{var access = MembraneRef(ref);} \\
          \logic{
            alive(M, F_{MR}) \sep
            \newobj_M(\js{ref},@this,@proto,\js{killed},\js{MembraneRef},
                   \js{access},\js{kill}) \sep {} \\

            kill(F_K,M) \sep
            (M,\js{access}) \pointsto F_A \sep {} \\

            MRset_M([MR], T') \sep
            MRef_{MR}(M,ref,F_A,S,T') \sep
            ref \dotin \loc \sep
            \ls \doteq M:Ls
          } \\
          \tjs{return \{access: access, kill: kill\};} \\
          \logic{
            alive(M, F_{MR}) \sep
            \newobj_M(\js{ref},@this,@proto,\js{killed},\js{MembraneRef},
                   \js{access},\js{kill}) \sep {} \\

            kill(F_K,M) \sep
            (M,\js{access}) \pointsto F_A \sep {} \\

            MRset_M([MR], T') \sep
            MRef_{MR}(M,ref,F_A,S,T') \sep
            ref \dotin \loc \sep {} \\

            \fullobj_L(\js{access}:F_A,\js{kill}:F_K) \sep
            \ls \doteq M:Ls \sep
            \rv \doteq L
          }
        }
        \tjs{\}} \\
        \\
        \\
        \logic{
          (\_,\js{kill}) \pointsto F_K \sep kill(F_K,M) \sep (alive(M, F_{MR}) \lor dead(M, F_{MR}))
        } \\
        \js{kill()} \\
        \logic{
          (\_,\js{kill}) \pointsto F_K \sep kill(F_K,M) \sep dead(M)
        } \\
        \gds{\dots and this is what you meant in your email about the $(\_,\js{kill})\pointsto F_k$, I see. I think what you've done is fine, because these lines aren't part of any proof. They're for illustration only - ``this is the sort of thing you can prove using the lemma below and the function call rule''. Make it clear that these things are informal aids to intuition, and your notation is fine.}
        \\
        \tjs{var kill = function() \{} \\
        \indblock{
          \logic{
            \exists A \st \ls \doteq A : M : \_ \sep
            \fullobj_A(@proto: \nil, @this: \_) \sep
            (alive(M, F_{MR}) \lor dead(M, F_{MR}))
          } \\
          \tjs{killed = true;} \\
          \logic{
            \exists A \st \ls \doteq A : M : \_ \sep
            \fullobj_A(@proto: \nil, @this: \_) \sep
            dead(M)
          }
        }
        \tjs{\}}
    \end{array}
  \]
  \caption{Proof \emph{outline} for \js{Membrane} and its \js{kill} function}
\end{figure}

\begin{figure}
  \gds{You might need ${} \sep \ls\doteq\dots$ in your $\tjs{MembraneRef}$ and $\tjs{access}$ specs.}
  \[
    \begin{array}{l}
      \logic{
        (\_,\js{MembraneRef}) \pointsto F_{MR} \sep
        alive(M, F_{MR}) \sep MRset_M(Ls,T) \sep ref \bp S \cup T \sep ref \dotin \loc
      } \\
      \tjs{MembraneRef(ref);} \\
      \logic{
        \exists R, F_A \st \args{
          (\_,\js{MembraneRef}) \pointsto F_{MR} \sep
          alive(M, F_{MR}) \sep MRset_M(R:Ls,T') \sep {} \\
          MRef_{R}(M,ref,F_A,S,T') \sep ref \dotin \loc \sep \rv \doteq F_A
        }
      } \\
      \\
      \tjs{var MembraneRef = function(ref) \{} \\
        \indblock{
          \logic{
            \exists R \st \args{
              alive(M, F_{MR}) \sep  \fullobj_{R}(\js{ref}: ref, @this: \_, @proto: \nil, \js{access}:
                \und) \sep {} \\
              ref \dotin \loc \sep
              MRset_M(R:Ls,T') \sep ref \bp S \cup T' \sep \ls \doteq R:M:Ls
            }
          } \\
          \tjs{var access = function(field) \{...\}} \\
          \logic{
            \exists R,F_A \st \args{
              alive(M, F_{MR}) \sep \fullobj_{MR}(\js{ref}: ref, @this: \_, @proto: \nil, \js{access}:
                F_A) \sep {} \\
              \newfun_{F_A}(R:M:Ls, \js{field}, \lambda_A, \_) \sep ref \dotin
              \loc \sep {} \\
              MRset_M(R:Ls,T') \sep ref \bp S \cup T' \sep \ls \doteq R:M:Ls
            }
          } \\
          \tjs{if(primitive(ref)) \{...\} else \{} \\
            \indblock{
              \tjs{return access;} \\
            }
          \tjs{\}} \\
          \logic{
            \exists R,F_A \st \args{
              alive(M, F_{MR}) \sep \fullobj_{R}(\js{ref}: ref, @this: \_, @proto: \nil, \js{access}:
                F_A) \sep {} \\
              \newfun_{F_A}(R:M:Ls, \js{field}, \lambda_A, \_) \sep ref \dotin
              \loc \sep {} \\
              MRset_M(R:Ls,T') \sep ref \bp S \cup T' \sep \ls \doteq R:M:Ls
                \sep {} \\
              \rv \doteq F_A
            }
          } \\
          \step{subst} \\
          \logic{
            \exists R,F_A \st \args{
              alive(M, F_{MR}) \sep MRset_M(R:Ls,T') \sep MRef_{R}(M,ref,F_A,S,T') \sep
                {} \\
              ref \dotin \loc \sep rv \doteq F_A \sep \ls \doteq R:M:Ls
            }
          }
        }
      \tjs{\}} \\
      \\
      \\
      \gds{As you noted in your email you need to pick some notation for naming the function in these informal intuition-aid spec illustrations. I prefer the style above to the ``dot-equals'' style below. What's your preference?}
      \logic{
        alive(M, F_{MR}) \sep
        access \doteq F_{A_1} \sep
        MRef_{R_1}(M,ref,F_{A_1},S_1,T_1) \sep
        MRset(Ls,T_1) \sep {} \\

        field \dotin \uvars \sep
        (ref, field) \pointsto V \sep
        V \dotin \loc \sep
        V \bp S_2
      } \\
      \js{access(field)} \\
      \logic{
        \exists R_2, F_{A_2} \st \args{
          alive(M, F_{MR}) \sep
          access \doteq F_{A_1} \sep
          MRef_{R_1}(M,ref,F_{A_1},S_1,T_2) \sep {} \\

          MRset(R_2:Ls,T_2) \sep
          MRef_{R_2}(M,V,F_{A_2},S_2,T_2) \sep
          \rv \doteq F_{A_2} \sep {} \\

          field \dotin \uvars \sep
          (ref, field) \pointsto V \sep
          V \dotin \loc
        }
      } \\
      \\
      \tjs{var access = function(field) \{} \\
        \indblock{
          \logic{
            \exists A \st \ls \doteq A : R_1 : M : \_ \sep
            \fullobj_A(\js{field}: field, @proto:\nil, @this:\_) \sep {} \\
            alive(M, F_{MR}) \sep
            MRef_{R_1}(M,ref,F_{A_1},S_1,T_1) \sep
            MRset(Ls,T_1) \sep {} \\

            field \dotin \uvars \sep
            (ref, field) \pointsto V \sep
            V \dotin \loc \sep
            V \bp S_2
          } \\
          \tjs{if(!killed) \{} \\
            \indblock{
              \logic{
                \exists A \st \ls \doteq A : R_1 : M : \_ \sep {} \\
                alive(M, F_{MR}) \sep
                MRef_{R_1}(M,ref,F_{A_1},S_1,T_1) \sep
                MRset_M(Ls,T_1) \sep {} \\

                (A, \js{field}) \pointsto field \sep
                field \dotin \uvars \sep {} \\

                (ref, field) \pointsto V \sep
                V \dotin \loc \sep
                V \bp S_2 \cup T_1
              } \\
              \tjs{return MembraneRef(ref[field]);} \\
              \logic{
                \exists A,R_2,F_{A_2} \st \args {
                  \ls \doteq A : R_1 : M : \_ \sep
                  alive(M, F_{MR}) \sep {} \\

                  MRef_{R_1}(M,ref,F_{A_1},S_1,T_1) \sep
                  MRef_{R_2}(M,V,F_{A_2},S_2,T_2) \sep {} \\

                  MRset_M(R_2:Ls,T_2) \sep
                  \rv \doteq F_{A_2} \sep {} \\

                  (A, \js{field}) \pointsto field \sep
                  field \dotin \uvars \sep
                  (ref, field) \pointsto V \sep
                  V \dotin \loc
                }
              } \\
            }
          \tjs{\}} \\
            \logic{
              \exists A,R_2,F_{A_2} \st \args{
                \ls \doteq A : R_1 : M : \_ \sep
                \fullobj_A(\js{field}: field, @proto:\nil, @this:\_) \sep {} \\

                alive(M, F_{MR}) \sep
                MRef_{R_1}(M,ref,F_{A_1},S_1,T_2) \sep {} \\

                MRset(R_2:Ls,T_2) \sep
                MRef_{R_2}(M,V,F_{A_2},S_2,T_2) \sep
                \rv \doteq F_{A_2} \sep {} \\

                field \dotin \uvars \sep
                (ref, field) \pointsto V \sep
                V \dotin \loc
              }
            }
        }
      \tjs{\}}
    \end{array}
  \]
  \caption{Proof \emph{outlines} for the nested \js{MembraneRef} and \js{access} functions}
\end{figure}

\end{document}
