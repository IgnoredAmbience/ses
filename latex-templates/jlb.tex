%SPLASH
\documentclass{article}
%\documentclass[9pt]{sigplanconf}

%\usepackage[pdftex]{graphicx}
%\graphicspath{{figs/}}

\usepackage{amsmath}
\usepackage{relsize}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{stmaryrd}
\usepackage{cancel}
\usepackage{wasysym}
\usepackage[usenames,dvipsnames]{color}
\usepackage{xspace}
\usepackage{url}
\usepackage{verbatim}
\usepackage{proof}
% The following makes landscape work, but only for pdfs.
\usepackage{rotating}
\usepackage{gds}

\usepackage{xr-hyper}
\usepackage[colorlinks,urlcolor=MidnightBlue,linkcolor=MidnightBlue,citecolor=MidnightBlue,backref]{hyperref}

\newcommand{\hl}[1]{\emph{#1}}
\newcommand{\iflong}[1]{#1}
%\newcommand{\iflong}[1]{}
%\newcommand{\ifshort}[1]{#1}
\newcommand{\ifshort}[1]{}

% Submission guidelines. Authors should submit an abstract of at most 300 words and a full paper of no more than 
% 12 pages formatted according to the ACM proceedings format. These 12 pages include everything (i.e., it is the
% total length of the paper). The program chair will reject papers that exceed the length requirement or are submitted 
% late. Templates for ACM format are available for Word Perfect, Microsoft Word, and LaTeX at 
% http://www.acm.org/sigs/sigplan/authorInformation.htm (use the 9 pt template). Submissions should be in PDF and 
% printable on US Letter and A4 sized paper.
%
% Submitted papers must adhere to the SIGPLAN Republication Policy. Concurrent submissions to other 
% conferences, workshops, journals, or similar forums of publication are not allowed. 
%
% Following the recent history of PLDI and the lengthier history of other conferences, POPL'12 will employ 
% double-blind reviewing.  To facilitate this, submitted papers must adhere to two rules: (1) author names and 
% institutions must be omitted and (2) references to authors' own related work should be in the thdird person (e.g., not 
% "We build on our previous work ..." but rather "We build on the work of..."). Nothing should be done in the name 
% of anonymity that weakens the submission or makes the job of reviewing the paper more difficult (e.g., important 
% background references should not be omitted or anonymized).  When in doubt, contact the program chair.  A FAQ 
% with further details will be made available closer to the submission deadline.
%
% There is an option on the submission page to submit supplementary material, e.g., a tech report with proofs, or 
% the software used to implement a system.  This supplemental material should NOT be anonymized; it will be made 
% available to reviewers after the intial reviews have been completed and author names are revealed. Reviewers may 
% choose to use the supplemental material or not at their discretion.  Authors can submit URLs to TRs or software 
% (e.g., in a text file), rather than the paper or code itself, since all supplemental material is not anonymous.

\begin{document}

\ifshort{
\conferenceinfo{POPL'12,} {January 25--27, 2012, Philadelphia, PA, USA.}
\CopyrightYear{2012}
\copyrightdata{978-1-4503-1083-3/12/01} 
}

%\newcommand\comment\footnote
\newcommand{\remark}[1]{}
%\renewcommand\footnote[1]{}




\title{Towards a Program Logic for JavaScript}%\thanks{Draft submitted to POPL 2012, currently under revision.}}

\ifshort{
\authorinfo{Philippa Gardner}
           {Imperial College London}
           {pg@doc.ic.ac.uk}
\authorinfo{Sergio Maffeis}
           {Imperial College London}
           {maffeis@doc.ic.ac.uk}
\authorinfo{Gareth Smith}
           {Imperial College London}
           {gds@doc.ic.ac.uk}
}
\iflong{
\author{Philippa Gardner, Sergio Maffeis, Gareth Smith}
\date{\{pg,maffeis,gds\}@doc.ic.ac.uk}
}


\maketitle



\begin{abstract}

JavaScript has become the most widely used language for client-side web programming.  
%
The dynamic nature of JavaScript makes understanding its code notoriously difficult, leading to buggy programs and a lack of adequate static-analysis tools.  
%
We believe that logical reasoning  has much to offer JavaScript: a simple  description of program behaviour, a clear understanding of module boundaries, and the ability to verify security contracts. 

We introduce a program logic for reasoning about  a broad subset of
JavaScript, including challenging features  such as prototype inheritance and
\js{with}.  We  adapt ideas  from separation logic  to provide
tractable reasoning about JavaScript code: reasoning about easy programs is
easy; reasoning about hard programs is possible. We prove a strong
soundness result. All libraries written in our subset and
proved  correct with respect to their specifications will be well-behaved,
even when called by arbitrary JavaScript code.


\end{abstract}

\ifshort{
\category{F.3.1}{Theory of Computation}{Logics and Meanings of Programs}[Specifying and Verifying and Reasoning about Programs]

\terms
Reliability, Theory, Verification

\keywords
JavaScript, Separation Logic, Web
}

\section{Introduction} 



%JavaScript is the primary language for client-side web programming. 

JavaScript has become the de-facto  language for client-side web programming. Ajax web applications, used in e.g.  Google Docs, are based on a combination of JavaScript and server-side programming. JavaScript has become an international standard called ECMAScript~\cite{ecma262}. Adobe Flash, used in e.g.  YouTube, features  ActionScript,  a programming language based on ECMAScript.  Even web applications written in e.g.  Java, F$\sharp$  or purpose-designed languages such as Flapjax or Milescript are either compiled to JavaScript, or they lack browser integration or cross-platform compatibility.  JavaScript is currently the assembly language of the Web, and this seems  unlikely to change.

%or reliant on non-standard browser extensions which severely limit browser integration, portability or both\remark{Something like this? --gds}.






JavaScript was initially created for small web-programming tasks, which benefited from the flexibility of the language and tight browser integration. Nowadays, the modern demands placed on JavaScript are huge. Although this flexibility and browser integration are still key advantages, the inherent dynamic nature of the language makes current web code based on ECMAScript~3 notoriously difficult to write and use~\cite{MMT-APLAS-TR08,Guha2010,Richards2010}.  The expectation is that ECMAScript~5 and future standards will improve the situation. However, although the main browsers now support ECMAScript~5, the majority of code being written today is in ECMAScript~3. Even if there is a wide acceptance of ECMAScript~5, which is certainly not clear from the current blogs, it is inevitable that
 ECMAScript~5 libraries  will have to interface properly with ECMAScript~3 code.
We  therefore believe that there is a growing need for general-purpose,  expressive analysis tools for both ECMAScript~3 and~5, which provide  simple, correct descriptions of program behaviour and  a clear understanding of module boundaries. 


We introduce a program logic for reasoning about ECMAScript~3. While it is tempting to ignore the `ugly' parts of the language, and reason only about `well-written' code, in practice JavaScript programs have to interface with arbitrary web code.
%This code  can be badly written, untrusted and potentially malicious. We are particularly concerned with library code, which must be well-behaved when called by arbitrary code. 
We therefore use a model of the language that does not shun the most challenging JavaScript features. 
For example, the behaviour of  prototype inheritance,  and the interplay between scoping rules and the $\js{with}$ statement, is complex. This means that our basic reasoning rules must also be  complex.  We overcome this complexity by establishing natural layers of abstraction on top of our basic reasoning.  With principled code, we can stay within these layers of abstraction and the reasoning is straightforward.  With arbitrary code, we must break open the appropriate  abstraction layers until we can re-establish the invariants of the abstraction. In this way, we are able to provide clean specifications of a wide variety of JavaScript programs.



%
%While there are promising approaches to problem-specific static analyses of JavaScript~\cite{pldi09-sif,thiemann-ai-js,jsapis, MMT-CSF-TR09,Sands08,YuChander07,Giannini,ThiemannE}, there is a growing need 


%We  believe that program reasoning has  a lot to offer JavaScript.  which enables us to write and verify web code to specification.


%While JavaScript as a whole is well known for being a challenging language,
%there are several JavaScript subsets which are ``more reliable, readable, and
%maintainable than the language as a whole'' (-- Douglas Crockford in
%``JavaScript: The Good Parts''). 




% We significantly adapt ideas  from separation logic  to provide
%tractable reasoning about JavaScript code: reasoning about easy programs is
%easy, and reasoning about hard programs is possible.


Our reasoning is based on separation logic.  Separation logic has proven to be invaluable for reasoning about programs which directly manipulate the heap, such as C and Java programs~\cite{DBLP:conf/csl/OHearnRY01,conf/fmco/BerdineCO05,spacep,slayerp,1449782}.  A key characteristic of JavaScript is that the entire state of the language resides in the object heap, in a structure that imperfectly emulates the variable store of many other programming languages.  It is therefore natural to investigate the use of separation logic to verify JavaScript programs. In fact, we had to fundamentally adapt  separation logic, both to present an accurate account of JavaScript's emulated variable store (see  Section~\ref{sec:simplereasoningcomplexlanguage}: Motivating Examples) % of our reasoning), 
 and also to establish soundness.
%
For soundness,  it is usual to require that all the program commands are `local', according to  a definition first given
in~\cite{DBLP:conf/csl/OHearnRY01}. Many JavaScript statements are not local
by this definition: for example, even a simple variable read is non-local because its result 
%GDS: Changed this - hope you don't mind.
may depend on the \emph{absence} of certain fields in the emulated variable store.
%depends on where the variable occurs in the Javascript variable store. 
We instead  prove soundness using a concept of \emph{weak locality}, recently 
introduced by Smith~\cite{gdsThesis}. 


In this paper, we reason about a substantial subset  of JavaScript, including prototype inheritance, $\js{with}$, simple functions
(no recursive or higher-order functions) and simple \js{eval}. Our treatment of functions and \js{eval}  is precisely enough to 
expose fully the complexity of the emulated variable store. Building on the work of Charlton and Reus~\cite{billiejoe,Schwinghammer09nestedhoare}, we will extend our reasoning 
to  higher-order functions and complex \js{eval} in future.
We prove soundness  of our reasoning with respect to a faithful subset of the formal operational semantics of Maffeis \emph{et al.}~\cite{MMT-APLAS-TR08}. Our soundness result has powerful implications. 
%
Library code 
written in our subset and proved correct with respect to their  specifications will be well-behaved,
even when called by arbitrary JavaScript code. Our  result is constructed in such a way  that it will be  simple to extend 
to reasoning  about higher-order functions and complex \js{eval} in due course. 




%Using
%their semantics, we have shown that not only is our reasoning sound, but that
%it is sound with respect to all program contexts in which it is used.

%Thus,
%all syntactically correct library code proved correct with respect to its specification will be well
%behaved, regardless of what JavaScript code calls it.  It also means that we
%can simply extend our reasoning to account for larger subsets of JavaScript
%(essentially adding logical support for higher-order functions and eval), without having to redo
%the work presented here.



 



%Separation logics has proven to be a useful tool on other languages~\cite{DBLP:conf/csl/OHearnRY01}.
%
%Correctness of rewriting mechanisms for subsets (which are not in subsets)~\cite{MMT-CSF-TR09,mmt-esorics09,mmt-oakland10,adsafe,caja,Sands08}.
%
%In particular, it would be valuable to have precise analysis of the JavaScript heap.
%
%Connection with the DOM~\cite{Thiemann05A,Gardner08DOM,Smith2010}.
%
%Many static analyses aim for example to approximate call and prototype graphs~\cite{gatekeeper,Jang2009,...,pldi09-sif,thiemann-ai-js}.


%JavaScript is described here~\cite{FlanaganJS,ungar87self,ecma262}. 
%%
%There are several models for JavaScript.
%
%Either the model is very precise but reasoning is complicated~\cite{online,MMT-APLAS-TR08}, or vice-versa~\cite{YuChander07,Giannini,HermanFlanagan,ThiemannE}.
%
%A model of JavaScript must deal with its unusual features~\cite{Richards2010}.
%
%JavaScript's dynamicity is one of the reason of its success.
%
% Scope objects are good.
% %
% %
% References: ECMA spec, SOS Aplas, subsets (CSF/ESORICS), DOCOMO, Thiemann, lambdajs.
% %
% We tackle the hard, non-standard bits of JavaScript using separation logics.
% %
% Our is first (or best) separation logics proposal.
% %
% We aim for complete, functional correctness.
% %


%
%
%
%
%Separation logics contributions.
%%
%First use of "NONE" to reason about the absence of heap fields. 
%%
%Sepish.
%%
%Weak locality in proof of frame rule~\cite{Smith2010}.
%
%
%
%
%
%
%Summary of our contributions.
%%
%Plan of the paper.
%
%
%
%
%
%
%

%% Intro 






\section{Motivating Examples} 
\label{sec:simplereasoningcomplexlanguage}

As convincingly argued in~\cite{MMT-APLAS-TR08,Guha2010,Richards2010,Vitek-Eval}, there are many reasons why
the behaviour of JavaScript programs is complex.
%
For a start, JavaScript is a dynamically typed, prototype-oriented
language, which does not have a standard notion of variable store.
Instead, JavaScript variables are best regarded  as being stored in the
heap, in a structure which imperfectly emulates the variable store. This structure consists of an
abstract list of scope objects, called the {\em scope chain}, analogous to stack frames in other
languages. Every scope object has a pointer to a linked list of
prototypes, providing prototype-based inheritance. Since scope objects
inherit data from their prototypes, the value of a variable cannot be
resolved by a simple list traversal. Variable resolution is further
complicated by the fact that JavaScript objects may share a common
prototype.
%.........??????????............got rid of null-terminated because scope is subtler than that.......

JavaScript's behaviour can make apparently simple programs deceptively
counter-intuitive. Consider the code \js C defined below:
%
\begin{verbatim}
  x = null; y = null; z = null;
  f = function(w){x = v; v = 4; var v; y = v;};
  v = 5; f(null); z = v; 
\end{verbatim}
%                
%
%Figure~\ref{fig:scopeExample}.
%\begin{figure}
%        \begin{center}
%                \begin{verbatim}
%                x = null; y = null; z = null;
%                f = function(w){x = v; v = 4; var v; y = v;};
%                v = 5; f(null); z = v; 
%                \end{verbatim}
%\end{center}
%\caption{Variable Scope Example}
%\label{fig:scopeExample}
%\end{figure}
What values should the variables $\js{x}$, $\js{y}$ and $\js{z}$ store at the end of the program? The correct answer is $\js{undefined}$, $4$ and $5$  respectively. We explain how this occurs as we walk through our reasoning.

%The reason $\js{x}$ takes the value $\js{undefined}$ is that when
%JavaScript calls the function $\js{f()}$, it performs two passes on the body of
%$\js{f()}$. In the first pass, it just looks for variable declarations, in our example  the 
%$\js{var v}$, and initialises those local variables to $\js{undefined}$. In the
%second pass, it runs the code in the newly constructed local scope. % The
% following three function bodies are equivalent:
% \[
% \begin{array}{l@{\qquad\qquad}l@{\qquad\qquad}l}
%         \js{x = v;}  &  \js{var v;}  & \js{x = v;}\\
%         \js{v = 4;}  &  \js{x = v;}  & \js{var v = 4;}\\
%         \js{var v;}  &  \js{v = 4;}  & \js{y = v;}\\
%         \js{y = v;}  &  \js{y = v;}  & \\
% \end{array}
% \]

In Section~\ref{sec:examples:varscope} we prove the following triple of this code:
        \[\begin{array}{c}
                \left\{\begin{array}{l}

                        \store_{\V{LS}}(\js{x},\js{y},\js{z},\js{f},\js{v}|)\sep\ls\doteq\V{LS}
                \end{array}\right\}\\
                \js C\\
                \left\{\begin{array}{l}
                        \exists\V{L}\st
                        \store_{\V{LS}}(|\js{x}:\und,\js{y}:4,\js{z}:5,\js{f}:\V{L},\js{v}:5)\\
                        {}\sep\ls\doteq\V{LS}
                        \sep\true\\
                \end{array}\right\} \\
        \end{array}\]
We   distinguish a  global logical 
expression $\ls$ with  value  $\V{LS}$ denoting
the scope chain. 
The 
 $\store$ predicate  $\store_{\V{LS}}(\js{x},\js{y},\js{z},\js{f},\js{v}|)$
states that the store-like structure referred to by $\V{LS}$ contains 
{\em none} of the program variables mentioned; the variables occur to the left of the bar.
The  $\store$ predicate
$  \store_{\V{LS}}(|\js{x}:\und,\js{y}:4,\js{z}:5,\js{f}:\V{L},\js{v}:5)$  denotes 
the final values for all the variables; the variables occur to  the  right of the bar with assigned values. 




To understand the complexity of the heap structures described by  $\store$ predicates, consider  the  example heap given in 
Figure~\ref{fig:variableStore}.
% \begin{figure}
%         \begin{center}
% %                \includegraphics[width=\linewidth]{figs/variablestore.pdf}
%                 \includegraphics[width=\linewidth]{figs/diag.pdf}
%         \end{center}
%         \caption{SM: Another diagram, if needed.}
%         \label{fig:variableStore1}
% \end{figure}
%
\begin{figure}
      \begin{center}
                \includegraphics[width=200pt]{figs/variableStoreTakeTwo.pdf}
        \end{center}
        \caption{A JavaScript emulated variable store}
        \label{fig:variableStore}
\end{figure}
\noindent This diagram illustrates a typical shape of a %(partial??) 
JavaScript variable store. Each object is denoted by a  box.
In this example, the current list of scope objects is given by $\ls =
[l_1, l_2, l_3, l_4, \lgo]$, where the  $l_i$  are object addresses
and $\lgo$ is a distinguished object containing the global variables which must occur  at the end of the current list of scope objects.
Each scope  object has a pointer to a list of prototypes, with the
arrows representing prototype relationships. These prototype lists can
be shared, but cannot form cycles. In ECMAScript~3, prototype lists must either end with the distinguished object $\lop$ or  be empty. %% They can  be complete, in the sense that they end with the distinguished object $\lop$.%  which points to $\nil$.
%% They can  be empty, since the prototype of a scope object may be $\nil$. Finally, if the browser running the program uses SpiderMonkey, V8 or WebKit, non-empty lists are allowed not to include $\lop$, although they still need to be $\nil$-terminated.
%% % 
 However, many implementations (SpiderMonkey, V8 and
WebKit) allow the programmer to directly access and change the
prototype pointers,  allowing incomplete prototype chains ending in $\js{null}$ but not allowing  the creation of cycles. We work with 
incomplete prototype chains, since we want ECMAScript~3  library code to work well with  such implementations. 

%For this reason we do not rely on any particular
%structure of prototype chains in our model. We do assume acyclicity,
%since that is guaranteed by both the ECMAScript~3 specification and
%the main web browsers.
%% This last case is not illustrated in Figure~\ref{fig:variableStore}, because 
%% it is not allowed by the ECMAScript~3 specification. It is however sufficiently common that it is worth ensuring that it does not affect the soundness of our reasoning. Our scope predicate therefore allows such partial lists. 

To look up the value of a variable $\js{x}$ in our example heap, we check each object for
a field with  name $\js{x}$, starting with $l_1$, checking the prototype list from $l_1$ then moving along the list of scope objects. In our example, the $\js{x}$ in object $l$ will be found first, since the whole prototype chain of $l_2$ will be visited before $l_3$. 
When reading the value stored in $\js{x}$, this is all we need to know.
If we  write to the same variable $\js{x}$, the effect will be
to create a new field $\js{x}$ at $l_2$. This new field will override
the $\js{x}$ field in object $l$  in the usual prototype-oriented way.



All of this messy detail is abstracted away by the $\store$ predicate. The formation of this  predicate is subtle and requires some adaptation of separation logic. 
As well as  the separating conjunction $\ast$ for reasoning  about
disjoint heaps, we introduce the \emph{sepish} connective
$\sepish$ for reasoning about partially separated heaps. It  is used, for example,  to account for  the sharing of prototype lists  illustrated in Figure~\ref{fig:variableStore}.
We also use  the assertion $(l,\js{x})\pointsto\none$, which states
that the field $\js{x}$ is {\em not} present at object address $l$. This predicate  is  reminiscent of the `out' predicate in~\cite{CAP}  stating  that values are not present in a concurrent list.
It  is necessary to identify the first $\js{x}$ in the structure: in our example, the $\js{x}$ at $l$ is the first $\js{x}$, since it does not occur in the prototype list of $l_1$ nor in the prototype list of $l_2$ until $l$.


%This is inspired by Dinsdale-Young {\em et al.}'s  use of the `out' predicate to ~\cite{.}.

Our store predicate allows us to make simple inferences  about variable assignments, without breaking our store abstraction: 
        \[\begin{array}{c}
                \left\{\begin{array}{l}
                        \store_{\V{LS}}(\js{x},\js{y},\js{z},\js{f},\js{v}|) \sep\ls\doteq\V{LS}
                \end{array}\right\}\\
                \js{x = null;}\\
                \left\{\begin{array}{l}
                        \store_{\V{LS}}(\js{y},\js{z},\js{f},\js{v}|\js{x}:\nil) \\
                        {}\sep\ls\doteq\V{LS}\sep \true
                \end{array}\right\} \\
        \end{array}\]
where the assertion $ \true$ hides potentially garbage-collected prototype lists. 

The evaluation of the function
expression \js{function(w) \{\dots \}} has the effect of creating a new
function object and returning the address $\V{L}$ of that
object. The object contains a number of internal housekeeping fields, including  $\bodyp$
which contains the body of the function and $\fscopep$ which stores the
function closure $\V{LS}$. Our  inference for the function definition  is approximately:
        \[\begin{array}{c}
                \left\{\begin{array}{l}
                        \store_{\V{LS}}(\js{f},\js{v}|\js{x}:\nil,\js{y}:\nil,\js{z}:\nil) \sep\ls\doteq\V{LS}
                \end{array}\right\}\\
                \js{f = function(w) \{\dots\}}\\
                \left\{\begin{array}{l}
                        \exists\V{L}\st
                        \store_{\V{LS}}(\js{v}|\js{x}:\nil,\js{y}:\nil,\js{z}:\nil,\js{f}:\V{L}) \sep {}\\
                        (\V{L},\bodyp)\pointsto \lambda w . \{\dots\}
                        \sep (\V{L},\fscopep)\pointsto\V{LS}\sep{}\\
                        \ls\doteq\V{LS}\sep\true
                \end{array}\right\} \\
        \end{array}\]

As well as the \store predicate, we  assert that the state also contains
object cells such as $(\V{L},\fscopep)\pointsto\V{LS}$. This assertion means that
there is an object with address $\V{L}$ in the heap, and it definitely contains
at least the field $\fscopep$ which has value $\V{LS}$. The assertion says nothing
about any other field of $\V{L}$.  We assert that our function object has
fields $\bodyp$ and $\fscopep$. The full specification, given in
Section~\ref{sec:examples:varscope},  is actually a little more complicated than
this.  For now, we hide additional housekeeping  fields in the assertion $\true$.

We know that this program example is challenging, because %it is difficult to
% calcualte the correct 
the final values of the variables are counter-intuitive.  All the complexity of
the example occurs within the function call.  When JavaScript calls a function,
it performs two passes on the body: in the first pass, it creates a new scope
object and initialises local variables to $\js{undefined}$; in the second pass,
it runs the code in the newly constructed local scope.
Our reasoning reflects this complexity. 
The Hoare triple for the function call  has the following shape:
\[\begin{array}{c}
        \left\{\begin{array}{l}
             
                \store_{\V{LS}}(|\js{x}:\nil,\js{y}:\nil,\js{z}:\nil,\js{f}:\V{L},\js{v}:5) \sep {}\\
                (\V{L},\bodyp)\pointsto \lambda w.\{\dots\}\sep
                (\V{L},\fscopep)\pointsto \V{LS}  \sep{}\\
                \ls\doteq\V{LS}\sep\true
        \end{array}\right\}\\
\js{f(}\nil\js{);}\\
        \left\{\begin{array}{c}
                %\exists \V{L}, \V{L}' \st 
                %\store_\ls(|\js{x}:\text{\bf ?},\js{y}:\text{\bf ?},\js{z}:\text{\bf ?},\js{f}:\text{\bf ?},\js{v}:\text{\bf ?})\sep{}\\
                %(\V{L},\bodyp)\pointsto \lambda w.\{\dots\}\sep
                %(\V{L},\fscopep)\pointsto \V{LS}  \sep {} \\
                %\qquad\qquad\qquad\qquad

                \text{Q }
        \end{array}\right\}% \qquad [\text{from Figure~\ref{fig:functionbody}}]
\end{array}\]
%         \left\{\begin{array}{l}
%                 \exists \V{L}, \V{L}' \st 
%                 \store_\ls(|\js{x}:\und,\js{y}:4,\js{z}:\nil,\js{f}:\V{L},\js{v}:5)\sep{}\\
%                 (\V{L},\bodyp)\pointsto \lambda w.\{\dots\}\sep
%                 (\V{L},\fscopep)\pointsto \V{LS}  \sep {} \\
%                 %(\lop,\js{x})\pointsto\none \sepish(\lop,\js{y})\pointsto\none\sep{}\\
%                 \newobj(\V{L}',\protop,\js{w},\js{v},\thisp)\sep (\V{L}',\protop)\pointsto \nil \sep{}\\
%                 (\V{L}',\js{w})\pointsto\nil \sep (\V{L}',\js{v})\pointsto 4\sep\true\\
%         \end{array}\right\}% \qquad [\text{from Figure~\ref{fig:functionbody}}]

To find a suitable postcondition $Q$,  we must reason about the function body. The precondition of the function-body  triple given below
is constructed from the first pass of the function call. As well as containing   the precondition of the function call, it   contains a new scope object $\V{L}'$ with fields given by the parameter of the function and the local variables discovered by the first pass. For  our example, it contains the  assertions
$(\V{L}',\js{w})\pointsto\nil$ for the parameter declaration and  $(\V{L}',\js{v})\pointsto\und$  for the  local variable declaration. 
The object $\V{L}'$ also has a
$\protop$ field, which points to $\nil$ since scope objects do not inherit
any behaviour, and a $\thisp$ field,  which can only be read. 
We also 
have the predicate $\newobj(\V{L}',\protop,\thisp,\js{w},\js{v})$, which
asserts the absence from $\V{L}'$ of  all the fields we have not mentioned as parameters. Knowing
this absence of fields  is essential if, in the function body, we  wish to write to variables,  such as the \js{x} and  \js{y}, 
which do not appear in the local scope object. 
Finally, the new scope object $\V{L}'$ is prepended to the scope list $\ls$. 

 Using this precondition, we are now able to  give the triple obtained by the second pass of the function call:

 %which 
%runs the code having assigned all the local variable declarations to $\und$:

%This triple says that the store has been updated in accordance with the effects
%of the function call, and also that a new local scope object $\V{L}'$ has been
%created. %Since we do not intend to call \js{f()} a second time, we have hidden
%%the function object $\V{L}$ inside the $\true$ assertion.
%The final contents of
%the scope object $\V{L}'$ and the effects of the function call are determined
%by the program body.  The inference rule for function call (given in
%Section~\ref{sec:reasoning}) therefore allows us to derive this triple, so long
%as we can prove the following triple about the function body:

\[\begin{array}{c}
        \left\{\begin{array}{l}
                \exists \V{L}'\st \ls\doteq\V{L}':\V{LS} \sep {}\\
                \store_\V{LS}(|\js{x}:\nil,\js{y}:\nil,\js{z}:\nil,\js{f}:\V{L},\js{v}:5) \sep {}\\
                (\V{L},\bodyp)\pointsto \lambda w.\{\dots\}\sep
                (\V{L},\fscopep)\pointsto \V{LS}  \sep {} \\
                %(\V{L}',\js{x})\pointsto\none \sep
                %(\V{L}',\js{y})\pointsto\none \sep{}\\
                %(\V{L}',\js{z})\pointsto\none \sep{}\\
                %\newobj(\V{L}',\protop,\js{w},\js{v})\sep
                \newobj(\V{L}',\protop,\thisp,\js{w},\js{v})\sep \\
                (\V{L}',\js{w})\pointsto\nil \sep 
                (\V{L}',\js{v})\pointsto\und\sep {}\\
          (\V{L}',\protop)\pointsto \nil \sep{}       (\V{L}',\thisp)\pointsto  \V{L}''\sep\true
        \end{array}\right\}\\
        \js{x = v ; v = 4 ; var v ; y = v;}\\
        \left\{\begin{array}{l}
                \exists \V{L}'\st \ls\doteq\V{L}':\V{LS} \sep {}\\
                \store_\V{LS}(|\js{x}:\und,\js{y}:4,\js{z}:\nil,\js{f}:\V{L},\js{v}:5) \sep {}\\
                (\V{L},\bodyp)\pointsto \lambda w.\{\dots\}\sep
                (\V{L},\fscopep)\pointsto \V{LS}  \sep {} \\
                %(\V{L}',\js{x})\pointsto\none \sep
                %(\V{L}',\js{y})\pointsto\none \sep{}\\
                %(\V{L}',\js{z})\pointsto\none \sep{}\\
                %\newobj(\V{L}',\protop,\thisp,\js{w},\js{v})\sep
                \newobj(\V{L}',\protop,\thisp,\js{w},\js{v})\sep\\
                (\V{L}',\js{w})\pointsto\nil \sep 
                (\V{L}',\js{v})\pointsto 4\sep{}\\
            (\V{L}',\protop)\pointsto \nil \sep{}      (\V{L}',\thisp)\pointsto \V{L}''\sep\true
        \end{array}\right\}\\
\end{array}\]


%This triple describes an initial state in which the local scope object $\V{L}'$
%has been created and prepended to the head of the scope list $\ls$. The local
%scope object $\V{L}'$ is initialised with the parameter \js{w} and the local
%variable \js{v}. The initial value of all local variables in JavaScript is
%$\und$, and \js{w} is initialised with the value of the parameter of the
%function call, which in this case is $\nil$. The function call rule also allows us to use the \newobj predicate to assert that
% variables not initialised by the function call, such as \js{x} and \js{y}, do \emph{not} appear in the local scope object. Knowing this is
%essential if we wish to be able to write to global variables from the body of
%the function.  
%In the general case we can reason about infinite sets of
%non-existent variables with a predicate called $\newobj$, but for this example it
%is sufficient to describe \js{x} and \js{y}.

% Recall that $\ls$ always denotes the current scope-list. Since we are now
% reasoning about the body of a function, \ls has changed to reflect the new
% scope list - it consists of the local scope object $\V{L}'$ and the old global
% scope $\V{LS}$.
The postcondition follows simply from the three assignments in the function body:
first, variable $\js{x}$ gets the value $\und$, since this is the current value of the local \js{v}; then the local $\js{v}$ is assigned $4$; and, finally, the global variable $\js{y}$ is assigned the value of the local variable $\js{v}$.
The $\js{var v}$
statement has no effect in the second pass of the function call. 


%counterintuitive assignments in the store of the postcondition. 

The postcondition of the function call is the postcondition of the function body, with local scope object $\V{L}'$ popped off the current scope list $\ls$:
\[
      \left\{\begin{array}{l}
              \exists\V{L}' \st 
              \store_{\V{LS}}(|\js{x}:\und,\js{y}:4,\js{z}:\nil,\js{f}:\V{L},\js{v}:5) \sep {}\\
               (\V{L},\bodyp)\pointsto \lambda w.\{\dots\}\sep
               (\V{L},\fscopep)\pointsto \V{LS}  \sep {} \\
               \newobj(\V{L}',\protop,\thisp,\js{w},\js{v})\sep \\
               (\V{L}',\js{w})\pointsto\nil \sep 
               (\V{L}',\js{v})\pointsto 4\sep
               (\V{L}',\protop)\pointsto \nil \sep{}   \\
               (\V{L}',\thisp)\pointsto L''\sep\ls\doteq\V{LS}\sep\true
       \end{array}\right\}
\]
Reasoning about the final assignment is straightforward, with \js{z} assigned the value of the global variable \js{v}. The
final postcondition is obtained using the consequence rule to hide the  function object and  local scope object behind the assertion $\true$, since they are surplus to requirements, and existentially quantifying  function object $\V{L}$: 
\[\begin{array}{c}
%         \left\{\begin{array}{l}
%                 \exists \V{L} \st 
%                 \store_\ls(|\js{x}:\und,\js{y}:4,\js{z}:\nil,\js{f}:\V{L},\js{v}:5)
%                 \sep\true\\
%         \end{array}\right\}\\
%         \js{z = v};\\
        \left\{\begin{array}{l}
                \exists \V{L} \st 
                \store_{\V{LS}}(|\js{x}:\und,\js{y}:4,\js{z}:5,\js{f}:\V{L},\js{v}:5)
                \sep\\
                \ls\doteq\V{LS}\sep\true
        \end{array}\right\}% \qquad [\text{from Figure~\ref{fig:functionbody}}]
\end{array}\]





% This specification uses some notation we have not yet introduced. Chief among
% them is $(\V{L}',\protop)\pointsto\nil$. This formula describes a one-cell heap
% containing the $\protop$ field of the object at address $\V{L}'$. It says that
% that field contains the value $\nil$. The formula
% $(\V{L}',\js{z})\pointsto\none$ is slightly different in that $\none$ is not a
% JavaScript value. This formula says that the field $\js{z}$ of the object
% $\V{L}'$ \emph{does not exist}. Since our logic deals with \emph{partial} heaps
% we can never infer non-existence from the absense of any evidence of existence.
% Instead we are explicit about which cells we know to exist \emph{and} which
% cells we know do not exist.
% % Absence of evidence is not evidence of absence!
% The $\protop$ field of the object $\V{L}$
% is seperate from the $\js{z}$ field, so we can write $(\V{L}',\js{z})\pointsto\none \sep (\V{L}',\protop)\pointsto\nil$.
% 
% This premise captures the requirement that the body of the function will have to run in a state in which:
% \begin{itemize}
%         \item a new scope frame $\V{L}'$ has been created: ${\exists \V{L}'}$
%         \item \V{L}' has been prepended to the head of the scope list: ${\ls \doteq (\V{L}':\V{L})}$ 
%         \item this new scope frame will certainly not contain the variables $\js{x}$ and $\js{y}$:
%                 $(\V{L}',\V{x})\pointsto\none \sep (\V{L}',\V{y})\pointsto\none$
%         \item the new scope frame will contain the local variable \js{v}, initialised to \und: ${(\V{L}',\V{v})\pointsto\und}$
% \end{itemize}

Part of the challenge of understanding this example is knowing the scope of
local variable \js{v}. In JavaScript, variables can only be declared local
to functions, not  other blocks such as \js{if} and \js{while}. This can lead
to undesirable behaviour, especially when a local variable overloads the name of a global
variable. One controversial technique for solving this problem is to use the
\js{with} statement  and a literal object to declare local variable blocks
precisely where they are needed. Using  \js{with}  is often
considered bad practice, and it is deprecated in ECMAScript~5. However,  it is widely used in
practice~\cite{Richards2010,RyuFOOL2011}  and can certainly be used to improve the program 
readability. We are able to reason about even extremely confusing uses of \js{with}.
 Consider the program $\js{C}'$:

% A large part of the complexity of JavaScript's emulated variable store is due
% to the \js{with} construct. This allows the programmer to connect arbitrary
% objects to the scope-list, and hence leads to the full complexity of the JavaScript variable store such as the prototype list
% from address $l_2$ given in Figure. It is tempting to assert that the use of such a commandis bad practice, and it is indeed deprecated in the next version of
% ECMAScript, version 5. However, this feature is widely used~\cite{Richards2010}, and in fact can considerably improve the readability of a
% program. For example, consider the following program which builds a set of
% closures:
% \begin{verbatim}
% while (i-- > 0) {
%    var x = i;
%    a.push(function(){ [use local variable x] });
%    [do something to x]
% }
% \end{verbatim}
% Since loop statements do not introduce separate scopes in JavaScript, this code
% will not have the expected behaviour. All the functions stored in \js a will
% share a single instance of the variable \js x.
% 
% The \js{with} construct can be used to force the desired scoping behaviour in
% the loop body:
% %
% \begin{verbatim}
% while (i-- > 0) {
%    with({x:i}){
%      a.push(function(){ [use local variable x] });
%      [do something to x]
%    }
% }
% \end{verbatim}

\begin{verbatim}
a = {b:1}; with (a){f=function(c){return b}};
a = {b:2}; f(null)
\end{verbatim}

Armed with an operational understanding of JavaScript's emulated variable
store, it is not so difficult to understand that this program returns the value
1, even though the value of \js{a.b} at the end of the program is 2. It may not
be quite so clear that this  program can fault. It
may also  execute arbitrary code from elsewhere in the emulated variable store, leading to a possible security violation. 

We only understood this example properly by doing the verification.  In Section~\ref{sec:examples:with}, we prove the triple:
\[\begin{array}{c}
        \{ \store_{\ls}(\js{a},\js{f}|) \sepish(\lop,\js{f})\pointsto\none\sepish(\lop,\protop)\pointsto\nil\}\\
        \js{C}'\\
        \{\rv\doteq 1 \sep \true\}
\end{array}\]
A similar proof is possible for a precondition where \js{a} and
\js{f} are in the store with  arbitrary values. Either
precondition ensures the program returns the value 1 as expected. The
obvious first try was to have e.g. just $\store_{\ls}(\js{a},\js{f}|)$ as
the precondition. This does not work as, when reasoning about the
assignment to the variable \js{f}, we cannot assert that the variable
\js{f} is not in the local scope. As discussed
earlier, 
%we cannot make assumptions about the shape of the 
we work with incomplete prototype
chains in the emulated variable store.  With some web code, it is
possible for programmers to directly access and change the prototype pointers, resulting in
the distinguished object $\lop$
not being a part of the emulated variable store. This means that  $\lop$ may contain the field \js{f} without violating our
proposed precondition. The statement \js{a = \{b:1\}} then results in
the creation of a new object $\V{L}$, with no field \js{f} as
expected, but with field $\protop$ pointing to $\lop$ which may contain $f$:

\[\exists\V{L}\st (\V{L},\js{b})\pointsto 1 \sep (\V{L},\js{f})\pointsto\none \sep (\V{L},\protop)\pointsto \lop\]

The \js{with} statement makes this new object $\V{L}$ the most local
cell in our emulated variable store. But because \js{f} is an
inherited property of $\V{L}$, the meaning of the assignment to \js{f}
has now changed -- it has become an overriding assignment of a local
variable. We write the new function \js{f} into the most local object
$\V{L}$. When the program returns from the \js{with} statement, the
function call to \js{f(null)} will fault, since there is no \js{f} in
scope to call. In many web browsers (including Chrome, Firefox, and
Safari), this behaviour can be induced by running the program
$\js{Object.prototype.f = 4 ; window.\_\_proto\_\_ = null ; C}'$ in
the default starting state\footnote{In web browsers,
  \js{Object.prototype} usually contains a pointer to the object
  $\lop$ and \js{window} usually contains a pointer to the object
  $\lgo$.}. The $\js{\_\_proto\_\_}$ notation allows the programmer to
directly access and change the internal $\protop$ fields, resulting in
a program state which causes the program $\js{C}'$ to fault.
Non-standard features such as this are widely used in practice, and so
it is important that our reasoning be robust to the states they
produce. In this example, it is possible to induce a similarly tricky
starting state without the use of any non-standard features, which
results in the call to \js{f()} executing arbitrary code not mentioned
in our program. Consider running the program $\js{Object.prototype.f =
  function(c) \{}\js{C}''\js{\};C}'$ where $\js{C}''$ is suspicious
code. This could result in a security breach if \js{f} is passed
sensitive data.


\section{Operational Semantics}\label{sec:JLB}



% Intro
%
%We define a big-step operational semantics for JavaScript that represents faithfully the inheritance, prototyping and scoping mechanisms of the language, as described in ECMAScript, version 3. 
%
%Any semantic derivation for this subset is also a valid JavaScript computation.
%
%See Section~\ref{sec:differences} for a discussion of omissions and discrepancies from actual JavaScript.




We define a big-step operational semantics for a large subset of
JavaScript that represents faithfully the inheritance, prototyping and
scoping mechanisms described in the ECMAScript~3 standard. Our
semantics follows closely  the full small-step JavaScript semantics of
Maffeis, Mitchell and Taly~\cite{MMT-APLAS-TR08}, except that we  make some
simplifications as discussed in Section~\ref{sec:differences}. We work with a big-step semantics because it connects better to our reasoning. 


%, but in
%general the derivations of our semantics correspond to valid
%JavaScript computations.





\subsection{Heaps}\label{sec:syntax2}


% The heap
%
The JavaScript heap is a partial function $H \ty \loc \times \vars \rightharpoonup \vals$ that maps memory locations  and field names to values.  
%
The set of locations \loc\ is lifted to a set \locb\ containing the special location \nil, analogous to a null-pointer in C, which cannot be in the domain of any %well-formed 
heap.
%
{\em References} $r \in \refs= \locb \times \vars$ are analogous to memory addresses, and play an important role in the internal workings of the language.
%took out variable names as you immediately talk about variables
%
Values $v\in\vals$ can be basic values $\js{v}$, locations $l$, lambda abstractions $\lambda\js{x.e}$ or scope chains $L$. 
%
We denote the empty heap by \emp, a heap cell by $(l,x)\pointsto v$, the union of two disjoint heaps % with disjoint domains 
by $H_1\sep H_2$, and a read operation by $H(l,x)$. 



% Objects
%
An object is represented by a set of heap cells addressed by the same location but with different field names.
%
% In this context, field names stand for object property names.
%
For ease of notation,  we use $l\pointsto\{x_1\ty v_1,\ldots, x_n\ty v_n\}$ as a shorthand for the object $(l,x_1)\pointsto v_1\sep\ldots \sep (l,x_n)\pointsto v_n$.



% Scope chain
%
As discussed, JavaScript has no variable store. 
Instead, variables are resolved with respect to a scope object implicitly known at run time.
Scope objects are just objects whose locations are recorded in a \emph{scope chain} $L\in \loc^n$ (we use a standard notation
$\emptylist,e\cons L,L\append L$ for lists). 
% 
%We denote the empty list by ${\emptylist}$, the list with term $t$ as the head and tail $L$ by $t\cons L$, and the list with elements $t_1,\ldots t_n$ by $[t_1,\ldots t_n]$. 
%
\remark{SM: we may find out later that we need a marker such as \scopep\ to recognise a potential scope object.}
%
Each scope object has a pointer to a {\em prototype chain}. 
A variable $x$ is resolved as the property named ``$x$" of the first object in the scope chain 
whose prototype list defines ``$x$".
%
Scoping constructs, such as function calls and $\js{with}$, 
cause sub-expressions to be evaluated with respect to a local scope object, by  putting the local scope object  at the beginning of the scope chain and then removing it after the sub-expressions have been evaluated. 
% which for example defines the local variables of a function
 %to defer back to the original scope chain once the sub-expressions have been evaluated. 
 %to its enclosing scope, where the resolution of non-local variables continues.
%
All user programs are evaluated starting from the default scope chain
$[\lgo,\lgs]$, where $\lgo$ is the location of the global JavaScript
object (described below) and $\lgs$ is a dummy scope object always at the end of the scope chain, whose 
role is to hold a $\thisp$ pointer to $\lgo$. This is equivalent to considering every top level JavaScript execution like calling a method of the global object, where $\lgs$ is the corresponding activation record. 
During execution $\lgo$ always appears in the scope chain, but its position may vary.
For example, the JavaScript program $\js{with(window)\{C\}}$ results in
the subprogram $\js{C}$ being evaluated in a state in which $\lgo$ is the most local object.


%
The auxiliary scope  function \scope,  defined below, returns the location of the first object in
the scope chain to define a given variable. It depends on the prototype function $\proto$, which 
returns the location of the first object in
the prototype chain to define the variable.


%
\begin{display}{Scope and prototype resolution: $\scope(H,l,x)$ and $\proto(H,l,x)$.}
\jaxiom{\scope(H,{\emptylist},\njs{x})}{\nil}{}\\[\gap]
\jrule{\scope(H,l\cons L,\njs{x})}{l}{\proto(H,l,\njs{x}) \neq \nil}\rsep
\jrule{\scope(H,l\cons L,\njs{x})}{\scope(H,L,\njs{x})}{\proto(H,l,\njs{x}) = \nil}\\
\\
\jaxiom{\proto(H,\nil,\njs{x})}{\nil}{}\\[\gap]
\jrule{\proto(H,l,\njs{x})}{l}{(l,\njs{x}) \in\domain(H)}\rsep
\jrule{\proto(H,l,\njs{x})}{\proto(H,l',\njs{x})}{(l,\njs{x}) \not\in\domain(H) \qquad H(l,\protop) = l'}
\end{display}



% Prototype chain
%

%\begin{display}{Prototype resolution:$\proto(H,l,x)$.}
%\jaxiom{\proto(H,\nil,\njs{x})}{\nil}{}\\[\gap]
%\jrule{\proto(H,l,\njs{x})}{l}{(l,\njs{x}) \in\domain(H)}\rsep
%\jrule{\proto(H,l,\njs{x})}{\proto(H,l',\njs{x})}{(l,\njs{x}) \not\in\domain(H) \qquad H(l,\protop) = l'}
%\end{display}
%

% Variables and references
%
The set of variable names $\vars$ is partitioned in two disjoint sets: the  {\em internal} variable names $\ivars$ and the {\em user } variable names $\uvars$.
%
The internal names $\ivars\triangleq
\{\fscopep,\bodyp,\protop,\thisp\}$ are not directly accessible by
user-defined ECMAScript~3 code, but are used by the semantics. As
noted in Section~\ref{sec:simplereasoningcomplexlanguage}, some
implementations do give programmers direct access to some of these
internal variables, but we do not  model those implementation-dependant programs. We do model 
all the program states that such  programs might create, and take
care not to make strong assumptions about the types or values of those
suspect internal variables. In this way, libraries verified using our
techniques are robust in the presence of unverified real-world code.
%
User names are denoted by $\js{x},\js{y},\js{z}\in\uvars$ and are considered a subset of strings;
keywords such as \js{var} are not valid variable names.
%
\remark{SM: we could go more into detail here. Note also that there is a difference between what is allowed in \js{var x} vs. \js{e["x"]}.}
%
It is worth anticipating at this point a subtlety of the JavaScript semantics.
%
The evaluation of a user variable \js{x} does not return its value, but rather the reference $l'\sv\js{x}$ where such value can be found ($l'$ is obtained using the \scope\ predicate).
%
In general, the values $r\in\valsr$ returned by JavaScript expressions can be normal values \vals\ or references \refs.
%
When a user variable \js{x} needs to be dereferenced in an expression, the semantics implicitly calls the dereferencing  function \getValue,  defined below, which returns the value denoted by the reference.

\newpage

%
%\begin{display}{Dereferencing values: $\getValue(H,r)$.}
%\jrule{\getValue(H,\njs{r})}{\njs{r}}{\njs{r}\neq l\sv \js{x}}\rsep
%\jrule{\getValue(H,l\sv\js{x})}{\und}{\proto(H,l,\js{x}) = \nil\\ l\neq \nil}\rsep\\\\
%\jrule{\getValue(H,l\sv\js{x})}{H(l',\js{x})}{\proto(H,l,\js{x}) = l'\\ l\neq \nil}
%\end{display}
%
\begin{display}{Dereferencing values: $\getValue(H,r)$.}
\jrule{\getValue(H,\njs{r})}{\njs{r}}{\njs{r}\neq l\sv \js{x}}~
\jrule{\getValue(H,l\sv\js{x})}{\und}{\proto(H,l,\js{x}) = \nil\\ l\neq \nil}~
\jrule{\getValue(H,l\sv\js{x})}{H(l',\js{x})}{\proto(H,l,\js{x}) = l'\\ l'\neq \nil}
\end{display}



% Well-formedness
%
%A JavaScript expression can only be evaluated in a well-formed heap, with respect to a valid scope chain.
%
We now introduce the definition of a well-formed JavaScript heap. A JavaScript
expression can only be evaluated in a sub-heap of a well-formed heap,
with respect to a valid scope chain. The evaluation of any JavaScript term 
maintains heap well-formedness.
%
A heap $H$ is \emph{well-formed} (denoted by $H\isok$) if its objects
and prototype chains are well-formed, and if it contains the global object $\lgo$, the global scope $\lgs$, the
distinguished objects $\lop$ and $\lfp$, which we will see
later serve as the default prototypes for new objects and functions, and finally the \js{eval} function object $\lge$.
%
A prototype chains is well-formed if it is acyclic and ends with $\js{null}$ on $\lop$.
%
A scope chain $L$ is \emph{valid} with respect to heap $H$, denoted by
$\schain(H,L)$,  if all the locations in the chain correspond to
objects allocated in $H$, if it contains the global object $\lgo$, and if it ends with the global scope $\lgs$.
%
Formal definitions are given in~\ifshort{\cite{proofs}.}\iflong{Appendix~\ref{sec:tables:jlb}.}
  
% Initial state.
%
%The default initial state 
$\Hinit$ is the smallest well-formed heap:
%
\[
\Hinit ~~\triangleq~~ \left(
\begin{array}{c} 
  \obj(\lgo,\lop) \sep\ \obj(\lop,\nil) \sep \obj(\lfp,\lop)\\[1mm]
  {}\sep\ \obj(\lge,\lfp)
  \sep \lgs\pointsto\{\protop\ty\nil,\thisp\ty\lgo\}
\end{array}\right)
\]
%
where $\obj(l,l')$ denotes an object at location $l$ which is empty except for the  prototype $l'$:
\[\obj(l,l')\ \triangleq\ (l,\protop)\mapsto l'.\]
%
The scope chain which would accompany this initial heap is:
%
\[
\Linit ~~\triangleq~~ [\lgo,\lgs]
\]

%
%\[\begin{array}{rll}
%          \Hinit \triangleq & 
%                   \phantom{\sep\ }\lgo&\pointsto\{ \protop:\lop,\thisp:\lgo\}\\
% &                 \sep\ \lop&\pointsto\{\protop:\nil\}\\
% &                 \sep\ \lfp&\pointsto\{\protop:\lop\}\\
% &                 \sep\ \lge&\pointsto\{\protop:\lep\}\\
% &                 \sep\ \lep&\pointsto\{\protop:\lop\}
%          \end{array}\]
  






% Heap update and deallocation
%
We conclude this section by defining the heap update $-\semup{-}$
operation which will be used by the semantics. Many JavaScript
expressions update a heap cell if it is present, or create it if it is
not present. We reflect this form of update in our heap update operation. 

%
\begin{display}{Update $H \semup{ (l,\js x)\pointsto\njs{v}}$.}
%
\jrule{H \semup{ (l,\js x)\pointsto\njs{v}}}{H\sep(l,x)\pointsto\njs{v}}{(l,\js x)\not\in dom(H)\qquad l\neq\nil}
\\[\gap]
%
\jaxiom{(H\sep(l,\js x)\pointsto\njs{v}) \semup{ (l,\js x)\pointsto\njs{v'}}}{H\sep(l,\js x)\pointsto\njs{v'}}{}
\\[\gap]
%
\jaxiom{H\semup{(\nil,\js{x})\pointsto \njs{v}}}{H\semup{(\lgo,\js{x})\pointsto \njs{v}}}{}
%
%
\end{display}
%
\remark{SM: in a long version, explain that \js{prototype} has ReadOnly attribute (at the moment our semantics of Delete is out of sync).}
%
The last rule says that an update to a non-allocated
reference (whose location is \nil) has the effect of allocating and
updating a new global variable,  which mimics  JavaScript's behaviour of
implicitly creating global variables when a variable name is first
used.





\subsection{Values and Expressions}\label{sec:terms}

The syntax of JavaScript programs is divided into statements (\js{stmt}) and
small-expressions (\js{exp}) as in~\cite{MMT-APLAS-TR08}. Since there
is so much cross-over between these categories, we find it convenient
to express our operational semantic rules using a catch-all category
of expressions \js{e}.

%% To aid  our presentation, we introduce the syntax of   all JavaScript 
%% programs, statements and expressions 
%% simply as expressions. Our operational semantics 
%% will only describe the behaviour of well-formed programs, 
%% as
%% defined by~\cite{MMT-APLAS-TR08}.

%, we do not go into the full detail of
%parsing JavaScript programs, statements and expressions in this paper.
%Instead, for the simplicity of this presentation, 
%
% Values
%
% The syntax for terms of our JavaScript subset is reported below.%shown in Figure~\ref{defn:data}. 
%
\begin{display}{Syntax of terms: values \js v and terms \js e.}
\clause{\mbox{$\begin{array}{lcl}
%  H & \defeq & H\sep (l,\js{x})\pointsto\js{v} \pipe \emp\\
\js{v} & \defeq & \js{n} \pipe \js{m} \pipe \und \pipe \nil\\  
\js{e} & \defeq &  \js{stmt} \pipe \js{exp} \\
\js{stmt} & \defeq & \js{stmt} ; \js{stmt} \pipe
          \js{if(exp)\{stmt\}\{stmt\}} \pipe \js{while(exp)\{stmt\}} \pipe
          \js{var}\ \js{x} \\
          && \pipe \js{var}\ \js{x = exp} \pipe \js{with(exp)\{stmt\}}\pipe\js{exp}\\
\js{exp} & \defeq &  \js{x} \pipe \js{v} \pipe \this\pipe \js{delete exp}
         \pipe \js{exp} \oplus \js{exp} \pipe \js{exp.x} \pipe \js{exp(exp)} \\
         &&\pipe \js{exp = exp} \pipe \jsfun{x}{stmt} \pipe
         \jsfun[x]{x}{stmt}\\
         && \pipe \js{new exp(exp)} 
         \pipe \{ \js{x}_1:\js{exp}_1 \dots \js{x}_n:\js{exp}_n \}
\pipe \js{exp[exp]} \\
\end{array}$}{}}\\
where $\oplus \in \{ +, -, *, /,{\&\&},{||},{==}, . \}$
\end{display}
%
\remark{SM: most general syntax for \js{new} would be \js{new e}.}
%
A basic value \js{v} can be a number \js{n}, a string \js{m} (including the user variable names), 
%the special constant \js{undefined} (denoted here by \und) 
the special constant \und\
or the \nil location.
%
% Expressions
%
The operator $\oplus$ denotes a standard binary operators on numbers, booleans or strings. 
%
Terms $\js{e}$ may be either statements $\js{stmt}$ or
expressions $\js{exp}$. Statements include sequential composition,
 conditionals, loops, local variable declaration, the
 \js{with} statement, and any expression.
Expressions include variable lookup, literal values, \js{this}, deletion, 
arithmetic and string concatenation, object property lookup, function call, assignment, 
function declaration, recursive functions, constructors, literal objects and computed object access.
%
%\begin{figure}
%\hrule
%\[
%\begin{array}{lcl}
%%  H & \defeq & H\sep (l,\js{x})\pointsto\js{v} \pipe \emp\\
%  \js{v} & \defeq & \js{n} \pipe \js{m} \pipe \und \pipe l \pipe l\sv\js{x} \pipe \lambda_l\js{x.e} \\
%  \js{e} & \defeq & \js{e} ; \js{e} \pipe \js{x} \pipe \js{v} \pipe \js{if(e)\{e\}\{e\}} \pipe \js{while(e)\{e\}} \pipe \js{var}\ \js{x} \pipe \this\pipe \js{delete e}\\
%  && \pipe \js{e} \oplus \js{e} \pipe \js{e.x} \pipe \js{e(e)} \pipe \js{e = e} \pipe \{ \js{x}_1:\js{e}_1 \dots \js{x}_n:\js{e}_n \} \pipe \jsfun{x}{e}\\
%  && \pipe \jsfun[a]{x}{e} 
%\end{array}
%\]
%\hrule
%\caption{JLB Syntax}
%\label{defn:data}
%\end{figure}


















\subsection{Evaluation Rules}\label{sec:semantics}

% Evaluation
%
A statement \js{e} is evaluated in a heap $H$, with respect to a scope chain $L$. If it successfully terminates, it returns a modified heap $H'$ and a final value $\njs{r}$.
%
%......repetition...........Our big-step operational semantics for expressions uses an evaluation relation $\levalsto$, defined on {\em configuration triples} $H,L,\js{e}$, and {\em terminal states}  $H',\njs{r}$ or $\fault$.
% We don't just return good terminating states, but also bad ones - ``faults''. Divergent programs are the well formed programs that don't return either a state or a fault. I believe this is standard for big-step semantics. Remember that we have an ``otherwise'' case, so our rules say /something/ about all well formed programs.
%
Selected evaluation rules are given below and then discussed. See~\ifshort{\cite{proofs}}\iflong{Appendix~\ref{sec:tables:jlb}} for the full definition.
%
Recall that the set of variables is a subset of the set of strings,
that a heap value $v$ can be a basic  value \js{v}, a memory location
$l$ or a function closure $\lambda\js{x.e}$, and that a return value $r$ can also be a reference $l\sv\js{x}$.
%
\remark{SM: considerations on (Computed Access): it duplicates the work of (Member Access) but that's in line with the natural semantics philosophy. If we used the latter rule in the premise of the former, we would need to change the syntax to include $r.x$ which is undesirable. A similar argument applies to (New).}
%
\begin{display}{Operational semantics: $H,L,\js e\levalsto H',r$.}
%
Notation: $H,L,\js{e} \gevalsto H',v \triangleq \exists r. (H,L,\js{e} \levalsto H',r \wedge \getValue(H',r) = v)$.\\[\gap]



%
% EXPRESSIONS
%

\staterule{(Definition)}
{H,L,\js{e}\levalsto H',v}
{H,L,\js{var e} \levalsto H',\und}
\rsep  
%
\stateaxiom{(Value)}
{H,L,\js{v} \levalsto H,\js{v} }
\\[\gap]


\staterule{(Member Access)}
{H,L,\js{e} \gevalsto H',l \\
 l\neq \nil}
{H,L,\js{e.x} \levalsto H',l\sv\js{x}}
\rsep
%
\staterule{(Computed Access)}
{H,L,\js{e1} \gevalsto H_1,l \\
 l\neq \nil\\
 H_1,L,\js{e2} \gevalsto H',\js x}
{H,L,\js{e1[e2]} \levalsto H',l\sv \js x}
\\[\gap]


\staterule{(Variable )}
{\scope(H,L,\js{x})=l }
{H,L,\js{x} \levalsto H,l\sv\js{x}}
\rsep
%
\staterule{(Object)}
{H_0 = H \sep \obj(l,\lop)\\
 \forall i\in 1..n.\left(\begin{array}{l}
  H_{i-1},L,\js{ei}\gevalsto H_i',\njs{v_i} \\ 
  H_i = H_i' \semup{ (l,\js{xi}) \pointsto \njs{v_i}}\end{array}\right)}
{H,L,\{\js{x1:e1},\dots, \js{xn:en}\} \levalsto H_n,l}
\\[\gap]  


\staterule{(Binary Operators)}
{H,L,\js{e1} \gevalsto H'',\js{v1}\\
 H'',L,\js{e2} \gevalsto H',\js{v2}\\
 \js{v1}\primop\js{v2}=\js{v}}
{H,L, \js{e1} \oplus \js{e2} \levalsto H',\js{v}}
\rsep
%
\staterule{(Assignment)}
{H,L,\js{e1} \levalsto H_1,l\sv\js{x}\\
 H_1,L,\js{e2} \gevalsto H_2,\njs{v}\\
 H'=H_2\semup{(l,\js{x})\pointsto\njs{v}}}
{H,L,\js{e1=e2} \levalsto H',\njs{v}}
\\[\gap]



\staterule{(This)}
{\scope(H,L,\thisp)=l_1 \\ \proto(H,l_1,\thisp)=l_2\\ H(l_2,\thisp)=l'}
{H,L,\js{this} \levalsto H,l'}
~
%
\staterule{(Function)}
{H' = H \sep \obj(l,\lop) \sep \func(l',L,\js x,\js e,l)}
{H,L,\jsfun{x}{e} \levalsto H',l'}
\\[\gap]


\staterule{(Function Call)}
{H,L,\js{e1} \levalsto H_1,r_1\qquad
 \pickThis(H_1,\njs{r_1})=l_2\qquad
 \getValue(H_1,r_1)=l_1\\
 l_1\neq\lge\qquad H_1(l_1,\bodyp)=\lambda \js{x.e3}\qquad
 H_1(l_1,\fscopep)= L'\\
 H_1,L,\js{e2} \gevalsto H_2,\njs{v}\\
 H_3 = H_2\sep\activ(l,\js x,v,\js{e3},l_2)\qquad
 H_3,l\cons L',\js{e3} \gevalsto H',\njs{v'}}
{H,L,\js{e1(e2)} \levalsto H',\njs{v'}}
\\[\gap]


\staterule{(Eval)}
{H,L,\js{e1} \gevalsto H_1,\lge\qquad 
 H_1,L,\js{e2} \gevalsto H_2,\js{m}\\ 
 \parse(\js m)=\js{e}\qquad
 H_2,L,\js {e}\gevalsto H',v'}
{H,L,\js{e1(e2)} \levalsto H',\njs{v'}}
\\[\gap]


%\staterule{(Function Call)}
%{H,L,\js{e1} \levalsto H_1,r_1\\ 
% \pickThis(H_1,\njs{r_1})=l_2\\
% \getValue(H_1,r_1)=l_1\\
% l_1\neq\lge\\
% H_1(l_1,\bodyp)=\lambda \js{x.e3}\\
% H_1(l_1,\fscopep)= L'\\
% H_1,L,\js{e2} \gevalsto H_2,\njs{v}\\
% H_3 = H_2\sep\activ(l,\js x,v,\js{e3},l_2)\\
% H_3,l\cons L',\js{e3} \gevalsto H',\njs{v'}}
%{H,L,\js{e1(e2)} \levalsto H',\njs{v'}}
%\rsep
%%
%\staterule{(Eval)}
%{H,L,\js{e1} \gevalsto H_1,\lge\\ 
% H_1,L,\js{e2} \gevalsto H_2,\js{s}\\ 
% \parse(\js s)=\js{e}\\
% H_2,L,\js {e}\gevalsto H',v'}
%{H,L,\js{e1(e2)} \levalsto H',\njs{v'}}
%\\[\gap]
%
%
%\staterule{(New)}
%{H,L,\js{e1} \gevalsto H_1,\njs{l_1} \\
% l_1\neq \nil\\
% H_1(l_1,\bodyp)=\lambda \js{x.e3}\\
% H_1(l_1,\fscopep)= L'\\    
% H_1(l_1,\js{prototype})= v\\ 
% l_2 = \objOrGlob(v) \\  
% H_1,L,\js{e2} \gevalsto H_2,\njs{v_1} \\
% H_3 = H_2\sep \obj(l_3,l_2) \sep\activ(l,\js x,v_1,\js{e3},l_3)\\ 
% H_3,l\cons L',\js{e3} \gevalsto H',v_2\\  
% \getBase(l_3,v_2) = l'}
%{H,L,\js{new e1(e2)} \levalsto H',\njs{l'}}
%\\[\gap]




%
% STATEMENTS
%

\staterule{(With)}
{H,L,\js{e1} \gevalsto H_1,l\\
l\neq\nil\\
 H_1,l\cons L,\js{e2} \levalsto H', \njs{r}}
{H,L,\js{with(e1)\{e2\}} \levalsto H',r}
\rsep
$\begin{array}{l}\scope, \proto, \getValue, \obj \text{ defined earlier}\\
    \func, \this, \activ \text{ defined below}\end{array}$
\end{display}
%
\remark{SM: Note about (Eval): if \js{s} is not a string, it should be returned straight away. For now, we do only the interesting case.}

% \[\fresh(l,H)\triangleq (l,\protop)\notin\domain(H)\]
%
\remark{SM: we don't need the $\fresh(l,H)$ condition in fact because of $H_1*H_2$. Note that we should have the lemma that any $l$ that makes sense must always be in the domain of the corresponding heap $H$ (note the tricky case for named function that has cross-pointers)}









% Rules description
%
We briefly discuss some of the evaluation rules that show non-standard features typical of JavaScript.
%spredic
Rule (Definition) for \js{var e} simply executes \js{e} and throws
away the return value. The \js{var} declaration is only used by \defs (defined below) to identify function local variables.
% 
Rule (Variable) uses $\scope$ to determine the scope object where a given variable can be found, without de-referencing the variable.
%
Rules (Member/Computed Access) return a reference to the object field denoted by the corresponding expressions.
%
Rule (Object) uses the $\obj$ notation introduced in
Section~\ref{sec:syntax2} to introduce a fresh, empty object at location $l$, and then initialises its fields accordingly.
%
Freshness is ensured by well-formedness of $H$ and disjointness of $\sep$.
%
Rule (Binary Operators) assumes the existence of a semantic version $\primop$ for each syntactic operator $\oplus$.  
%
Each $\primop$ is a partial function, defined only on arguments of a basic type (in this case numbers or strings) and returning results of some other (possibly the same) basic type, corresponding to the intended meaning of the operation. \remark{SM: in particular, i don't want them to return pointers or references as it may bite us later}
%
Rule (Assignment) is quite subtle.
%
Suppose we have the expression \js{x=4}.
%
Now consider Figure~\ref{fig:variableStore} of Section~2. If \js{x} were defined as
a field of the object $l_1$ then \js{x=4} would be an
\emph{overwriting} assignment. The value of the field \js{x} in the
object $l_1$ would be overwritten with the value \js{4}.
%
If \js{x} were not found anywhere, then it would be created as a global
variable -- a field of the object $\lgo$.
%
Finally, consider the actual case in this figure: \js{x} is found to
be a field of object $l$, which is a prototype of $l_2$, which is in the scope chain.
%
In this case, \js{x=4} is an \emph{overriding} assignment, with the
effect of creating a new field \js{x} in the object $l_2$ to override
the existing \js{x} in $l$.
%
This complexity is handled in two places. Firstly, the variable rule uses the
$\scope$ function  (defined in Section~\ref{sec:syntax2}) to return a
reference $l_2\sv\js{x}$. Note that the $\scope$ function  does not
return a reference to $l\sv\js{x}$ precisely because we wish to model
this behaviour. Secondly, the heap update operation $H_2[...]$ manages
the business of either overwriting an existing field or,  in this case,
creating a new field.
%
Rule (This) resolves the \js{this} identifier. As we will see, when
executing a method of an object, we use the internal variable $\thisp$
to store the location of that object. When executing a function call,
$\thisp$ points to the global object $\lgo$. The (This) rule uses
$\scope$ and $\proto$ to retrieve the value of $\thisp$ which is then
returned by the \js{this} statement.
%
% In a well-formed state, it will always be the case that the rule returns a valid (non-\nil) object.
%
Rule (Function) introduces the notation $\func(l',L,\js x,\js e,l)\triangleq$
\[ l'\mapsto\{\protop\ty\lfp,\js{prototype}\ty l,\fscopep\ty L,\bodyp\ty\lambda \js{x.e}\}\]
to allocate a fresh function object at location $l'$. The internal
prototype of the new function object points to the standard function
prototype object $\lfp$. The rule also creates a new empty object at
$l$ and stores a pointer to it in the \js{prototype} field of the new
function. If the function is ever used as a constructor (using the
\js{new} keyword) then the object pointed to by this \js{prototype}
field will serve as the prototype of the newly constructed object.
Note that the field is mutable, and so may be used by a programmer to
emulate a class-like inheritance structure.

Recall from Section~\ref{sec:simplereasoningcomplexlanguage} that
JavaScript function calls can be surprisingly complex. We now describe
rule (Function Call), which uses two auxiliary functions $\pickThis$
and $\activ$.
%
Recall also that the semantics rule (This) uses the internal $\thisp$ field to
resolve the \js{this} keyword. 
%
%To understand $\pickThis$, first notice that every newly created local
%scope object has a $\thisp$ field, while no other
%objects ever will\footnote{$l_g$ has $\thisp$  in some,  not all,
%  implementations; \cite{ecma262} is silent on the issue.}.
The (Function Call) rule finds a pointer to a function in the location
$l\sv\js{x}$. If $l$ is a regular object (which has no $\thisp$
field), then the function must be a method of that object, and so the
$\thisp$ field of our new local scope object should point to $l$. On
the other hand, if $l$ is a special local scope object (which has a
$\thisp$ field), then the function must be a regular function (and not
a method), and so the $\thisp$ of our new local scope object should
point to $\lgo$. 
%
The process described above is embedded in the (Function Call) rule by the
auxiliary function $\pickThis$:
%
\[\begin{array}{rlll}
        \pickThis(H,l\sv \js{x})&\triangleq &l &[(l,\thisp)\not\in dom(H)]\\
        \pickThis(H,\njs{r})&\triangleq& \lgo &[\text{otherwise}]
\end{array}\]
%
This rule precisely captures the behaviour of the ECMAScript~3 \js{this} keyword.
%The rationale is that in the expression \js{o.f(null)}, the \this\ of \js{f} will be \js{o}, whereas in the expression \js{f(null)} the \this\ of \js{f} will be the global object.
%
The auxiliary function $\activ$ describes the allocation of a new
local scope object:
$\activ(l,\js{x},\njs{v},\js{e},l'') \triangleq$
%
\[l\pointsto\{\js{x}\ty \njs{v},\thisp\ty l'',\protop\ty \nil\}\sep \defs(\js{x},l,\js{e})\]
%
The object is allocated at address $l$, and contains a function parameter
\js{x} with value $v$, the internal fields $\thisp,\protop$ and the
local variables declared in an expression \js{e}.
%
The auxiliary function \defs, defined in~\ifshort{\cite{proofs}}\iflong{Appendix~\ref{sec:tables:jlb}},
searches the function body $\js{e}$ for instances of 
the \js{var} keyword, 
and
sets all the appropriate fields of our new local scope object to the
value \und, as discussed in Section~\ref{sec:simplereasoningcomplexlanguage}.
%% returns the fresh memory needed to allocate the local variables defined by a function body.
%% %
%% % In particular, 
%% $\defs(\js y,l,\js{var}\ \js{x})$, where $\js y$ is the formal parameter of the function being defined, returns the cell $(l,\js x) \pointsto \und$ if $\js x\neq \js y$. 
%% %
%% All other rules for \defs propagate this information homomorphically.
%
Rule (Eval) looks like an ordinary function call, but the function
being called is not  an ordinary function object. It is the special
built-in object $\lge$. It assumes a partial function $\parse$ that
parses a string \js m into a JavaScript expression \js e, only if
there are no syntax errors.% in \js m.
%

Control statements are mostly standard (see~\ifshort{\cite{proofs}}\iflong{Appendix~\ref{sec:tables:jlb}}),
except for the unusual (With) rule that evaluates \js {e2} in a
scope-chain temporarily augmented with the object obtained by evaluating \js {e1}.
% 


\subsection{Safety}

An important sanity property of the evaluation relation is that it preserves well-formedness of the heap, for any valid scope chain.
%
\begin{thm}[Well-Formedness]\label{thoerem:anotherwfheap1}
Let $H,L$ be such that $H\isok$ and $\schain(H,L)$. 
If $H,L,\js{e}\levalsto H',\njs r$ then $H'\isok$. 
\end{thm}
%
Although the theorem is about end-to-end well-formedness, its proof (reported in~\ifshort{\cite{proofs}}\iflong{Appendix~\ref{sec:proofs:JLB}}) shows that starting from a well-formed state and scope chain, all the intermediate states and scope chains visited during the computation are also well-formed, and all the locations occurring in intermediate return values correspond to objects effectively allocated on the heap.
%
\remark{SM: this whole paragraph is not needed by the logics but i think it's useful to have for the semantics.}  
  














%% \subsection{Scope Example}
%% \label{sec:JLB:example}

%% We now revisit the scope example to illustrate some actual evaluation steps of the semantics.
%% %
%% Let \js {e1} be the code:
%% %
%% \begin{verbatim}
%% x = null; y = null; z = null;
%% f = function(w){x=v; v=4; var v; y=v;};
%% v = 5; f(null); z = v;
%% \end{verbatim}
%% %
%% We evaluate the state $(\Hinit,[\lgo],\js{e})$ using rule (Sequence).
%% %
%% We first compute $(\Hinit,[\lgo],\js{x = }\nil) \levalsto H_1,\nil$, where $H_1=\Hinit\sep(\lgo,\js{x})\pointsto\nil$.
%% %
%% Then, if we find some $H,\njs{r}$ such that $H_1,[\lgo],\js{e2}\levalsto H,\njs{r}$  we can conclude that $\Hinit,[\lgo],\js{e1}\levalsto H,\njs{r}$, where $H$ and \njs{r} are the final heap and return value of the computation, and \js {e2} is the continuation of \js{e1}.
%% %
%% Applying similar reasoning to \js{e2} a few times, we can isolate the last two sub-derivations $H_5,[\lgo],\js{f(\nil)}\levalsto H_6,\njs{r_1}$ and  $H_6,[\lgo],\js{z = v}\levalsto H,\njs{v}$.
%% %
%% The first sub-derivation is the most interesting.
%% %
%% It must follow by rule (Function Call), where the last premise is the sub-derivation
%% %
%% \[H',[l_{\lambda},\lgo],(\js{x=v; v=4; var v; y=v;})\gevalsto H_6,\njs{v_1}\]
%% %
%% where $l_{\lambda}$ is the scope object for executing the function call.
%% %
%% It is easy to see that $H_5 = I\sep\lgo\pointsto\{G\}\sep l_{\js{f}}\pointsto\{F\}\sep\obj(l_{\js{f}p},\lop)$, where 
%% %
%% \[\begin{array}{ll}
%% 		I=\lop\pointsto\{\protop:\nil\}\sep\ \obj(\lfp,\lop)\sep\\ 
%% 		  \phantom{I=\,}\lge\pointsto\{\protop:\lep\}\sep\ \obj(\lep,\lop)\\[\gap]
%%         G=\protop\ty \lop,\thisp\ty\lgo,
%%           \js{x}\ty\nil,\js{y}\ty\nil, \js{z}\ty\nil,\js{f}\ty l_{\js{f}},\js{v}\ty 5\\[\gap]
%%         F=\protop\ty \lfp,\js{prototype}\ty l_{\js{f}p},\fscopep\ty [\lgo],\bodyp\ty \js{[...]}
%% \end{array}\]
%% %%
%% %\[\begin{array}{ll}
%% %		I=&\lop\pointsto\{\protop:\nil\}\sep\ \obj(\lfp)\sep\\ 
%% %		  &\lge\pointsto\{\protop:\lep\}\sep\ \obj(\lep)\\[\gap]
%% %        G=&\protop\ty \lop,\thisp\ty\lgo,\\
%% %          &\js{x}\ty\nil,\js{y}\ty\nil, \js{z}\ty\nil,\js{f}\ty l_{\js{f}},\js{v}\ty 5\\[\gap]
%% %        F=&\protop\ty \lfp,\js{prototype}\ty l_{\js{f}p},\fscopep\ty [\lgo],\\
%% %          &\bodyp\ty \lambda\js{w.[...]}
%% %\end{array}\]
%% %
%% Heap $H'=H_5\sep S$ is obtained by allocating the scope $S$ at $l_{\lambda}$:
%% %
%% \[S=l_{\lambda}\pointsto \{\js{w}:\nil,\thisp:\lgo,\protop:\nil,\js{v}:\und\}\]
%% %
%% Note that \js{v} has been added as an undefined local variable by \defs.
%% %
%% At this point we can easily deduce $H_6$ and $H$.
%% %
%% In particular, for some appropriate $H''$, 
%% \[H = H''\sep \lgo\pointsto\{\js{x}:\und,\js{y}:4,\js{z}:5,\js{v}:5\}\]





























\subsection{JavaScript Subset}\label{sec:differences}
%
% Intro
%
%In this Section, 
We work with a subset of JavaScript, in order to limit the size and complexity of our semantics for this paper.
Our subset is substantial and, despite some minor omissions and simplifying assumptions discussed below,  faithful to the ECMAScript 3 standard. 
A significant property of our semantics is that our programs will run reliably in states generated by any valid JavaScript program, including those reached by programs using non-standard features that we do not model, such as \js{\_\_proto\_\_},  or getters and setters.
Our reasoning of Section~\ref{sec:reasoning} will therefore interface well with real-world JavaScript programs.


We do not model implicit type-coercion functions. Adding them is
straightforward but would add significantly to the length of our
presentation.
%
We have no boolean type. 
Instead, where control statements (\js{if} and \js{while}) require a
boolean, we use other types whose behaviour is  equivalent to the type
conversion that occurs in JavaScript. Values such as $0$ and $\nil$
behave like $\js{false}$ and values such as $1$ and $\js{"string"}$
behave like $\js{true}$.
%
%In particular, our semantics agrees with the standard JavaScript semantics modulo the corner cases pointed out below, such as for example the lack of implicit type conversions. 
%
%
%
For simplicity, we use an implicit return statement for functions.
%
Moreover, our functions take only one parameter, rather than the arbitrary list of parameters usual in  JavaScript, and do not have the \js{arguments} object or the \js{constructor} property.
%
%
%As mentioned in Section~\ref{sec:terms}, we simplify our presentation
%of JavaScript programs, statements and expressions, into a single
%class of terms.
%
% This choice simplifies the formal machinery but  allows our model to have valid expressions that are not JavaScript terms (e.g., the sum of two \js{if} statements).
%
We also  omit several JavaScript constructs such as labels, \js{switch} and \js{for}, as they do not contribute significantly to the problem of program  reasoning. 

The ECMAScript standard~\cite{ecma262} specifies that the expression \js{this} evaluated in the global scope should resolve to the global object, but does not mandate where to store the corresponding $\thisp$ pointer, so different behaviours are possible depending on implementation choices.
%
In an earlier version of this paper, following~\cite{MMT-APLAS-TR08}, we opted for the conceptually simpler solution of storing a $\thisp$ pointer directly as an internal property of the global object $\lgo$.
% 
In this paper, we have used an alternative representation where a dummy scope object $\lgs$, always available at the end of the scope chain, holds the $\thisp$ pointer to $\lgo$. Object $\lgs$
is not mentioned anywhere in the semantics of the language and is
therefore not as ``special'' as $\lgo$, $\lop$, and $\lge$. 
Since this is merely a
choice of starting state, the program reasoning we give in
Section~\ref{sec:reasoning} is robust to both these, and many other
potential choices.

In this presentation we only consider the core language ECMAScript~3,
and do not model the many standard libraries which browsers make
available to programmers. 
%
%
Instead of exceptions, we have a single error condition denoted $\fault$.
%
Our reasoning conservatively avoids faults.
%
This means that programs which are proved using our fault-avoiding local Hoare reasoning will run without throwing exceptions in JavaScript interpreters. 


















\section{Assertion Language}\label{sec:assertionLanguage}
%
Our assertion language follows that of Parkinson and Bierman~\cite{Parkinson05,ParkinsonB08,Bierman03mj:an}, in their work on     reasoning about Java.
They use  assertions of the form $(\V{l}, \V{x}) \mapsto \V{v}$ to denote  that a partial heap contains the object $\V{l}$ with field $ \V{x}$ which has value $\V{v}$. Using the separating conjunction $\ast$~\cite{DBLP:conf/csl/OHearnRY01},  the assertion $((\V{l}, \V{x}) \mapsto \V{v} ) \ast ((\V{l}, \V{y}) \mapsto \V{w})$ declares  that a heap contains an object $\V{l}$ which must have two separate fields $\V{x}, \V{y}$ with the appropriate values. The assertion
$(\V{l}, \V{x}) \mapsto \V{v} \ast (\V{l}, \V{x}) \mapsto \V{w}$ is unsatisfiable since it declares two fields $\V{x}$ for $\V{l}$. 

This style of reasoning  is not enough for  JavaScript.
We must also assert negative information about fields not being in the heap,  and  extend 
the  structural assertions of separation logic to account for partial separation due to shared prototype chains. 
Recall the example of a JavaScript emulated variable store in Figure~\ref{fig:variableStore}. 
To find the value of $\V{x}$ in the store, we must not only determine that the object $l$ has a field  $\V{x}$ 
but also determine that no fields named $\V{x}$ occur earlier in the emulated store. 
We use  assertions 
$(\V{l}, \V{x}) \mapsto \none$ to declare  that a {heap}  contains an object $\V{l}$  which {\em does not} have a field $\V{x}$. 
The assertion  $(\V{l}, \V{x}) \mapsto \none \ast (\V{l}, \V{y}) \mapsto \V{w}$ declares  that the heap contains an object $\V{l}$  which { does not} have field $\V{x}$  but does have field $ \V{y}$. The assertions  $(\V{l}, \V{x}) \mapsto \V{v} \ast (\V{l}, \V{x}) \mapsto \none$ and
$(\V{l}, \V{x}) \mapsto \none \ast (\V{l}, \V{x}) \mapsto \none$ are unsatisfiable. Thus, the assertion $(\V{l}, \V{x}) \mapsto \none$
states the full knowledge that field $\V{x}$  is not in object $\V{l}$. 

Now consider what happens when we want to describe the state of more
than one variable at a time. In Section~\ref{sec:reasoning} we
introduce a predicate $\scope$ which allows us to assert, for example,
``The variable \js{x} is found in the store in object $l_2$'':
$\scope(\_,\ls,\js{x},l_2)$ or ``The variable \js{y} is not in the
store'': $\scope(\_,\ls,\js{y},\nil)$. Both of these assertions must make
use of the $\protop$ fields in order to navigate the variable store,
so we cannot separate them using $\sep$.
But the first assertion does not mention any \js{y} field, and the
second assertion does not mention any \js{x} field, so we cannot join
them with $\land$. In order to make
both assertions about the same variable store, we need a way for them
to share their common parts. To do this, we introduce the {\em sepish
  connective} $P \sepish Q$ which allows {\em partial} separation
between heaps. We can use $\sepish$ to describe the state of more than
one variable in a given store:
$\scope(\_,\ls,\js{x},l_2)\sepish\scope(\_,\ls,\js{y},\nil)$,  and we
shall see in Section~\ref{sec:reasoning} that it is also
invaluable when defining the $\scope$ predicate.


An assertion may be satisfied by a triple $(h,L,{\env})$ consisting of an
{abstract heap} $h$, a scope chain $L$, and a {logical environment} $\env$.
An {\em  abstract JavaScript heap}  is a partial function $H \ty \refs
\rightharpoonup \vals \cup \{\none\}$ that maps { references}, $r \in
\refs= \loc \times \vars $  to values $v\in \vals$ or $\none$. Abstract heaps thus declare information about fields not being present in an object,
as well as the fields that are present. 
We also define an evaluation function $\heval{\_}$ which takes an abstract heap to a concrete heap: 
%
\[\heval{h}(l,x) \triangleq h(l,x) \text{ iff } (l,x) \in \domain(h) \land h(l,x) \not= \none\]
We use this function in Section~\ref{sec:reasoning} to define the
relationship between our reasoning using Hoare triples and our operational semantics. 

%our reasoning with Hoare triples and the behaviour of programs.



We define a logical environment $\env$, which is a partial function
from logical variables $\V{X}\in\lvars$ to logical values $\lvals$,
which may be a return value $r$, any expression $\js{e}$, $\none$ or a
list $Ls$ of logical values.
%
We also define logical expressions $E$, which are different from program
expressions in that they can not read or alter the heap.
%
Expressions $\Expr$ are evaluated in a logical environment $\env$ with respect to a current scope chain $L$.
%
\begin{display}{Logical expressions and evaluation: $\eval{\Expr}^L_{\env}$.}
~~~$ \V{v}\in\lvals \defeq e \pipe v \pipe \none \pipe Ls $\qquad\qquad\qquad\qquad\qquad\quad
$ \env:\lvars \rightharpoonup \lvals$ \\[\gap]
$\begin{array}{rll}
  \Expr \defeq & \V X& \text{Logical variables} \\
  & \pipe \ls & \text{Scope list} \\
  & \pipe \V{v} & \text{Logical values} \\
  &\pipe \Expr \oplus \Expr%\pipe \Expr - \Expr\pipe \Expr * \Expr\pipe \Expr / \Expr & \text{Arithmetic}\\
  %&\pipe \Expr . \Expr 
        & \text{Binary Operators} \\  
  &\pipe \Expr \cons \Expr &\text{List cons} \\
%  &\pipe \Expr \in \T{set} & \text{Expression Type Checking}\\
  & \pipe \Expr \sv \Expr & \text{Reference construction}\\
  & \pipe \lambda\Expr.\Expr & \text{Lambda values}
\end{array}$\\[\gap]
%
~~~\jaxiom{\eval{\V{v}}^L_{\env}}{\V{v}}
\rsep
%
~~~\jaxiom
{\eval{\ls}^L_{\env}}{ L }
\rsep
\jaxiom{\eval{\V{X}}^L_{\env}  }{{\env}(\V{X})}
\\[\gap]


~~~\jaxiom
{\eval{{\Expr_1}\cons{\Expr_2}}^L_{\env} }{ \eval{{\Expr_1}}^L_{\env}
  \cons \List \text{ if } \eval{{\Expr_2}}^L_{\env} = \List }
\\[\gap]
%
~~~\jaxiom
{\eval{{\Expr_1}\sv{\Expr_2}}^L_{\env}  }{  l\sv\js{x}
\text{ if }\eval{{\Expr_1}}^L_{\env} = l \land \eval{{\Expr_2}}^L_{\env}=\js{x}}
\\[\gap]


~~~\jaxiom
{\eval{{\Expr_1}\oplus{\Expr_2}}^L_{\env}  }{ v\primop v'
\text{ if }\eval{\Expr_1}^L_{\env} = v \land \eval{\Expr_2}^L_{\env} = v'}
\\[\gap]
%
~~~\jaxiom
{  \eval{\lambda{\Expr_1}.{\Expr_2}}^L_{\env}  }{  \lambda\js{x}.\eval{{\Expr_2}}^L_{\env}
\text{ if } \eval{{\Expr_1}}^L_{\env}=\js{x} }
%
\end{display}


%\begin{defn}[Logical Expressions]
%\[
%\begin{array}{rll}
%  \Expr \defeq & \lvars & \text{Variables} \\
%  & \pipe \ls & \text{Scope List} \\
%  & \pipe \V{val} & \text{Values} \\
%  &\pipe \Expr \oplus \Expr%\pipe \Expr - \Expr\pipe \Expr * \Expr\pipe \Expr / \Expr & \text{Arithmetic}\\
%  %&\pipe \Expr . \Expr 
%        & \text{Binary Operators} \\  
%  &\pipe \Expr : \Expr &\text{List Cons} \\
%%  &\pipe \Expr \in \T{set} & \text{Expression Type Checking}\\
%  & \pipe \Expr \sv \Expr & \text{Reference Construction}\\
%  & \pipe \lambda_{\Expr}\Expr.\Expr & \text{Lambda Values}
%\end{array}
%\]
%\end{defn}


%%
%\begin{display}{Logical Expression Evaluation: $\eval{\Expr}^L_{\env}$.}
%%{\small\[
%$\begin{array}{ll}
%  \eval{\lvars}^L_{\env} & \triangleq {\env}(\LVAR) \\[\gap]
%  \eval{\ls}^L_{\env} & \triangleq L \\[\gap]
%  \eval{\V{val}}^L_{\env} & \triangleq \V{val} \\[\gap]
%  \eval{{\Expr_1}\oplus{\Expr_2}}^L_{\env} & \triangleq 
%  \begin{array}[t]{rl}
%    n\primop n' & \text {iff} \eval{\Expr_1}^L_{\env} = n \land \eval{\Expr_2}^L_{\env} = n' \\
%%    \text{not defined} & \text{otherwise} \\
%  \end{array}\\[\gap]
%  %  \eval{{\Expr_1}-{\Expr_2}}^l_{\env} & \triangleq 
%%  \begin{array}[t]{rl}
%%    n-n' & \text {iff} \eval{Exp1}^l_{\env} = n \land \eval{Exp2}^l_{\env} = n' \\
%%    \text{not defined} & \text{otherwise} \\
%%  \end{array}\\
%%  \eval{{\Expr_1}*{\Expr_2}}^l_{\env} & \triangleq 
%%  \begin{array}[t]{rl}
%%    n*n' & \text {iff} \eval{Exp1}^l_{\env} = n \land \eval{Exp2}^l_{\env} = n' \\
%%    \text{not defined} & \text{otherwise} \\
%%  \end{array}\\
%%  \eval{{\Expr_1}/{\Expr_2}}^l_{\env} & \triangleq 
%%  \begin{array}[t]{rl}
%%    n/n' & \text {iff} \eval{Exp1}^l_{\env} = n \land \eval{Exp2}^l_{\env} = n' \\
%%    \text{not defined} & \text{otherwise} \\
%%  \end{array}\\
%%  \eval{{\Expr_1}.{\Expr_2}}^l_{\env} & \triangleq 
%%  \begin{array}[t]{rl}
%%    m.m' & \text {iff} \eval{Exp1}^l_{\env} = m \land \eval{Exp2}^l_{\env} = m' \\
%%    \text{not defined} & \text{otherwise} \\
%%  \end{array}\\
%  \eval{{\Expr_1}:{\Expr_2}}^L_{\env} & \triangleq
%  \begin{array}[t]{rl}
%    \eval{{\Expr_1}}^L_{\env} : \V{list} & \text{iff} \eval{{\Expr_2}}^L_{\env} = \V{list} \\
% %   \text{not defined} & \text{otherwise} \\
%  \end{array}\\[\gap]
% % \eval{{\Expr_1}\in\T{set}}^l_e & \triangleq \eval{{\Expr_1}}^l_e \in \T{set} \\
%  \eval{{\Expr_1}\sv{\Expr_2}}^L_{\env} & \triangleq
%  \begin{array}[t]{rl}
%    \eval{{\Expr_1}}^L_{\env} \sv \eval{{\Expr_2}}^L_{\env} & \text{iff} \eval{{\Expr_1}}^L_{\env} = l' \land \eval{{\Expr_2}}^L_{\env}=\js{x}\\
%  %  \text{not defined} & \text{otherwise} \\
%  \end{array}\\[\gap]
%  \eval{\lambda_{{\Expr_1}}{\Expr_2}.{\Expr_3}}^L_{\env} & \triangleq 
%  \begin{array}[t]{rl}
%    \lambda_{\eval{{\Expr_1}}^L_{\env}}\eval{{\Expr_2}}^L_{\env}.\eval{{\Expr_3}}^L_{\env}& \text{iff} \eval{{\Expr_1}}^L_{\env} = L' \land \eval{{\Expr_2}}^L_{\env}=\js{x} \\
%   % \text{not defined} & \text{otherwise}\\
%  \end{array}\\
%\end{array}$
%%\]}
%\end{display}
%
%\begin{display}{Logical Expression Evaluation: $\eval{\Expr}^L_{\env}$.}
%%
%\jaxiom{\eval{\V{v}}^L_{\env}}{\V{v}}
%\rsep
%%
%\jaxiom
%{\eval{\ls}^L_{\env}}{ L }
%\rsep
%\jaxiom{\eval{\V{X}}^L_{\env}  }{{\env}(\V{X})}
%\\[\gap]
%
%
%\jrule
%{\eval{{\Expr_1}\cons{\Expr_2}}^L_{\env} }{ \eval{{\Expr_1}}^L_{\env} \cons \List}
%{\eval{{\Expr_2}}^L_{\env} = \List }
%\rsep
%%
%\jrule
%{\eval{{\Expr_1}\sv{\Expr_2}}^L_{\env}  }{ \eval{{\Expr_1}}^L_{\env} \sv \eval{{\Expr_2}}^L_{\env}}
%{\eval{{\Expr_1}}^L_{\env} = l' \land \eval{{\Expr_2}}^L_{\env}=\js{x}}
%\\[\gap]
%
%
%\jrule
%{\eval{{\Expr_1}\oplus{\Expr_2}}^L_{\env}  }{ n\primop n'}
%{\eval{\Expr_1}^L_{\env} = n \land \eval{\Expr_2}^L_{\env} = n'}
%\rsep
%%
%\jrule
%{  \eval{\lambda{\Expr_1}.{\Expr_2}}^L_{\env}  }{  \lambda\eval{{\Expr_1}}^L_{\env}.\eval{{\Expr_2}}^L_{\env}}
%{ \eval{{\Expr_1}}^L_{\env}=\js{x} }
%%
%\end{display}




%\begin{defn}[Logical Expression Evaluation]
%The evaluation of an expression $\Expr$ in a logical environment $\env$ with current scope list $L$ is written $\eval{\Expr}^L_{\env}$ and defined by:
%{\small
%\[
%$\begin{array}{ll}
%  \eval{\LVAR}^L_{\env} & \triangleq {\env}(\LVAR) \\[\gap]
%  \eval{\ls}^L_{\env} & \triangleq L \\[\gap]
%  \eval{\V{val}}^L_{\env} & \triangleq \V{val} \\[\gap]
%  \eval{{\Expr_1}\oplus{\Expr_2}}^L_{\env} & \triangleq 
%  \begin{array}[t]{rl}
%    n\primop n' & \text {iff} \eval{\Expr_1}^L_{\env} = n \land \eval{\Expr_2}^L_{\env} = n' \\
%%    \text{not defined} & \text{otherwise} \\
%  \end{array}\\[\gap]
%  %  \eval{{\Expr_1}-{\Expr_2}}^l_{\env} & \triangleq 
%%  \begin{array}[t]{rl}
%%    n-n' & \text {iff} \eval{Exp1}^l_{\env} = n \land \eval{Exp2}^l_{\env} = n' \\
%%    \text{not defined} & \text{otherwise} \\
%%  \end{array}\\
%%  \eval{{\Expr_1}*{\Expr_2}}^l_{\env} & \triangleq 
%%  \begin{array}[t]{rl}
%%    n*n' & \text {iff} \eval{Exp1}^l_{\env} = n \land \eval{Exp2}^l_{\env} = n' \\
%%    \text{not defined} & \text{otherwise} \\
%%  \end{array}\\
%%  \eval{{\Expr_1}/{\Expr_2}}^l_{\env} & \triangleq 
%%  \begin{array}[t]{rl}
%%    n/n' & \text {iff} \eval{Exp1}^l_{\env} = n \land \eval{Exp2}^l_{\env} = n' \\
%%    \text{not defined} & \text{otherwise} \\
%%  \end{array}\\
%%  \eval{{\Expr_1}.{\Expr_2}}^l_{\env} & \triangleq 
%%  \begin{array}[t]{rl}
%%    m.m' & \text {iff} \eval{Exp1}^l_{\env} = m \land \eval{Exp2}^l_{\env} = m' \\
%%    \text{not defined} & \text{otherwise} \\
%%  \end{array}\\
%  \eval{{\Expr_1}:{\Expr_2}}^L_{\env} & \triangleq
%  \begin{array}[t]{rl}
%    \eval{{\Expr_1}}^L_{\env} : \V{list} & \text{iff} \eval{{\Expr_2}}^L_{\env} = \V{list} \\
% %   \text{not defined} & \text{otherwise} \\
%  \end{array}\\[\gap]
% % \eval{{\Expr_1}\in\T{set}}^l_e & \triangleq \eval{{\Expr_1}}^l_e \in \T{set} \\
%  \eval{{\Expr_1}\sv{\Expr_2}}^L_{\env} & \triangleq
%  \begin{array}[t]{rl}
%    \eval{{\Expr_1}}^L_{\env} \sv \eval{{\Expr_2}}^L_{\env} & \text{iff} \eval{{\Expr_1}}^L_{\env} = l' \land \eval{{\Expr_2}}^L_{\env}=\js{x}\\
%  %  \text{not defined} & \text{otherwise} \\
%  \end{array}\\[\gap]
%  \eval{\lambda_{{\Expr_1}}{\Expr_2}.{\Expr_3}}^L_{\env} & \triangleq 
%  \begin{array}[t]{rl}
%    \lambda_{\eval{{\Expr_1}}^L_{\env}}\eval{{\Expr_2}}^L_{\env}.\eval{{\Expr_3}}^L_{\env}& \text{iff} \eval{{\Expr_1}}^L_{\env} = L' \land \eval{{\Expr_2}}^L_{\env}=\js{x} \\
%   % \text{not defined} & \text{otherwise}\\
%  \end{array}\\
%\end{array}$
%\]}
%\end{defn}

Assertions include the  boolean assertions, structural assertions of separation logic and our new
sepish connective, basic  assertions for describing cells in a JavaScript heap,  expression equality, set and list assertions, and quantification over logical variables.
%
\begin{display}{Assertions.}
$\begin{array}{rll}
  P \defeq 
 & P \land P \pipe P \lor P \pipe \neg P \pipe \true \pipe \false & \text{Boolean assertions}\\
 & \pipe P \sep P \pipe P \wand P \pipe P \sepish P %\pipe P \wandish P 
                         & \text{Structural assertions} \\
 & \pipe (\Expr,\Expr)\pointsto \Expr \pipe \lemp % \pipe \cancel{(\Expr,\Expr)}
                         & \text{JavaScript heap assertions} \\
%  & \pipe \LVAR & \text{logical (auxiliary) variables   TODO: Consider typing them.} \\
 & \pipe \Expr\doteqdot\Expr & \text{Expression equality} \\ % Might want to add string-inclusion?
 & \pipe \Expr \in \T{set} & \text{Set membership} \\
 & \pipe \Expr \elem \Expr  & \text{List element} \\
 & \pipe \exists\V{X}\st P  \pipe \forall\V{X}\st P &  \text{Quantification} \\
\end{array}\Gap$\\[\gap]
Notation: $E\not{\!\circ} E \triangleq \neg(E \circ E)$  for ${\circ}\in\{\doteqdot,\in\}$\\
\phantom{Notation: }$\Expr_1 \dot{\,\circ\,}\Expr_2 \triangleq \Expr_1
\circ \Expr_2 \land \lemp$ for
${\circ}\in\{\doteqdot,\not\doteqdot,\in,\notin\}$.\\
The logical operators bind in order: $\neg,\sepish,\sep,\land,\lor,\wand$.
\end{display}
%
The structural assertions $\sep$ and $\wand$ are
standard separation logic assertions. The separating conjunction
$P\sep Q$ says that the heap may be split into two disjoint heaps, one
 satisfying  $P$  and the other $Q$. The right adjoint $P \wand Q$ says that, whenever the heap is extended by a
heap satisfying $P$, then the resulting heap satisfies $Q$. 
It is useful in
proving the soundness of some of our layers of abstraction in
Section~\ref{sec:examples}, as given in
\ifshort{\cite{proofs}}\iflong{Appendices~\ref{sec:constantvar} and~\ref{sec:assignvarvar}}. 
The sepish  connective  $P \sepish Q$ is novel. It says that the heap may be split into two heaps,
one satisfying $P$ and the other  $Q$, but
these two heaps need not be disjoint. They may share zero or more
common cells. We shall see in Section~\ref{sec:reasoning} that this is
particularly useful when reasoning about the emulated variable store. 
It is possible to define $\wandish$ analogously with $\wand$, but
since this is not useful for JavaScript reasoning we omit it here. 
Note that $P \wedge Q \Rightarrow P \sepish Q$ and $P \ast Q \Rightarrow P \sepish Q$, but neither of the reverse implications hold. 
%
The assertion $(\Expr_1,\Expr_2)\pointsto \Expr_3$ declares information about a memory 
cell, including whether or not the field $\Expr_2$ is defined in object $\Expr_1$. 
Assertion $\lemp$ says that the heap is empty.
%
%...........can we just define what SET is in the figure and not have
%in main text..............
% GDSGDS: No - there's an enormous number of named sets in the techreport,
% and listing them all here would be ugly.
The notation  $\T{set}$ denotes  a literal set, or a named set such as $\vars$, the
set of JavaScript field names. Note that since there are sets for
numbers, strings and locations, we can use set inclusion to assert the
type of a particular JavaScript value.
%

%
%% The intuition of $P \sepish Q$ is that its footprint is the
%% union of the footprints of $P$ and $Q$, but that sharing of resources is
%% permitted between $P$ and $Q$. This allows us to reason naturally about complex
%% structures that permit sharing, such as the JavaScript emulated variable store.


%
The satisfaction relation $h,L,{\env} \satisfies P$ is defined below. The cases for the boolean assertions are not given
as they are standard. 


%
%\begin{display}{Satisfaction of assertions: $h,L,{\env} \satisfies P$.}
%$\begin{array}{ll}
%  h,L,{\env} \satisfies P \sep Q & \iff \exists h_1,h_2 \st  h \equiv h_1 \sep h_2 \land \\
%        &\quad (h_1,L,{\env} \satisfies P) \land (h_2,L,{\env} \satisfies Q)\\
%  h,L,{\env} \satisfies P \wand Q & \iff \forall h_1 \st (h_1,L,{\env} \satisfies P) \land h\mathbin{\#}h_1 \\
%        &\qquad\implies ((h \sep h_1),L,{\env} \satisfies Q)\\  
%  h,L,{\env} \satisfies P \sepish Q & \iff \exists h_1,h_2,h_3 \st \\
%          & \qquad h \equiv h_1 \sep h_2 \sep h_3 \land {}\\
%          & \qquad (h_1\sep h_3,L,{\env} \satisfies P) \land {}\\
%          & \qquad (h_2\sep h_3,L,{\env} \satisfies Q)\\
%  h,L,{\env} \satisfies P \sepish Q & \iff \exists h_1,h_2,h_3\st\\  
%\multicolumn{2}{l}{~~\qquad   h \equiv h_1 \sep h_2 \sep h_3 \land 
%   (h_1\sep h_3,L,{\env} \satisfies P) \land    (h_2\sep h_3,L,{\env} \satisfies Q)}\\
%  
%  h,L,{\env} \satisfies ({\Expr_1},{\Expr_2})\pointsto {\Expr_3} & \iff h \equiv (\eval{{\Expr_1}}^L_{\env},\eval{{\Expr_2}}^L_{\env})\pointsto \eval{{\Expr_3}}^L_{\env}\\
%  h,L,\env \satisfies \lemp & \iff h = \emp \\
%  
%  %h,L,{\env} \satisfies \LVAR & \iff h \equiv {\env}(\LVAR) \\
%  
%  h,L,{\env} \satisfies {\Expr_1} \doteqdot {\Expr_2} & \iff \eval{{\Expr_1}}^L_{\env} = \eval{{\Expr_2}}^L_{\env} \\
%  h,L,{\env} \satisfies \Expr \in \T{set} & \iff \eval{\Expr}^L_{\env} \in \tset \\
%  h,L,{\env} \satisfies \Expr_1 \elem \Expr_2 & \iff \eval{\Expr_1}^L_{\env} \text{ is in the list } \eval{\Expr_2}^L_{\env} \\
%
%  h,L,{\env} \satisfies \exists\V X \st P & \iff \exists \V{v} \st h,L,[{\env} | \V X\takes \V{v}] \satisfies P \\
%  h,L,{\env} \satisfies \forall\V X \st P & \iff \forall \V{v} \st h,L,[{\env} | \V X\takes \V{v}] \satisfies P \\
%\end{array}$
%\end{display}
%
\begin{display}{Satisfaction of assertions: $h,L,{\env} \satisfies P$.}
${h,L,{\env} \satisfies P \sep Q \qquad\iff \exists h_1,h_2 \st  h \equiv h_1 \sep h_2 \land }$\\
${\phantom{h,L,{\env} \satisfies P \sep Q \qquad\iff}(h_1,L,{\env} \satisfies P) \land (h_2,L,{\env} \satisfies Q)}$\\
%
${h,L,{\env} \satisfies P \wand Q\qquad\iff \forall h_1 \st (h_1,L,{\env} \satisfies P) \land h\mathbin{\#}h_1}$\\
${\phantom{h,L,{\env} \satisfies P \wand Q\qquad\iff }\implies ((h \sep h_1),L,{\env} \satisfies Q)}$\\
%
${h,L,{\env} \satisfies P \sepish Q}{\qquad\iff \exists h_1,h_2,h_3\st}$\\
$\qquad  h \equiv h_1 \sep h_2 \sep h_3 \land 
   (h_1\sep h_3,L,{\env} \satisfies P) \land    (h_2\sep h_3,L,{\env} \satisfies Q)$\\
%
$ h,L,{\env} \satisfies ({\Expr_1},{\Expr_2})\pointsto {\Expr_3} \qquad\iff h \equiv (\eval{{\Expr_1}}^L_{\env},\eval{{\Expr_2}}^L_{\env})\pointsto \eval{{\Expr_3}}^L_{\env}$\\
$  h,L,\env \satisfies \lemp  \qquad\iff h = \emp $\\
$ h,L,{\env} \satisfies {\Expr_1} \doteqdot {\Expr_2} \qquad\iff \eval{{\Expr_1}}^L_{\env} = \eval{{\Expr_2}}^L_{\env} $\\
$  h,L,{\env} \satisfies \Expr \in \T{set}  \qquad\iff \eval{\Expr}^L_{\env} \in \tset $\\
$  h,L,{\env} \satisfies \Expr_1 \elem \Expr_2  \qquad\iff \eval{\Expr_1}^L_{\env} \text{ is in the list } \eval{\Expr_2}^L_{\env} $\\

$  h,L,{\env} \satisfies \exists\V X \st P  \qquad\iff \exists \V{v} \st h,L,[{\env} | \V X\takes \V{v}] \satisfies P $\\
 $ h,L,{\env} \satisfies \forall\V X \st P  \qquad\iff \forall \V{v} \st h,L,[{\env} | \V X\takes \V{v}] \satisfies P $
\end{display}


%
%\begin{defn}[Satisfaction of assertions]
%An assertion $P$ may be satisfied by a triple $h,L,{\env}$ of a heap, stack list, and logical environment.
%\[
%\begin{array}{ll}
%  h,L,{\env} \satisfies P \land Q & \iff (h,L,\env \satisfies P) \land (h,L,{\env} \satisfies Q)\\
%  h,L,{\env} \satisfies P \lor Q & \iff (h,L,{\env} \satisfies P) \lor (h,L,{\env} \satisfies Q)\\
%  h,L,{\env} \satisfies \neg P & \iff \neg (h,L,{\env} \satisfies P) \\
%  h,L,{\env} \satisfies \true & \text{Always}\\
%  h,L,{\env} \satisfies \false & \text{Never}\\
%  
%  h,L,{\env} \satisfies P \sep Q & \iff \exists h1,h2 \st  h \equiv h1 \sep h2 \land \\
%        &\quad (h1,L,{\env} \satisfies P) \land (h2,L,{\env} \satisfies Q)\\
%  h,L,{\env} \satisfies P \wand Q & \iff \forall h' \st (h',L,{\env} \satisfies P) \land h\mathbin{\#}h' \\
%        &\qquad\implies ((h \sep h'),L,{\env} \satisfies Q)\\  
%  h,L,{\env} \satisfies P \sepish Q & \iff \exists h1,h2,h3 \st \\
%          & \qquad h \equiv h1 \sep h2 \sep h3 \land {}\\
%          & \qquad (h1\sep h3,L,{\env} \satisfies P) \land {}\\
%          & \qquad (h2\sep h3,L,{\env} \satisfies Q)\\
%  
%  h,L,{\env} \satisfies ({\Expr_1},{\Expr_2})\pointsto {\Expr_3} & \iff h \equiv (\eval{{\Expr_1}}^L_{\env},\eval{{\Expr_2}}^L_{\env})\pointsto \eval{{\Expr_3}}^L_{\env}\\
%  h,L,\env \satisfies \lemp & \iff h = \emp \\
%  
%  %h,L,{\env} \satisfies \LVAR & \iff h \equiv {\env}(\LVAR) \\
%  
%  h,L,{\env} \satisfies {\Expr_1} \doteqdot {\Expr_2} & \iff \eval{{\Expr_1}}^L_{\env} = \eval{{\Expr_2}}^L_{\env} \\
%  h,L,{\env} \satisfies \Expr \in \T{set} & \iff \eval{\Expr}^L_{\env} \in \tset \\
%  h,L,{\env} \satisfies \Expr_1 \elem \Expr_2 & \iff \eval{\Expr_1}^L_{\env} \text{ is an element of the list } \eval{\Expr_2}^L_{\env} \\
%
%  h,L,{\env} \satisfies \exists\LVAR \st P & \iff \exists \V{val} \st h,L,[{\env} | \LVAR\takes \V{val}] \satisfies P \\
%  h,L,{\env} \satisfies \forall\LVAR \st P & \iff \forall \V{val} \st h,L,[{\env} | \LVAR\takes \V{val}] \satisfies P \\
%\end{array}
%\]
%\end{defn}
%
We have given a direct definition of the sepish connective. When logical variables range over heaps, it  can be derived: $P \sepish Q \Leftrightarrow \exists \V{R} \st (\V{R} \wand P) \sep (\V{R} \wand Q) \sep \V{R}$. It remains to be seen what
natural  logical properties are satisfied by this connective. 



%Just as with previous separation logic work, we define $\_$ and $\doteq$ for convenience:
%\[       \_ \triangleq \exists \V{X}\st \V{X}\qquad
%\Expr_1\doteq\Expr_2 \triangleq \Expr_1\doteqdot\Expr_2 \land \lemp
%\]
%We adopt a similar convention for ${\not\doteq} , {\dotin}$ and ${\notdotin}$.
%
%



%\[
%\begin{array}{ll}
%  \Expr\not\doteq\Expr' &\triangleq (\Expr\not\doteqdot\Expr') \land \lemp \\
%  \Expr\dotin\Expr' &\triangleq (\Expr\in\Expr') \land \lemp \\
%  \Expr\notdotin\Expr' &\triangleq (\Expr\not\in\Expr') \land \lemp \\
%\end{array}
%\]

% \begin{defn}{Sepish and Wandish.}
% \textbf{GDSGDS: } Josh told me that these are ``relevant conjunction'' and ``relevant implication''. James told me they're not. Pete convinced James that they are.\\
% The logical operator $\sepish$ means ``some separation and some sharing'', and is defined by:
% 
% \[
% P \sepish Q \triangleq \exists \V{V} \st (\V{V} \wand P) \sep (\V{V} \wand Q) \sep \V{V}
% \]
% 
% Although we don't use it in this work, the operator $\wandish$ may be thought of as to $\sepish$ as $\wand$ is to $\sep$.
% \[
% P \wandish Q \triangleq \exists \V{V} \st (P \wand (\V{V} \wand Q)) \sep \V{V}
% \]



%\end{defn}















\section{Program Reasoning}\label{sec:reasoning}
%
%% We give a fault-avoiding program reasoning system which is sound with
%% respect to the operational semantics in Section~\ref{sec:semantics}.

%% Since many JavaScript statements are not local in the traditional
%% sense, we prove soundness using `weak locality' as introduced
%% in~\cite{gdsThesis}.
In the spirit of separation logic, we give 
small axioms and inference rules which precisely capture the behaviour
of all JavaScript expressions,  except for the usual approximation for
\js{while}  and conservative approximations of function calls and
\js{eval}. Reasoning about function calls and \js{eval} is interesting and complex, and will be the
focus of future work as outlined in Section~\ref{sec:conclusions}.
Because our reasoning captures the full complexity of JavaScript
semantics, particularly with respect to the emulated variable store
and the \js{with} command, it is possible to prove properties about extremely subtle
programs. Unfortunately, proving any program at this
level of abstraction involves a level  of  detail which most programmers
would understandably rather avoid. We therefore provide several
\emph{layers of abstraction} which make it possible to reason at a
natural high level about well-behaved JavaScript programs.
We discuss these abstractions  in Section~\ref{sec:examples}.

Our fault-avoiding Hoare triples take the form:
$\{P\}\js{e}\{Q\}$, which means ``if $\js{e}$ is executed
in a state satisfying $P$, then it will not fault, and if it
terminates it will do so in a state satisfying $Q$''. The postcondition $Q$ may
refer to the special variable $\rv$, which is equal to the return value of
\js{e}.  




\subsection{Auxiliary Predicates}
%
%In order to reason about the JavaScript heap-simulation of a variable stack, we define a predicate $\scope$ that finds a variable in a scope. 
%This inductive predicate takes a list of scope pointers {\List}, a starting scope pointer \E{Start}, a variable name \E{Var}, and a scope pointer \E{L}. 
%
For our reasoning rules, we require predicates that correspond to 
functions, such as $\sigma$, $\pi$ and $\gamma$, used by the operational semantics in
Section~\ref{sec:semantics}. These predicates present  us with two distinct
challenges: sharing and precision. 
To consider  sharing, recall the scope function $\scope$ from
Section~\ref{sec:syntax2} when searching for a variable \js{y} in the
example emulated store  given in~Figure~\ref{fig:variableStore}. Since \js{y} is
not present in the emulated store, $\scope$ will check the entire
structure before returning $\nil$ to indicate that \js{y} cannot be
found. What is of interest to us is the order in which the cells in
the store will be checked. Notice that the cell $l$ will be checked
twice, and the cell $\lop$ will be checked three times. This is
because the cells $l$ and $\lop$ are shared between 
the prototype chain of the object $l_2$ and the object $l_4$. In
addition, $\lop$ is shared by these prototype chains and  the prototype chain of 
$\lgo$. As we shall see below, we can describe these partially shared
structures using our sepish connective~$\sepish$.
To consider precision, recall  the 
function $\scope$  when this time  searching for a variable  \js{x} either in the emulated store of 
Figure~\ref{fig:variableStore}, or in the identical store
but for the omission of a single object such that the prototype
of $l_2$ would be $l$. In each of these stores, the $\scope$ function will
return the same value -- the location $l_2$. In our program reasoning,
 our $\scope$ predicate (which will correspond to the $\scope$
function of the operational semantics) must  be more precise as we need to 
distinguish between these two possible cases.
%
With the challenges of sharing and precision  in mind, we first give, then explain, the
logical predicates $\scope$, $\proto$ and $\getValue$.

\begin{display}{Logical predicates: $\scope,\proto,\getValue$.}
$\begin{array}{l}
        \scope({\emptylist},{\emptylist},\_,\nil) ~~\triangleq~~ \lemp\\
        \scope([{\List}],\E{L}':\E{Ls}',\E{X},\E{L}') ~~\triangleq~~ 
         \exists\V{L}\st\proto({\List},\E{L}', \E{X}, \V{L}) \sep \V{L}\not\doteq\nil \\
          \scope(({\Lista}:{\Listb}),\E{L}':\E{Ls}',\E{X},\E{L}) ~~\triangleq~~ \\
  \qquad\qquad\proto({\Lista},\E{L}',\E{X},\nil) \sepish {}
 \scope({\Listb},\E{Ls}',\E{X},\E{L})
\end{array}$\Gap\\[\gap]
%
$\begin{array}{l}
  \proto({\emptylist},\nil,\_,\nil) ~~\triangleq~~ \lemp\\
  \proto([\E{L}],\E{L},\E{X},\E{L}) ~~\triangleq~~ 
 \exists\LVAL\st(\E{L},\E{X})\pointsto \LVAL \sep \LVAL\not\doteq\none\\
  \proto((\E{L}':{\List}),\E{L}',\E{X},\E{L}) ~~\triangleq~~\\
 % \qquad \begin{array}[t]{l}
\qquad          \exists\V{N}\st
    (\E{L}',\E{X})\pointsto\none \sep {}
    (\E{L}',\protop)\pointsto \V{N} \sep {}
    \proto({\List},\V{N},\E{X},\E{L})
%  \end{array}\\
\end{array}$\Gap\\[\gap]
%
$\begin{array}{l}
  \getValue({\emptylist}, \E{Val},\E{Val}) ~~\triangleq~~ \E{Val} \notdotin\refs \\
  \getValue({\List}, \E{L}\sv\E{X}, \und) ~~\triangleq~~ \proto({\List},\E{L},\E{X}, \nil) \sep \E{L}\not\doteq\nil \\
  \getValue({\List}, \E{L_1}\sv\E{X}, \E{Val})~~\triangleq~~\\
\qquad\exists\V{L_2}\st \proto({\List},\E{L_1},\E{X}, \V{L_2}) \sepish {}         (\V{L_2},\E{X})\pointsto\E{Val} \sep \E{Val}\not\doteq\none\\
\end{array}$
\end{display}
These predicates closely follow the structure of the functions defined
in~\ref{sec:syntax2}, using $\sepish$ to manage the challenge of
sharing prototype chains mentioned earlier. The predicate
$\scope(\_,L,\js{x},l)$ holds only for abstract heaps $h$ such that
the function from Section~\ref{sec:syntax2} gives us
$\scope(\heval{h},L,\js{x})=l$, meaning that the value of the variable
\js{x} in the emulated variable store given by the list $L$ can be
found in the object (or a prototype of the object) at address $l$.
However, recall the challenge of precision mentioned earlier. In order
to distinguish between all the possible heaps which satisfy the
predicate $\scope(\_,L,\js{x},l)$, we work with an additional first
argument. The predicate $\scope(Ls,L,\js{x},l)$ is ``precise'' in the
sense that, for any abstract heap $h$, it holds for at most one
subheap of $h$. The first argument $Ls$ is a list of lists, which
specifies the exact cells which must be visited (and the order in
which they must be checked) in order to determine which object in the
emulated variable store defines the variable \js{x}. For example,
recall the heap illustrated in Figure~\ref{fig:variableStore}. If the
prototype of the cell $l_2$ has address $l'$, then the predicate
$\scope([[l_1],[l_2,l',l]],\ls,\js{x},l_2)$ is satisfied by the
abstract heap consisting of the $\js{x}$ and $\protop$ fields of the
four objects in the lower left corner of that diagram. Notice that we
do not need to visit every object in the variable store in order to
discover the location of the variable $\js{x}$. In the spirit of the
small axioms of separation logic, our predicate holds for the smallest
possible heap in which we can be sure of discovering the variable we
are interested in.

The predicates $\proto$ and $\getValue$ are similar in that they
mirror their operational counterparts, with the addition of one extra
argument to make them precise. In the case of $\proto$ and $\getValue$,
the first argument $Ls$ is simply a list of addresses, rather than a list of
lists of addresses, because each predicate only walks down at
most one prototype chain.

% GDSGDS: Consider the use of sepish in the following carefully.\\
% And a ``canPut" predicate:
% \newcommand{\canPut}{\tt{canPut}}

% \[
% \begin{array}{ll}
%   \canPut({\List},\E{L},\E{M},true) &\triangleq \proto({\List},\E{L},\E{M},null) \\
%   \canPut({\List},\E{L},\E{M},true) &\triangleq 
%     \begin{array}[t]{l}
% 		\proto({\List},\E{L},\E{M},l)\sepish \\
% 		(l,\E{M})\pointsto va\{\tilde a\}\wedge\\
% 		ReadOnly\in \{\tilde a\}
% 	\end{array}\\
%   \canPut({\List},\E{L},\E{M},false) &\triangleq 
%     \begin{array}[t]{l}
% 		\proto({\List},\E{L},\E{M},l)\sepish \\
% 		(l,\E{M})\pointsto va\{\tilde a\}\wedge\\
% 		ReadOnly\not\in \{\tilde a\}
% 	\end{array}
% \end{array}
% \]

The inference rules %for Hoare triples shall need the 
also require logical predicates corresponding to a number of other auxiliary functions given in Section~3. 
%
Below, we define \newobj and \func predicates, which assert the existence of a fresh object and function object, and \vardecls that returns the local variables of an expression.
%
In order to reason about function call, we also use a \defs\ predicate  which we define  in~\ifshort{\cite{proofs}}\iflong{Appendix~\ref{sec:tables:logics}}.

%
\begin{display}{Auxiliary predicates}
$\pickThis(\E{L}\sv\_,\E{L}) ~~~\triangleq~~~ (\E{L},\thisp)\pointsto\none\qquad\text{where }\E{L}\neq\lgo$\\
$\pickThis(\E{L}\sv\_,\lgo) ~~~\triangleq~~~ \exists\V{V}\st(\E{L},\thisp)\pointsto\V{V}\sep\V{V}\not\doteq\none$\\[\gap]
%
$\istrue(\E{E}) ~~~\triangleq~~~ \E{E}\notdotin \falsity$\\
$\isfalse(\E{E}) ~~~\triangleq~~~ \E{E}\dotin \falsity$\\
%
$\newobj(\E{L},\E{V}_1,\dots,\E{V}_n) ~~~\triangleq~~~ \bigsep_{\E{V} \in \vars\setminus\{\E{V}_1\dots\E{V}_n\}} (\E{L},\E{V}) \pointsto\none$\\[\gap]
%
$\begin{array}{l}
        \hspace{-5pt}\func(\E{F},\E{Env},\E{X},\E{Body},\E{Proto}) ~~~\triangleq
        \\ \qquad 
                (\E{F},\fscopep)\pointsto \E{Env} \sep
                (\E{F},\bodyp )\pointsto \lambda\E{X}.\E{Body} \sep{}\\
        \qquad  (\E{F},\js{prototype} )\pointsto \E{Proto} \sep
                (\E{F},\protop )\pointsto \lfp
\end{array}$\\[\gap]
%
$\vardecls(\E{X},\E{L},\js e) ~\triangleq~ \js{x1},\ldots,\js{xn}\quad\text{ where }(\E{L},\js{xi})\in\domain(\defs(\E{X},\E{L},\js e))$
%
\end{display}





\subsection{Inference Rules}
%
We define below some inference rules $\tr P{\js e}Q$ for reasoning about JavaScript expressions.
%
The full list can be found in~\ifshort{\cite{proofs}}\iflong{Appendix~\ref{sec:tables:logics}}.
%
\remark{SM: i proposed changing all logical rules to be as concrete as possible, but the changes would propagate very far (e.g. scope, proto etc.). for now, \V V etc. are universally quantified outside the rule i guess.}
%
\begin{display}{Inference rules: $\tr P {\js{e}} Q$.}
%
\staterule{(Definition)}
{\tr P {\js{e}} Q \qquad \rv\not\in\fv(Q)}
{\tr P {\js{var e}} {Q\sep\rv\doteq\und}}
\rsep
%
\stateaxiom{(Value)}
{\tr \lemp {\js{v}} {\rv\doteq\js{v}}}
\\[\gap]



\staterule{(Variable)}
{P = \scope({\Lista},\ls,\js{x},\E{L})\sepish\getValue({\Listb},\E{L}\sv\js{x},\E{V})}
{\tr P {\js{x}} {P \sep \rv\doteq\E{L}\sv\js{x}}}
~%\rsep
%
\staterule{(Variable Null)}
{P = \scope({\List},\ls,\js{x},\nil)}
{\tr P {\js{x}}{P\sep \rv\doteq\nil\sv\js{x}}}
\\[\gap]


\staterule{(Member Access)}
{\tr P {\js e} {Q\sep\rv\doteq\E{V}}\qquad
Q = R\sep\getValue({\List},\E{V},\E{L})\sep\E{L}\not\doteq\nil}
{\tr P {\js{e.x}} {Q\sep\rv\doteq\E{L}\sv\js{x}}}
\\[\gap]


\staterule{(Computed Access)}
{\tr P {\js e1} {R\sep\rv\doteq\E{V_1}}\qquad
R = S_1\sep\getValue({\Lista},\E{V}_1,\E{L})\sep\E{L}\not\doteq\nil\\
\tr {R} {\js e2} {Q\sep X \dotin \uvars \sep\rv\doteq\E{V}_2}\qquad
Q = S_2\sep\getValue({\Listb},\E{V}_2,\E{X})}
{\tr P {\js{e1[e2]}} {Q\sep\rv\doteq\E{L}\sv\E{X}}}
\\[\gap]




%\staterule{(Object)}
%{\forall i\in 1..n\quad\left(\begin{array}{l}
%						 	P_i = R_i\sep\getValue(\List_i,\E{Y_i},\E{X_i})\\
%                             \tr  {P_{i-1}} {\js{ei}} {P_i\sep\rv\doteq\E{Y_i}}
%                             \end{array}\right)\\
% \js{x1} \neq \dots \neq \js{xn}\\ 
% Q = \left( P_n \sep \exists \V{L} \st \left(
% 	\begin{array}{l}
%        \newobj(\V{L},\protop,\js{x1},\dots,\js{xn}) \sep {}\\
%        (\V{L},\js{x1})\pointsto\E{X_1} \sep \dots \sep (\V{L},\js{xn})\pointsto\E{X_n} \sep{}\\
%        (\V{L},\protop)\pointsto \lop \sep \rv\doteq \V{L}
%		\end{array}\right)\right)\\
% \rv\not\in \fv(P_n)}
%{\tr {P_0} {\js{\{x1}\js{:e1},\dots,\js{xn}\js{:en}\js{\}}} Q}
%  \\[\gap]

\staterule{(Object)}
{\forall i\in 1..n.~ \big(
						 	P_i = R_i\sep\getValue(\List_i,\E{Y_i},\E{X_i})\quad
                             \tr  {P_{i-1}} {\js{ei}} {P_i\sep\rv\doteq\E{Y_i}}\big)\\[\gap]
 Q = \left( P_n \sep \exists \V{L} \st \left(
 	\begin{array}{l}
        \newobj(\V{L},\protop,\js{x1},\dots,\js{xn}) \sep {}\\
        (\V{L},\js{x1})\pointsto\E{X_1} \sep \dots \sep (\V{L},\js{xn})\pointsto\E{X_n} \sep{}\\
        (\V{L},\protop)\pointsto \lop \sep \rv\doteq \V{L}
		\end{array}\right)\right)\Gap\\
\js{x1} \neq \dots \neq \js{xn}\qquad \rv\not\in \fv(P_n)}
{\tr {P_0} {\js{\{x1}\js{:e1},\dots,\js{xn}\js{:en}\js{\}}} Q}
  \\[\gap]

\staterule{(Binary Operators)}
{\tr P {\js{e1}} {R\sep\rv\doteq\E{V_1}}  \qquad
    R = S_1 \sep\getValue({\Lista},\E{V_1},\E{V_3})\\
 \tr R {\js{e2}} {Q\sep\rv\doteq\E{V_2}} \qquad
    Q = S_2\sep\getValue({\Listb},\E{V_2},\E{V_4})\\
    \E{V} = \E{V_3}\primop\E{V_4}}
{\tr   P {\js{e1}\oplus\js{e2}} { Q\sep\rv\doteq \E{V} }}
  \\[\gap]


\staterule{(Assign Global)}
{\tr P {\js{e1}} {R \sep\rv\doteq \nil\sv\E{X}}\\
\tr R {\js{e2}} {Q \sep (\lgo,\E{X}) \pointsto\none \sep\rv\doteq \E{V_1}}\qquad
Q = S\sep\getValue(\List,\E{V_1},\E{V_2})}
{ \tr P {\js{e1 = e2}} {Q\sep {} (\lgo,\E{X})\pointsto\E{V_2} \sep\rv\doteq \E{V_2}}}
  \\[\gap]


\staterule{(Assign Local)}
{\tr P {\js{e1}} {R \sep\rv\doteq \E{L}\sv\E{X}}\\
\tr R {\js{e2}} {Q \sep (\E{L},\E{X}) \pointsto \E{V_3} \sep\rv\doteq \E{V_1}}\qquad
Q = S\sep\getValue(\List,\E{V_1},\E{V_2})}
{\tr P {\js{e1 = e2}} {Q\sep (\E{L},\E{X})\pointsto\E{V_2} \sep\rv\doteq \E{V_2}}}
\\[\gap]





\staterule{(Function)}
{Q = \left(\begin{array}{l}
        \exists \V{L_1},\V{L_2}\st
        \newobj(\V{L_1},\protop) \sep (\V{L_1},\protop)\pointsto\lop \sep {}\\
        \newobj(\V{L_2},\protop,\js{prototype},\scopep, \bodyp) \sep {}\\
        \func(\V{L_2},\ls,\js{x},\js{e},\V{L_1}) \sep \rv \doteq \V{L_2}
 \end{array}\right)}
{\tr {\lemp}{\jsfun{x}{e}}{Q}}
\\[\gap]




%
% Statements -- moved up to make space more sensical.
%


\staterule{(While)}
{\tr P {\js{e1}} {S\sep\rv\doteq\E{V_1}} \qquad
S = R \sep \getValue({\List},\E{V_1},\E{V_2})\\
 \tr {S \sep \istrue(\E{V_2})} {\js{e2}} P\\
 Q = S \sep \isfalse(\E{V_2})\sep\rv\doteq\und\qquad
 \rv\not\in \fv(R)}
{\tr P {\js{while(e1)\{e2\}}} Q}
\\[\gap]


\staterule{(With)}
{\tr {P \sep \ls\doteq\E{L}} {\js{e1}} {S\sep \ls\doteq\E{L}\sep \rv\doteq\E{V_1}} \qquad
S =  R \sep \getValue(\List,\E{V_1},\E{L_1}) \sep \E{L_1}\not\doteq\nil\\
\tr {S\sep \ls\doteq\E{L_1}{:}\E{L}}{ \js{e2} }{ Q\sep \ls\doteq\E{L_1}{:}\E{L} }\qquad
 \ls \not\in\fv(P, Q, R)}
{\tr { P \sep \ls\doteq\E{L}}{ \js{with(e1)\{e2\}}} { Q \sep
    \ls\doteq\E{L}}}
\\[\gap]




\staterule{(Function Call)}
{\tr P {\js{e1}} {R_1 \sep\rv\doteq \E{F_1}}\\
 R_1 = \left(\begin{array}{l}
          S_1 \sepish \pickThis(\E{F_1},\E{T})\sepish \getValue(\Lista,\E{F_1},\E{F_2}) \sep\\%\E{F_2}\not\doteq\lge\sep\\
          (\E{F_2},\bodyp)\pointsto \lambda\E{X}.\js{e3} \sep {}
          (\E{F_2},\fscopep)\pointsto\Listb
     \end{array}\right)\Gap\\
 \tr {R_1} {\js{e2}} {R_2 \sep \ls\doteq\List_3\sep\rv\doteq \E{V_1}}\quad
 R_2 = S_2\sep \getValue(\List_4,\E{V_1},\E{V_2})\\[\gap]
 R_3 = \left(\begin{array}{l} 
            R_2 \sep \exists\V{L}\st \ls\doteq\V{L}\cons\Listb \sep (\V{L},\E{X})\pointsto \E{V_2} \sep\\
            (\V{L},\thisp)\pointsto\E{T} \sep {} \\
            (\V{L},\protop)\pointsto \nil  \sep \defs(\E{X},\V{L},\js{e3})  \sep \\
            \newobj(\V{L}, \protop,\thisp, \E{X}, \vardecls(\E{X},\V{L},\js{e3}))
      \end{array}\right)\\[\gap]
 \tr {R_3} {\js{e3}} {\exists \V{L}\st Q \sep \ls\doteq\V{L}\cons\Listb}\qquad
 \ls\not\in\fv(Q , R_2)}
{\tr P {\js{e1(e2)}} {\exists \V{L}\st Q \sep\ls\doteq\List_3}}
\\[\gap]




%
% Logics
%

\staterule{(Frame)}
{\tr P {\js{e}} Q}
{\tr {P\sep R} {\js{e}} {Q\sep R}}
~~
%
\staterule{(Consequence)}
{\tr {P_1} {\js{e}} {Q_1}\quad
 P\implies P_1\quad Q_1 \implies Q}
{\tr P {\js{e}} Q}
\\[\gap]


\staterule{(Elimination)}
{\tr P {\js{e}} Q}
{\tr {\exists\V X\st P}{\js{e}}{\exists\V X\st Q}}
\rsep
%
\staterule{(Disjunction)}
{ \tr {P_1} {\js{e}} {Q_1} \qquad
 \tr {P_2} {\js{e}} {Q_2}}
{\tr {P_1\lor P_2} {\js{e}} {Q_1\lor Q_2}}
%
\end{display}

Although most of the rules correspond closely to their operational  counterparts, some rules deserve further comment.
%
Rule (Definition) shows the use of the reserved variable $\rv$ to record the result of an expression.
%
Rule (Variable) shows the use of $\sepish$ to express the overlapping footprints of predicates $\scope$ and $\getValue$.
%
Rule (Assign Global) shows the use of $\none$ to assert that certain known memory cells are available for allocation.
%
Rule (Function Call) describes JavaScript's dynamic functions but does not support higher order reasoning.
%
%Note that the postcondition for evaluating the function \js{e1} assumes that it is possible to determine that the store contains exactly the function body \js{e3}, preventing a fully-compositional analysis of code involving stored functions.
%
%Rule (While) is an adaptation of the Hoare rule for while-loops.
%
Rule (Frame) does not have the usual side condition because JavaScript stores all its program variables on the heap, so any variable modified by an expression is necessarily contained entirely within the footprint of the expression.
%
% Rule (Consequence) uses logical implication of assertions, which can be tricky to automatize.
%
Rules (Consequence), (Elimination) and (Disjunction) are standard.



\subsection{Soundness}\label{sec:soundness}
%
We show that our inference rules are sound with respect to the operational 
semantics of Section~\ref{sec:semantics}. When proving the soundness
of any system involving the frame rule, it is usual to first show the
locality of the programming language, and use that property to show
the soundness of the frame rule~\cite{DBLP:conf/csl/OHearnRY01}.
Unfortunately, many JavaScript statements are not local according to
this standard definition. We therefore use the recently introduced
notion of weak locality from Smith's thesis~\cite{gdsThesis}.

\begin{defn}[Soundness of a Hoare triple]
        \label{defn:soundness}
A Hoare triple $\{P\}\js{e}\{Q\}$ is sound if, for all abstract heaps $h$,
scope chains $L$ and environments $\env$, it satisfies the following two properties:\\[\gap]
%
$\begin{array}{l}
\textit{Fault Avoidance}: h,L,(\env\setminus\rv) \satisfies P \implies \heval{h},L,\js e  \;\;  \not\!\!\!\!\!\!\levalsto \fault\\[\gap]
\textit{Safety}: \forall H,r\st~h,L,(\env\setminus\rv) \satisfies P \land \heval{h},L,\js e \levalsto H,r \\
~~~~~~~~~~~~\implies~\exists h' \st H=\heval{h'} \land h',L,[\env|\rv\takes r] \satisfies Q.
\end{array}$
\end{defn}
%
%% Notice that we are not limited to reasoning about only well-formed heaps. While
%% it is the case that all JavaScript programs maintain the well-formedness of the
%% heap, we are also able to reason about programs that run on partial-heaps,
%% which may not be well-formed. 

%
\begin{thm}[Soundness]
        All derivable Hoare triples $\{P\}\js{e}\{Q\}$ are sound according to Definition~\ref{defn:soundness}.
\end{thm}
%
The proof (\ifshort{reported in~\cite{proofs}}\iflong{given in Appendix~\ref{sec:soundness}}) involves showing that the
predicates used by the Hoare rules correspond to the auxiliary
functions used by the semantics, showing that all JavaScript
expressions are weakly local with respect to their preconditions,  and
finally showing that all our inference rules are sound.









\section{Layers of Abstraction}\label{sec:examples}

As mentioned in Section~\ref{sec:reasoning}, using the rules given so
far, reasoning about JavaScript program involves 
detail that most programmers need never consider. Most of the time,
programmers will work at a higher level of abstraction, for example,
treating the emulated variable store as if it were a regular variable
store. This is a good practice as  long as the abstraction holds.
However, if the program happens to come across a corner case that
breaks the abstraction, its resulting behaviour can appear almost
inexplicable. This may be a particular problem when writing library
code, since the programmer has no control over the programming
discipline of the client who uses the library. In this section,  we
introduce several  explicit abstraction formalisms. Many alternatives 
are possible, but those presented here are enough to demonstrate the
concept and reason about some interesting programs. We are able to use
these formalisms to reason at a comfortable, high-level way 
about many well-behaved programs. Crucially, we know exactly what the
boundaries of these layers of abstraction are, so we can ensure that
our programs remain safely within the abstraction. If we wish, we can
even choose to temporarily break an abstraction, execute some
particularly subtle low-level code, re-establish the abstraction and then 
continue to work at the high level.


\subsection{Layer 1: Exploring the Scope List}
\label{sec:layer1}

Central to reasoning about JavaScript variables are the \scope and
\proto predicates. The first abstraction layer consists of alternative
versions of these predicates which make reasoning about certain common
cases simpler. The \scopepr predicate unrolls from the end (the most
global end) of the scope rather than from the beginning (the local
end) which makes modifying a variable easier to specify. It makes use
of \notscope which says that a variable does not exist in a particular
partial scope. The \notscopeg predicate does the same, but excludes
$\lgo$ from its specification, in order to make reasoning about global
variable instantiation simpler. We give several useful triples about
variable assignment. In~\ifshort{\cite{proofs}}\iflong{Appendix~\ref{sec:abslayer1}},  we prove these triples by using  $\scopepr$  and showing the equivalence of $\scope$ and
$\scopepr$.

\newpage
\begin{display}{Layer 1 Predicates.}
$\begin{array}{l}
        \scopepr({\List},\E{Ls}',\E{Var},\nil) \triangleq
        \notscope({\List},\E{Ls}',\E{Var},\nil)\\
        \scopepr({\Lista}{\append}({\Listb}:{\emptylist}),\E{Ls}',\E{Var},\E{L})  \triangleq \\\vspace{0.5em}
        \quad \notscope({\Lista},\E{Ls}',\E{Var},\E{L}) \sep 
        \exists\V{L2}\st\proto({\Listb},\E{L},\E{Var},\E{L2}) \sep \V{L2}\not\doteq\nil \\

        \notscope({\emptylist},\E{L}':\E{Ls}',\_,\E{L}')  \triangleq \lemp \\
        \notscope({\Listb}:{\List},\E{L}':\E{Ls}',\E{Var},\E{End}) \triangleq %\\\vspace{0.5em}
        %\qquad
        \proto({\Listb},\E{L}',\E{Var},\nil) \sepish 
                \notscope({\List},\E{Ls}',\E{Var},\E{End})\\

        \notscopeg({\emptylist},\E{L}':\E{Ls}',\_,\E{L}')  \triangleq \lemp \\
        \notscopeg({\Listb}:{\List},\E{L}':\E{Ls}',\E{Var},\E{End}) \triangleq %\\\vspace{0.5em}
        %\qquad
        \protog({\Listb},\E{L}',\E{Var},\nil) \sepish \notscopeg({\List},\E{Ls}',\E{Var},\E{End})\\

        \protog({\emptylist},\nil,\_,\nil) \triangleq \lemp\\
        \protog({\emptylist},\lgo,\_,\nil) \triangleq \lemp\\
        \protog([\E{L}'],\E{L}',\E{Var},\E{L}') \triangleq %\\\vspace{0.5em}
        \exists\LVAL\st(\E{L}',\E{Var})\pointsto \LVAL \sep \LVAL\not\doteq\none\sep\E{L}'\not\doteq\lgo\\
        \protog((\E{L}':{\List}),\E{L}',\E{Var},\E{L}) \triangleq
        %\begin{array}[t]{l}
                \exists\V{N}\st
                (\E{L}',\E{Var})\pointsto\none \sep {} \\
          \qquad      (\E{L}',\protop)\pointsto \V{N} \sep
                \protog({\List},\V{N},\E{Var},\E{L})\sep\E{L}'\not\doteq\lgo
        %\end{array}\\
\end{array}$
\end{display}


These predicates give us much more flexibility to reason about
JavaScript variables found in various places in the emulated variable store. Even at this quite low level, it is possible to prove  general specifications about programs with many corner cases. A good example of this sort of reasoning is
simple assignment statements. We prove the following general triples about
simple assignments. The first three triples deal with the assignment of a
constant to a variable, in the cases of variable initialisation, variable
override, and variable overwrite respectively. The fourth triple deals with
assigning the value of one variable to another. All four are proved
sound
in~\ifshort{\cite{proofs}}\iflong{Appendices~\ref{sec:constantvar} and
  \ref{sec:assignvarvar}}.


\begin{display}{Simple assignments.}
\nohrule
{P = \scope(\E{L_1}{\append}((\lgo\cons\E{L_2})\cons\E{L_3}),\ls,\js{x},\nil)\\[\gap]
 Q = \left(\begin{array}{c}     \exists\V{L_1'},\V{L_3'},\V{Ls}',\V{G}\st~~
                                \notscopeg(\V{L_1'},\ls,\js{x},\lgo) \sepish\\ \proto(\E{L_2},\V{G},\js{x},\nil) \sepish {}
                                \notscopeg(\V{L_3'},\V{Ls}',\js{x},\nil) \sep {}                                (\lgo,\js{x})\pointsto \js{v} \sep\\
 (\lgo,\protop)\pointsto\V{G} \sep \ls\doteq \_{\append}(\lgo \cons \V{Ls}') \sep {}
                                \rv\doteq  \js{v} \end{array}\right)}
{\tr{P}{\js{x = v}}{Q}}
\\[\gap]


\nohrule
{P = \scope(\E{L_1}{\append}[\E{L}\cons\E{L_2}]),\ls,\js{x},\E{L}) \sepish (\E{L},\js{x})\pointsto \none\sepish
                               \getValue(\E{L}\cons\E{L_2},\E{L}\sv\js{x},\E{V})\\[\gap]
 Q =                         \left(\begin{array}{l}
                                \exists\V{L'}\st
                                \notscope(\E{L_1},\ls,\js{x},\E{L})  \sep {}
                                (\E{L},\js{x})\pointsto \js{v} \sep  (\E{L},\protop)\pointsto\V{PR} \sep{}\\
                                \proto(\E{L_2},\V{PR},\js{x},\V{L'}) \sepish (\V{L'},\js{x})\pointsto\E{V}
                                \sep\rv\doteq \js{v}
                        \end{array}\right)}
{\tr P{\js{x = v}}Q}
\\[\gap]

                
\nohrule
{P = \scope(\E{L_1}{\append}[[\E{L}]],\ls,\js{x},\E{L}) \sepish (\E{L},\js{x})\pointsto\E{V}\sep\E{V}\not\doteq\none\\
 Q =                        
                                \notscope(\E{L_1},\ls,\js{x},\E{L}) \sep {}
                                (\E{L},\js{x})\pointsto \js{v} \sep\rv\doteq  \js{v} 
                        }
{\tr P{\js{x = v}}Q}
\\[\gap]


\nohrule
{P = \left(\begin{array}{l}
                                \scope(\Lista,\ls,\js{y},\E{L}_y)  \sepish \getValue(\Listb,\E{L}_y\sv\js{y},\E{V}_y)  \sepish{}\\
                                \scope(\E{L_1}{\append}[[\E{L}]],\ls,\js{x},\E{L}) \sepish {}
                                (\E{L},\js{x})\pointsto\E{V}\sep\E{V}\not\doteq\none 
                        \end{array}\right)\Gap\\[\gap]
                         Q =  \scope(\Lista,\ls,\js{y},\E{L}_y)  \sepish \notscope(\E{L_1},\ls,\js{x},\E{L}) \sep{} (\E{L},\js{x})\pointsto \E{V}_y \sep\rv\doteq  \E{V}_y}
{\tr P{\js{x = y}}Q}
%
\end{display}

Compared to the (Assign Global) and (Assign Local)  inference rules, these triples provide an explicit account of the footprint of the assignment, and more clearly describe the destructive effects of assignment. Yet, they are still quite  complex and are difficult to
compose.  It would be useful to ignore some information about the
exact structure of the variable store, while retaining the information about  the mappings of variable names to values. To do this, we introduce a new $\store$ predicate.



\subsection{Layer 2: a Simple Abstract Variable Store}
\label{sec:examples:abstractvarstore}
\label{sec:examples:varscope}
\label{sec:examples:with}



The predicates below provide a convenient abstraction for an emulated variable store.
\begin{display}{The \store Predicate.}
$\begin{array}{l}
\store_{\E{L}}(\E{X_1}\dots \E{X_n} | \E{X_1'}\cons\E{V_1} \dots \E{X_m'}\cons\E{V_m}) \triangleq \\
~~\begin{array}{l}
        \exists \Lista\,\dots,\List_n,\Lista',\dots,\List_m',\Lista'',\dots,\List_m''  \st~~
        \thischain(\E{L}) \sepish{}\\
        \sepish_{i\in 1..n}~\notscope(\List_i,\E{L},\E{X_i},\nil) \quad\sepish (\lgo,\E{X_i})\pointsto\none \\
        \sepish_{j\in 1..m}~\scope(\List_j',\E{L},\E{X_j'},\E{L}_j)\quad
        \sepish_{k\in 1..m}~\getValue(\List_k'',\E{L}_k\sv\E{X_k'},\E{V_k}) \\        
\end{array}
\end{array}$
\\[\gap]
$\begin{array}{lll}
        \thischain({\emptylist}) & \triangleq & \lemp \\
        \thischain(\E{L}:\E{Ls}') & \triangleq & (\E{L},\thisp)\pointsto\_ \sep {}
                        %&&(\E{L},\scopep)\pointsto \E{L}'\sep{}\\
                        \thischain(\E{Ls}')
\end{array}$
%\]
\end{display}

The assertion $\store_{\V{LS}}(\js{a},\js{b}|\js{x}:1,\js{y}:2)$
describes a heap emulating a variable store given by scope chain $\V{LS}$,  in which the variables
\js{a} and \js{b} are \emph{not} present and  the
variables \js{x} and \js{y} take the values $1$ and $2$ respectively.
The body of the predicate uses the $\notscope$ predicate to assert the
absence of \js{a} and \js{b}, and the $\scope$ and $\getValue$
predicates to assert the presence and values of \js{x} and \js{y}.
This information about the exact structure of the emulated store and
the locations of $\js{x}$ and $\js{y}$ is hidden from the programmer,
since at this level of abstraction it should be of no concern. The
$\thischain$ part of the body of the predicate ensures that the
$\store$ predicate always encompasses enough resource to call any
function that is stored in the emulated variable store.
 The variables \js{a} and \js{b}
 can be re-ordered, as can the variables \js{x} and \js{y}. To
facilitate program reasoning at this level of abstraction we provide several inference rules,
all of which are derived  (using previous levels of abstraction) in~\ifshort{\cite{proofs}}\iflong{Appendix~\ref{sec:varscope}}.
We start by giving rules for  initialising, overwriting and
overriding a variable with a constant and with another variable.


\newcommand{\rulepat}{\ensuremath{\mathfrak{R}}}

\begin{display}{Writing to a \store.}
%
Let $Q_1 = \store_\ls(\LVAR_1\dots \LVAR_n | \js{x}\cons v,\LVAR'_1\cons \LVAL_1 \dots \LVAR'_m\cons \LVAL_m)$.\\
Let $Q_2 = \store_\ls(
                        \LVAR_1\dots \LVAR_n | 
                        \js{x}\cons \LVAL,\js{y}\cons \LVAL,\LVAR'_1\cons \LVAL_1 \dots \LVAR'_m\cons \LVAL_m)
$.                \\[\gap] 

% Init with constant
\nohrule
{\js{x}\neq\LVAR_1 \neq \dots \neq \LVAR_n \neq \LVAR'_1 \neq \dots \neq \LVAR'_m \\
 P = \store_\ls(\js{x},\LVAR_1\dots \LVAR_n | \LVAR'_1\cons \LVAL_1 \dots \LVAR'_m\cons \LVAL_m)}
{\tr P {\js{x = v}}{Q_1
                {}\sep \true \sep\rv\doteq v}}
\\[\gap]


%Overwrite/override with constant
\nohrule
{\js{x}\neq\LVAR_1 \neq \dots \neq \LVAR_n \neq \LVAR'_1 \neq \dots \neq \LVAR'_m \\
P = \store_\ls(\LVAR_1\dots \LVAR_n | \js{x}\cons \LVAL,\LVAR'_1\cons \LVAL_1 \dots \LVAR'_m\cons \LVAL_m)}
{\tr{P}{        \js{x = v}}{Q_1
                {}\sep \true \sep\rv\doteq v}}
\\[\gap]


% Init with variable
\nohrule
{       \js{x}\neq\js{y}\neq\LVAR_1 \neq \dots \neq \LVAR_n \neq \LVAR'_1 \neq \dots \neq \LVAR'_m \\
P = \store_\ls(\js{x},\LVAR_1\dots \LVAR_n | \js{y}\cons \LVAL,\LVAR'_1\cons \LVAL_1 \dots \LVAR'_m\cons \LVAL_m)}
{\tr{P}{\js{x = y}}{Q_2{}\sep \true \sep\rv\doteq \LVAL}}
\\[\gap]



% Overwrite/override with variable
\nohrule
{        \js{x}\neq\js{y}\neq\LVAR_1 \neq \dots \neq \LVAR_n \neq \LVAR'_1 \neq \dots \neq \LVAR'_m \\
P = \store_\ls(\LVAR_1\dots \LVAR_n | \js{x}\cons \LVAL',\js{y}\cons \LVAL,\LVAR'_1\cons \LVAL_1 \dots \LVAR'_m\cons \LVAL_m)}
{\tr{P}{\js{x = y}}{Q_2
                {}\sep \true \sep\rv\doteq \LVAL}}
\end{display}

Notice that each of these rules has a postcondition which includes
$\true$. This is because initialising or overriding a variable may
render a portion of the emulated variable store superfluous. For
example, consider the overriding assignment \js{x = 1} in the store
given in Figure~\ref{fig:variableStore}. In this case the cell
$(l,\js{x})$ has become surplus to requirements. In separation logic
it is not sound to simply forget about these cells, so we hide them in
the general assertion $\true$.

One limitation of this level of abstraction is that the abstraction only covers
a static (and unknown)  scope chain. If we call a function
which adds a new cell to the scope chain, then the rules
above are insufficient to reason about our program. The following rules allow
us to reason at this level of abstraction about a program which alters a global
variable from within a new local scope frame.

\begin{display}{Writing to a \store from a deeper scope.}
%\begin{lemma}[Variable initialisation from a deeper scope]
%
Let $Q = \store_\V{LS}\left(
                        \begin{array}{l}
                                \LVAR_1,\dots,\LVAR_n | 
                                \js{x}:\LVAL',\LVAR'_1:\LVAL'_1,\dots,\LVAR'_m:\LVAL'_m
                        \end{array}\right)$ and \\
$S =(\V{L},\protop)\pointsto \nil \sep (\V{L},\js{x})\pointsto\none
                        {} \sep (\V{L},\js{y})\pointsto\LVAL' \sep
                        \ls\doteq \V{L}:\V{LS}$.\\[\gap]

\nohrule
{\js{x}\neq\js{y}\neq\LVAR_1 \neq \dots \neq \LVAR_n \neq \LVAR'_1 \neq \dots \neq \LVAR'_m\\
P_1 = \store_\V{LS}\left(\begin{array}{l}
                                \js{x},\LVAR_1,\dots,\LVAR_n |
                                \LVAR'_1:\LVAL'_1,\dots,\LVAR'_m:\LVAL'_m
                        \end{array}\right)}
{\tr {P_1\sep S}{\js{x=y}}{Q\sep S\sep \true}}
\\[\gap]


\nohrule
{\js{x}\neq\js{y}\neq\LVAR_1 \neq \dots \neq \LVAR_n \neq \LVAR'_1 \neq \dots \neq \LVAR'_m\\
P_2 = \store_\V{LS}\left(\begin{array}{l}
                                \LVAR_1,\dots,\LVAR_n |
                                \js{x}:\LVAL,\LVAR'_1:\LVAL'_1,\dots,\LVAR'_m:\LVAL'_m
                        \end{array}\right)}
{\tr {P_2\sep S}{\js{x=y}}{Q\sep S\sep \true}}
%
\end{display}

Finally, we provide two rules for a more general case of store interaction.
In these cases, the value which is to be written to the variable is the result
of computing some arbitrary expression. These specifications are therefore necessarily
more complicated, since they must incorporate some features of sequential
composition. We insist that whatever the expression does, it must not
alter the variable store in a way that changes the visible values of the variables.

\begin{display}{Destructive \store Initialisation.}
%
\nohrule
{\js{x}\neq\LVAR_1 \neq \dots \neq \LVAR_n \neq \LVAR'_1 \neq \dots \neq \LVAR'_m \\
R= \store_\ls(\js{x},\LVAR_1\dots \LVAR_n | \LVAR'_1\cons \LVAL_1 \dots \LVAR'_m\cons \LVAL_m)\\
 \tr {R\sep P}{\js{e}}{R\sepish \getValue(\E{LS},\LVAL',\LVAL)\sep Q \sep\rv\doteq \LVAL'
                }\qquad \rv\not\in\fv(Q)\\[\gap]        
S =         
        \left(\begin{array}{l}
                \store_\ls\left(\begin{array}{l}
                        \LVAR_1\dots \LVAR_n | 
                        \js{x}\cons \LVAL,\LVAR'_1\cons \LVAL_1 \dots \LVAR'_m\cons \LVAL_m
                \end{array}\right) \\
                {}\sepish \getValue(\E{LS},\LVAL',\LVAL) \sep Q \sep \true \sep\rv\doteq \LVAL
        \end{array}\right)
}{
\tr{R\sep P}{\js{x = e}}{S}}
\\[\gap]


\nohrule
{\js{x}\neq\LVAR_1 \neq \dots \neq \LVAR_n \neq \LVAR'_1 \neq \dots \neq \LVAR'_m \\
 R = \store_{\E{L}\cons \E{SLS}}(\js{x},\LVAR_1\dots \LVAR_n | \LVAR'_1\cons \LVAL_1 \dots \LVAR'_m\cons \LVAL_m)\sepish {} \notscope(\E{Nsls},\ls,\js{x},\E{L})\\
 \tr{R
                }{
                \js{e}}{R\sepish
                        \getValue(\E{LS},\LVAL',\LVAL)\sep Q \sep\rv\doteq \LVAL'
                }\qquad
        \rv\not\in\fv(Q)\\[\gap]
        S = \left(\begin{array}{l}
                \store_{\E{L}\cons \E{SLS}}\left(\begin{array}{l}
                        \LVAR_1\dots \LVAR_n | 
                        \js{x}\cons \LVAL,\LVAR'_1\cons \LVAL_1 \dots \LVAR'_m\cons \LVAL_m
                \end{array}\right) \sepish {}\\
                \notscope(\E{Nsls},\ls,\js{x},\E{L}) \sepish 
                \getValue(\E{LS},\LVAL',\LVAL) \sep Q \sep \true \sep\rv\doteq \LVAL
        \end{array}\right)
}
{\tr{R \sep P}{\js{x = e}}{S}}
\end{display}

It may seem surprising that we only provide derived rules for destructive variable
initialisation, and not for destructive variable \emph{update}. This is because
such an update rule %following the pattern of the rules above
 would be unsound. 
 The destructive expression might have the side effect of overriding the variable we wish to update.
This serves to further demonstrate the need for the low-level reasoning
introduced earlier in this paper. We can use high-level abstractions such as
the \store predicate where they are sound, but if we wish to reason about
programs with side-effecting expressions, we will sometimes be forced to reason
at a lower level.

%\subsubsection{The Scope of a Variable}
%\label{sec:examples:varscope}

\stitle{The scope of a variable}
%
The \store abstraction gives us the tools we need to easily reason about programs with large numbers of variables. For example, consider the program from Section~\ref{sec:simplereasoningcomplexlanguage}:

\begin{verbatim}
x = null; y = null; z = null;
f = function(w){x=v;v=4;var v;y=v;};
v = 5; f(null); z = v;
\end{verbatim}

With the \store predicate and the results  given above, reasoning about this
program is simple.  A proof of the main program is shown in
Figure~\ref{fig:varscope2a}. It relies on a simple proof of the
function body summarised here and given in full in~\ifshort{\cite{proofs}}\iflong{Appendix~\ref{sec:varscope}}.


\begin{figure}
%        \scriptsize
\begin{center}
        \[\begin{array}{l}
                \left\{\begin{array}{l}
                        \store_\ls(\js{x},\js{y},\js{z},\js{f},\js{v}|) 
                \end{array}\right\}\\
                \js{x = }\nil\js{;} \js{y = }\nil\js{;} \js{z = }\nil\js{;}\\
                \left\{\begin{array}{l}
                        \store_\ls(\js{f},\js{v}|\js{x}:\nil,\js{y}:\nil,\js{z}:\nil) \sep\true
                \end{array}\right\}\\
        \js{f = function(w)\{x=v ; v=4 ; var v ; y=v\};}\\
                \left\{\begin{array}{l}
                        \exists\V{L}\st
                        \store_\ls(\js{v}|\js{x}:\nil,\js{y}:\nil,\js{z}:\nil,\js{f}:\V{L}) \sep {}\\
                        (\V{L},\bodyp)\pointsto \lambda \js{w}.\{\dots\}\sep{}\\
                        (\V{L},\fscopep)\pointsto \ls \sep \true
                \end{array}\right\}\\
        \js{v = 5;}\\
                \left\{\begin{array}{l}
                        %\exists\V{L}\st
                        \store_\ls(|\js{x}:\nil,\js{y}:\nil,\js{z}:\nil,\js{f}:\V{L},\js{v}:5) \sep {}\\
                        (\V{L},\bodyp)\pointsto \lambda \js{w}.\{\dots\}\sep{}\\
                        (\V{L},\fscopep)\pointsto \ls  \sep\true
                \end{array}\right\}\\
        \js{f(}\nil\js{);}\\
                \left\{\begin{array}{l}
                        \exists %\V{L}, 
                        \V{L}' \st 
                        \store_\ls(|\js{x}:\und,\js{y}:4,\js{z}:\nil,\js{f}:\V{L},\js{v}:5)\sep{}\\
                        %(\lop,\js{x})\pointsto\none \sepish(\lop,\js{y})\pointsto\none\sep{}\\
                        \newobj(\V{L}',\protop,\thisp,\js{w},\js{v})\sep (\V{L}',\protop)\pointsto \nil \sep{}\\
                        (\V{L}',\js{w})\pointsto\nil \sep (\V{L}',\js{v})\pointsto 4\sep\true\\
                \end{array}\right\}% \qquad [\text{from Figure~\ref{fig:functionbody}}]
                \\\text{[Frame]}\\
                \left\{\begin{array}{l}
                        %\exists\V{L}\st
                        \store_\ls(|\js{x}:\und,\js{y}:4,\js{z}:\nil,\js{f}:\V{L},\js{v}:5)\\
                \end{array}\right\} %\; \text{\scriptsize[Var-Elim/Frame]}
                \\
        \js{z = v;}\\
                \left\{\begin{array}{l}
                        %\exists\V{L}\st
                        \store_\ls(|\js{x}:\und,\js{y}:4,\js{z}:5,\js{f}:\V{L},\js{v}:5)\sep\true\\
                \end{array}\right\} \\\text{[Frame]}\\
                \left\{\begin{array}{l}
                        %\exists\V{L}, \V{L}' \st (
                        \store_\ls(|\js{x}:\und,\js{y}:4,\js{z}:5,\js{f}:\V{L},\js{v}:5)\sep{}\\
                        %(\lop,\js{x})\pointsto\none \sepish(\lop,\js{y})\pointsto\none\sep{}\\
                        \newobj(\V{L}',\protop,\thisp,\js{w},\js{v})\sep (\V{L}',\protop)\pointsto \nil \sep{}\\
                        (\V{L}',\js{w})\pointsto\nil \sep (\V{L}',\js{v})\pointsto 4\sep\true\\
                \end{array}\right\} %\qquad [Var-Elim/Frame]
                \\\text{[Cons/Var Elim]}\\
                \left\{\begin{array}{l}
                        \exists\V{L}\st
                        \store_\ls(|\js{x}:\und,\js{y}:4,\js{z}:5,\js{f}:\V{L},\js{v}:5)\sep\true\\
                \end{array}\right\} 
        \end{array}\]
        \hrule
                \[\begin{array}{ll}
                \left\{\begin{array}{l}
                        \exists\V{L}',\V{LS}\st \ls\doteq\V{L}':\V{LS} \sep {}\\
                        \store_\V{LS}(|\js{x}:\nil,\js{y}:\nil,\js{z}:\nil,\js{f}:\V{L},\js{v}:5) \sep {}\\
                        (\V{L},\bodyp)\pointsto \lambda \js{w}.\{\dots\}\sep{}
                        (\V{L},\fscopep)\pointsto \V{LS}  \sep {} \\
                        \newobj(\V{L}',\protop,\thisp,\js{w},\js{v})\sep{}
                        (\V{L}',\protop)\pointsto \nil \sep{}\\
                        (\V{L}',\js{w})\pointsto\nil \sep (\V{L}',\js{v})\pointsto\und\sep (\V{L}',\thisp)\pointsto\_\sep\true
                \end{array}\right\}\\\\\js{x=v;v=4;var v;y=v;}\\
                \left\{\begin{array}{l}
                        \exists\V{L}',\V{LS}\st \ls\doteq\V{L}':\V{LS} \sep {}\\
                        \store_\V{LS}(|\js{x}:\und,\js{y}:4,\js{z}:\nil,\js{f}:\V{L},\js{v}:5)\sep{}\\
                        %(\lop,\js{x})\pointsto\none \sepish(\lop,\js{y})\pointsto\none\sep{}\\
                        \newobj(\V{L}',\protop,\thisp,\js{w},\js{v})\sep (\V{L}',\protop)\pointsto \nil \sep{}\\
                        (\V{L}',\js{w})\pointsto\nil \sep (\V{L}',\js{v})\pointsto 4\sep\true\\
                \end{array}\right\}\\%& 
                \end{array}\]

\end{center}
\caption{Reasoning about variable scopes.}
\label{fig:varscope2a}
\end{figure}


%\subsubsection{Reasoning About \js{with}}
%\label{sec:examples:with}

\stitle{Reasoning about \js{with}}
%
This level of abstraction also leads itself to reasoning about the notorious \js{with} statement. Consider the \js{with} example from Section~\ref{sec:simplereasoningcomplexlanguage} (where \js f implicitly returns \js b):
%
\begin{verbatim}a = {b:1}; with (a){f=function(c){b}};
a = {b:2}; f(null)
\end{verbatim}
%
This program demonstrates the importance of modelling \js{with}
correctly. Recall that when correctly modelled, the closure of the
function \js{f} will refer to the object \js{\{b:1\}}, which was
pointed to by the variable \js{a} at the time that \js{f} was defined.
However, even though the variable \js{a} is changed to point to a
different object before \js{f(null)} is called, the closure continues
to point to the object \js{\{b:1\}}. Thus the program normally returns
the value 1, not 2. Recall also that we must be careful with the
\js{f} field of the object $\lop$.

We can reason about this program using the $\store$ predicate. The proof is in Figure~\ref{fig:withproof}.
\begin{figure}
%\scriptsize
\[
\begin{array}{l}
        \text{Let }P = (\V{L},\js{b})\pointsto 1 \sep (\V{L},\protop)\pointsto\lop \sep \true \\[1mm]
        \left\{\begin{array}{l}
                \store_{\ls}(\js{a},\js{f}|) \sepish(\lop,\js{f})\pointsto\none \sepish(\lop,\protop)\pointsto\nil
        \end{array}\right\}\\
        \js{a = \{b:1\};}\\
        \left\{\begin{array}{l}
                \exists\V{L}\st\store_{\ls}(\js{f}|\js{a}:\V{L})\sepish(\lop,\js{f})\pointsto\none \sepish{}\\(\lop,\protop)\pointsto\nil\sep 
                (\V{L},\js{f})\pointsto\none \sep P
        \end{array}\right\}\\
        \js{with (a)\{}\\
                \qquad\left\{\begin{array}{l}
                        \exists\V{LS},\V{L}\st\ls\doteq\V{L}:\V{LS} \sep {} \\
                        \store_{\V{LS}}(\js{f}|\js{a}:\V{L})\sepish(\lop,\js{f})\pointsto\none \sepish{}\\(\lop,\protop)\pointsto\nil\sep 
                        (\V{L},\js{f})\pointsto\none\sep P
                \end{array}\right\}\\
                \qquad \js{f=function(c)\{b\}}\\
                \qquad\left\{\begin{array}{l}
                        \exists\V{LS},\V{L},\V{F}\st\ls\doteq\V{L}:\V{LS} \sep {} \\
                        \store_{\V{LS}}(|\js{a}:\V{L},\js{f}:\V{F})\sepish(\lop,\js{f})\pointsto\none\sepish{}\\(\lop,\protop)\pointsto\nil \sep 
                        (\V{L},\js{f})\pointsto\none \sep {}\\
                        (\V{F},\bodyp)\pointsto \lambda\js{c}.\{\js{b}\} \sep
                        (\V{F},\fscopep)\pointsto \V{L}:\V{LS}\sep P
                \end{array}\right\}\\
        \js{\};}\\
        \left\{\begin{array}{l}
                \exists\V{LS},\V{L},\V{F}\st\ls\doteq\V{LS} \sep {} \\
                \store_{\V{LS}}(|\js{a}:\V{L},\js{f}:\V{F})\sepish(\lop,\js{f})\pointsto\none \sepish (\lop,\protop)\pointsto\nil\sep {} \\
                (\V{L},\js{f})\pointsto\none \sep 
                (\V{F},\bodyp)\pointsto \lambda\js{c}.\{\js{b}\} \sep
                (\V{F},\fscopep)\pointsto \V{L}:\V{LS} \sep P
        \end{array}\right\}\\
        \js{a = \{b:2\};}\\
        \left\{\begin{array}{l}
                \exists\V{LS},\V{L},\V{F},\V{L}'\st\ls\doteq\V{LS} \sep {} \\
                \store_{\V{LS}}(|\js{a}:\V{L}',\js{f}:\V{F})\sepish(\lop,\js{f})\pointsto\none\sepish(\lop,\protop)\pointsto\nil \sep {}\\
                (\V{L},\js{f})\pointsto\none \sep 
                (\V{L}',\js{b})\pointsto 2 \sep (\V{L}',\js{f})\pointsto\none \sep (\V{L}',\protop)\pointsto\lop \sep {}\\
                (\V{F},\bodyp)\pointsto \lambda\js{c}.\{\js{b}\} \sep
                (\V{F},\fscopep)\pointsto \V{L}:\V{LS} \sep P
        \end{array}\right\}\\
        \js{f(null)}\\
        \left\{\begin{array}{l}
                \exists\V{LS},\V{L},\V{F},\V{L}',\V{LOC}\st\ls\doteq\V{LS} \sep {} \\
                \store_{\V{LS}}(|\js{a}:\V{L}',\js{f}:\V{F})\sepish(\lop,\js{f})\pointsto\none\sepish (\lop,\protop)\pointsto\nil \sep {}\\
                (\V{L},\js{f})\pointsto\none \sep 
                (\V{L}',\js{b})\pointsto 2 \sep (\V{L}',\js{f})\pointsto\none \sep (\V{L}',\protop)\pointsto\lop \sep {}\\
                (\V{F},\bodyp)\pointsto \lambda\js{c}.\{\js{b}\} \sep
                (\V{F},\fscopep)\pointsto \V{L}:\V{LS} \sep {} \\
                (\V{LOC},\js{b})\pointsto\none \sep (\V{LOC},\protop)\pointsto\nil \sep P \sep \rv\doteq 1
        \end{array}\right\}\\
        \{ \rv\doteq 1 \sep \true \}
\end{array}
\]
\caption{Reasoning about \js{with}.}
\label{fig:withproof}
\end{figure}
This proof relies on a sub-proof for the invocation of the function \js{f(null)}, which culminates with the judgement $\tr P{\js b}{P\sep\rv\doteq 1}$, where $P$ is 

\[\left(\begin{array}{l}
                \exists\V{LS},\V{L},\V{F},\V{L}',\V{LOC}\st\ls\doteq\V{LOC}:\V{L}:\V{LS} \sep {} \\
                \store_{\V{LS}}(|\js{a}:\V{L}',\js{f}:\V{F})\sepish(\lop,\js{f})\pointsto\none\sepish{}\\(\lop,\protop)\pointsto\nil \sep \true \sep {}\\
                (\V{L},\js{b})\pointsto 1 \sep (\V{L},\js{f})\pointsto\none \sep (\V{L},\protop)\pointsto\lop \sep {}\\
                (\V{L}',\js{b})\pointsto 2 \sep (\V{L}',\js{f})\pointsto\none \sep (\V{L}',\protop)\pointsto\lop \sep {}\\
                (\V{F},\bodyp)\pointsto \lambda\js{c}.\{\js{b}\} \sep
                (\V{F},\fscopep)\pointsto \V{L}:\V{LS} \sep {} \\
                (\V{LOC},\js{b})\pointsto\none \sep (\V{LOC},\protop)\pointsto\nil
        \end{array}\right)\]



For space reasons, we only give the reasoning for  the case in which neither \js{a}
nor \js{f} are in the variable store. The same techniques in tandem with the
disjunction rule can be used to prove the general precondition.


In both the simple and the general case, we must constrain our precondition with
the assertion $(\lop,\js{f})\pointsto\none\sepish(\lop,\protop)\pointsto\nil$. The requirement for this term may seem
surprising. 
Consider running the above program in a state satisfying $\store_{\ls}(\js{a},\js{f}|) \sepish(\lop,\js{f})\pointsto 4$.
In this case, when the assignment to \js{f} is made, the function pointer will be written to the cell $(\V{L},\js{f})$, rather than into the global variable store. Since the variable store does not contain a function value for the variable \js{f}, the call to \js{f(null)} will cause the program to fault.
The problem is potentially even worse  if $(\lop,\js{f})$ contains a function pointer.
In this case, the call to $\js{f(null)}$ will not fault, but rather will execute
whatever code it finds. This kind of unpredictability
could lead to very confusing bugs. In the case of a system like Facebook
which attempts to isolate user-application code from host-page code, 
it could even lead to a security flaw.




\subsection{Layer 3: a Recursive Abstract Variable Store}
\label{sec:examples:recstore}

While reasoning using the $\store$ predicate, it is possible to handle large
numbers of assignments and small numbers of function calls. However, for large numbers of 
function calls, another abstraction is helpful.  
Consider an {\em  abstract}  variable store as a list
of lists of variable-value pairs, with the most local scope frame at the head
of the outer list. The list \mbox{$[[x=4], [y=5], [x=6,z=7]]$} represents a
store in which the global scope contains the variables x and z, an intermediate
scope adds the variable y, and the most local scope overrides the variable x.
The list elements of variable-value pairs can be represented in our logical
expression language as lists containing two elements. For readability, we use
the notation $x=v$ above.  
%We use lists of this form to define a recursive store predicate $\recstore$.
%
%\begin{defn}[The Recursive Store Predicate]
        We define the recursive store predicate $\recstore_{\E{L}}(\E{NoVars}, \E{Store})$ which describes an abstract variable store $\E{Store}$, which does not contain the variables in the list $\E{NoVars}$.% The predicate is defined as follows:
%\[
\begin{display}{The Recursive \recstore predicate.}
$        \recstore_{\E{L}}([\js{x1}',\cdots\js{xm}'], [[\js{x1}=\E{V}_1,\cdots,\js{xn}=\E{V}_n]]) \triangleq $\\
$        \qquad \store_{\E{L}}(\js{x1}',\cdots\js{xm}'|\js{x1}:\E{V}_1,\cdots,\js{xn}:\E{V}_n) $\\[\gap]
        
        
$        \recstore_{\E{L}:\E{LS}}([\js{x1}',\cdots\js{xm}'],([\js{x1}=\E{V}_1,\cdots,\js{xn}=\E{V}_n] : \E{Ls}')) \triangleq $\\
 $       ~~~~\begin{array}[t]{l}
                \recstore_{\E{LS}}([\js{x1}',\cdots\js{xm}'],\E{Ls}') \sep {} 
                (\E{L},\protop)\pointsto\nil \sep \E{L}\not\doteq \lgo \sep {} \\
                \sep_{i\in 1..m}~~(\E{L},\js{xi}')\pointsto\none 
                \sep_{j\in 1..n}~~(\E{L},\js{xj})\pointsto\E{V}_j \sep {}\\
                \nones_{\E{L}}([\js{x1},\cdots,\js{xn}] , \E{Ls}')
        \end{array}\Gap$\\[\gap]
        
        
$        \nones_{\E{L}}(\_ , {\emptylist}) \triangleq \lemp $\\[\gap]
        
        
$        \nones_{\E{L}}(\E{Ls},([\js{x1}=\E{V}_1,\cdots,\js{xn}=\E{V}_n] : \E{Ls}')) \triangleq $\\
$        \qquad\begin{array}[t]{l}
                \sep_{i\in 1..n}((\js{xi}\dotin\E{Ls}) \lor (\js{xi}\not\elem\E{Ls} \land (\E{L},\js{xi})\pointsto\none)) \sep {} \\
                
                \nones_{\E{L}}((\js{x1}:\cdots:\js{xn}:\E{Ls}), \E{Ls}')
        \end{array}$
%
\end{display}

Notice that \recstore uses the \store predicate to constrain the most global
scope frame in the abstract scope list, while being rather more restrictive
about more local scope frames. Local scope frames must be emulated by
JavaScript objects which contain fields for each variable defined at
that scope level. Furthermore, they must assert the absence of 
fields which are  not in the store (the \E{NoVars}), or which
would otherwise shadow a variable declared in a more global position
in the store. This is handled by the $\nones$ predicate. Notice that
local scope frames have a \nil prototype, and may not be the $\lgo$
object. These criteria are met by the emulated scope frames created by a normal
function call, and are not normally met by \js{with} calls. This makes this
abstraction ideal for reasoning about programs with many function calls and no
internal uses of the \js{with} statement. Notice, however, that we do not outlaw
\js{with} calls in the enclosing scope, represented here by a top-level use of
the \store predicate. This means that this abstraction will facilitate
reasoning about libraries which are written in a principled way, and which may
be called by unprincipled clients.

We provide several rules for reasoning at this level of abstraction in~\ifshort{\cite{proofs}}\iflong{Appendix~\ref{sec:varscope}}, the most interesting of which are destructive variable
initialisation and update.

%\begin{lemma}[Destructive Variable Initialisation]
%        \label{lem:recstore:destricvarinit}
\begin{display}{Destructive \recstore update.}
\nohrule
{R = \recstore_{\ls}((\js{x}:\E{EmpVars}) , (\E{Locals}{\append}[\E{Globals}]))\\
\tr {R\sep P}{\js{e}}{R\sep Q \sep \rv\doteq\E{Var}} \\
                \rv\not\in\fv(Q)\\
S = \recstore_{\ls}((\E{EmpVars}) , (\E{Locals}{\append}[\js{x}=\E{Var}:\E{Globals}])) 
        }{\tr{R\sep P}{\js{x = e}}{S\sep Q \sep \true}}
\\[\gap]


\nohrule
{R= \recstore_{\ls}((\E{Emps}) , (\E{Ls}{\append}((\js{x}=\E{Var}):\E{Curr}){\append}\E{Globs}))\\
\tr{R \sep \E{Globs}\not\doteq{\emptylist} \sep P}{\js{e}}{R
                                {}  \sep \E{Globs}\not\doteq{\emptylist}\sep Q \sep \rv\doteq\E{Var}'
                        }\\
                \rv\not\in\fv(Q)\\
                \forall \V{LS}\in\E{Ls} \st (\js{x}=\_)\not\in\V{LS}\\
                S = \recstore_{\ls}((\E{Emps}) , (\E{Ls}{\append}((\js{x}=\E{Var}'):\E{Curr}){\append}\E{Globs}))
        }
        {\tr {R \sep \E{Globs}\not\doteq{\emptylist} \sep P }{

                \js{x = e}}{S\sep \E{Globs}\not\doteq{\emptylist} \sep Q \sep \rv\doteq\E{Var}'
}         }
%
\end{display}

Notice that we may not safely
update variables in the global portion of the abstract variable store with the
results of potentially destructive expressions. This is for the same reason as
the corresponding restriction on the \store predicate in
Section~\ref{sec:examples:abstractvarstore};  there is a corner case which would
lead to very unexpected behaviour. At this level of abstraction however, we
have an advantage. We can be sure that the local abstract scope frames
were constructed in a more principled way, and so we are able to reason about
updating them with destructive expressions using
the second rule above. %Lemma~\ref{lem:recstore:destricvarupdate}.


%\subsubsection{Form Validation}

\stitle{Form validation}
%
Consider a web form with a number of mandatory text fields and a submit button.
If the button is ``disabled'' when the page loads, then an event handler on the
form can be used to regularly check if valid data has been entered in all the
fields before enabling the button. Let us assume that the programmer has
separated the concerns of parsing the web page and of validating the data. The
data validation function will be called with a single parameter: an object with
one field for each text value to check, a count of those text values, and
boolean toggle corresponding to whether the submit button should be disabled.
An example function which might perform the validation check is:
        \begin{verbatim}
checkForm = function(data) {
    data.buttonDisabled = 0;
    var checkField = function(text) {
        if(text == "") {data.buttonDisabled = 1;}}
    var i = 0;
    while(i < data.numEntries) {
        checkField(data[i]); i = i+1;}}        
\end{verbatim}
Notice that this code deals with variables in a principled way. It makes use
of no global variables, preferring instead to use function parameters and local
variables. The repeated work of the loop body is factored into a function which
could be expanded to provide extra functionality or used elsewhere with little
cost in readability. Using the \recstore abstraction %from
%Section~\ref{sec:examples:recstore}, 
it is straightforward to show that the function body
%of the \js{checkForm} function 
satisfies the specification given in
Figure~\ref{fig:spec:formvalid}.
\begin{figure}\scriptsize
        \[\begin{array}{c}
                \left\{\begin{array}{l}
                        \recstore_{\ls}\left(\left[\right],\left[\left[\begin{array}{l}\js{data}=\V{L},\\
                                        \js{checkField}=\undef,\\
                                        \js{i}=\undef
                                \end{array} \right],\left[\right]\right]\right) \sep {}\\
                        (\V{L},\js{numEntries})\pointsto\V{N} \sep (\V{L},\js{buttonDisabled}) \pointsto \_ \sep {}\\
                        (\V{L},0)\pointsto\V{TXT}_0 \sep \dots \sep (\V{L},\V{N})\pointsto\V{TXT}_{\V{N}}
                \end{array}\right\}\\
                \dots\js{checkForm}\dots\\
                \left\{\begin{array}{l}
                        \exists\V{L}'\st\recstore_{\ls}({\emptylist},[[\js{data}=\V{L},\js{checkField}=\V{L}',\js{i}=\V{N}],{\emptylist}]) \sep {}\\
                        (\V{L},\js{numEntries})\pointsto\V{N} \sep {}\\
                        (\V{L},0)\pointsto\V{TXT}_0 \sep \dots \sep (\V{L},\V{N})\pointsto\V{TXT}_{\V{N}} \sep{} \\
                        \left(\begin{array}{l}
                                \left(\begin{array}{l}
                                        \V{TXT}_0\not\doteq"" \sep \dots \sep \V{TXT}_{\V{N}}\not\doteq"" \sep {}\\
                                        (\V{L},\js{buttonDisabled}) \pointsto 0
                                \end{array}\right)\\
                                \lor (\V{L},\js{buttonDisabled})\pointsto 1
                        \end{array}\right)
                \end{array}\right\}
        \end{array}\]
        \caption{The specification of \js{checkForm}.}
        \label{fig:spec:formvalid}
\end{figure}

\iflong{\subsection{Layer 4: Custom Abstractions}

Many JavaScript programs make use of custom data structures in the heap. This
is exactly the sort of thing that separation logic is used for in other
programming languages, and is correspondingly simple here.

Consider the following program, for reversing a list. The program demonstrates
two important points about our reasoning. Firstly, it makes use of a custom
list structure, and is simplest to reason about with a similar abstraction (the
\tlist inductive predicate) in the logic. Secondly, it is written in a
particularly easy-to-understand style, making use of exclusively local
variables and avoiding function calls, \js{with} statements and other quirks of
the language which makes static analysis so challenging. Many well-written
programs are similarly easy to understand, and it is important that our
reasoning about such programs should be correspondingly easy.\\}
% Damned verbatim environment interacts poorly with \iflong. This is
% the hack to fix.
\begin{verbatim}revlist(l) {
        var x ;
        var y ;
        while (l != null) {
                y = l.next;
                l.next = x;
                x = l;
                l = y;
        }
        return x;
}
\end{verbatim}


\iflong{We can define a custom inductive predicate which checks if the data structure pointed to by a given reference is a list:

\[
\begin{array}{ll}
        \tlist(\V{X}) & \triangleq \tlistseg(\V{X},\nil)\\
        \tlistseg(\V{X},\V{X}) & \triangleq \lemp \\
        \tlistseg(\V{X},\V{Y}) & \triangleq \exists \V{Z} \st (\V{X},\text{next})\pointsto \V{Z} \sep \tlistseg(\V{Z},\V{Y})
\end{array}
\]

Using this \tlist predicate, we can prove the \js{revlist} program as in
Figure~\ref{fig:revlist}. Notice that at no point do we need to mention the
contents of the list. Since JavaScript is a dynamically typed language, the
revlist program will run on any data structure which has the appropriate
``next'' fields, regardless of the other data stored in the objects that
represent the list nodes. Our reasoning reflects this dynamicity, and allows us
to frame on any payload-data that we wish to reason about after the revlist
operation is complete. 

\begin{figure}
{\scriptsize
\[
\begin{array}{l}
        \js{revlist(l)}\{\\
        \left\{\begin{array}{l}
                (\ls,\js{l})\pointsto\V{L}\sep(\ls,\js{x})\pointsto\nil \sep (\ls,\js{y})\pointsto\nil\sep{}\\
                \text{list}(\V{L})
        \end{array}\right\}\\
        \quad \js{var x;}\\
        \quad \js{var y;}\\
        \left\{\begin{array}{l}
                \exists \V{L},\V{X},\V{Y}\st\\
                (\ls,\js{l})\pointsto\V{L}\sep(\ls,\js{x})\pointsto\V{X} \sep (\ls,\js{y})\pointsto\V{Y}\sep{}\\
                \V{X}\doteq\nil\sep\V{Y}\doteq\nil\sep{}\\
                \text{list}(\V{L}) \sep \text{list}(\V{X})
        \end{array}\right\}\\
        \quad \js{while (l != \nil) \{}\\
        \left\{\begin{array}{l}
                \exists \V{L},\V{X},\V{Y}\st\\
                (\ls,\js{l})\pointsto\V{L}\sep(\ls,\js{x})\pointsto\V{X} \sep (\ls,\js{y})\pointsto\V{Y}\sep{}\\
                \V{L}\not\doteq\nil\sep{}\\
                \text{list}(\V{L}) \sep \text{list}(\V{X})
        \end{array}\right\}\\
        \left\{\begin{array}{l}
                \exists \V{L},\V{X},\V{Y},\V{Z}\st\\
                (\ls,\js{l})\pointsto\V{L}\sep(\ls,\js{x})\pointsto\V{X} \sep (\ls,\js{y})\pointsto\V{Y}\sep{}\\
                \V{L}\not\doteq\nil\sep{}\\
                (\V{L},\text{next})\pointsto\V{Z}\text{list}(\V{Z}) \sep \text{list}(\V{X})
        \end{array}\right\}\\
        \qquad \js{y = l.next;}\\
        \left\{\begin{array}{l}
                \exists \V{L},\V{X},\V{Y},\V{Z}\st\\
                (\ls,\js{l})\pointsto\V{L}\sep(\ls,\js{x})\pointsto\V{X} \sep (\ls,\js{y})\pointsto\V{Y}\sep{}\\
                \V{L}\not\doteq\nil\sep\V{Y}\doteq\V{Z}\sep{}\\
                (\V{L},\text{next})\pointsto\V{Z}\text{list}(\V{Z}) \sep \text{list}(\V{X})
        \end{array}\right\}\\
        \qquad \js{l.next = x;}\\
        \left\{\begin{array}{l}
                \exists \V{L},\V{X},\V{Y},\V{Z}\st\\
                (\ls,\js{l})\pointsto\V{L}\sep(\ls,\js{x})\pointsto\V{X} \sep (\ls,\js{y})\pointsto\V{Y}\sep{}\\
                \V{L}\not\doteq\nil\sep\V{Y}\doteq\V{Z}\sep{}\\
                (\V{L},\text{next})\pointsto\V{X}\text{list}(\V{Z}) \sep \text{list}(\V{X})
        \end{array}\right\}\\
        \qquad \js{x = l;}\\
        \left\{\begin{array}{l}
                \exists \V{L},\V{X},\V{Y},\V{Z}\st\\
                (\ls,\js{l})\pointsto\V{L}\sep(\ls,\js{x})\pointsto\V{L} \sep (\ls,\js{y})\pointsto\V{Y}\sep{}\\
                \V{L}\not\doteq\nil\sep\V{Y}\doteq\V{Z}\sep{}\\
                (\V{L},\text{next})\pointsto\V{X}\text{list}(\V{Z}) \sep \text{list}(\V{X})
        \end{array}\right\}\\
        \left\{\begin{array}{l}
                \exists \V{L},\V{X},\V{Y},\V{Z}\st\\
                (\ls,\js{l})\pointsto\V{L}\sep(\ls,\js{x})\pointsto\V{L} \sep (\ls,\js{y})\pointsto\V{Y}\sep{}\\
                \V{L}\not\doteq\nil\sep\V{Y}\doteq\V{Z}\sep{}\\
                \text{list}(\V{Z}) \sep \text{list}(\V{L})
        \end{array}\right\}\\
        \qquad \js{l = y;}\\
        \left\{\begin{array}{l}
                \exists \V{L},\V{X},\V{Y},\V{Z}\st\\
                (\ls,\js{l})\pointsto\V{Y}\sep(\ls,\js{x})\pointsto\V{L} \sep (\ls,\js{y})\pointsto\V{Y}\sep{}\\
                \V{L}\not\doteq\nil\sep\V{Y}\doteq\V{Z}\sep{}\\
                \text{list}(\V{Z}) \sep \text{list}(\V{L})
        \end{array}\right\}\\
        \left\{\begin{array}{l}
                \exists \V{L},\V{X},\V{Y}\st\\
                (\ls,\js{l})\pointsto\V{Y}\sep(\ls,\js{x})\pointsto\V{L} \sep (\ls,\js{y})\pointsto\V{Y}\sep{}\\
                \V{L}\not\doteq\nil\sep{}\\
                \text{list}(\V{Y}) \sep \text{list}(\V{L})
        \end{array}\right\}\\
        \quad \js{\}}\\
        \left\{\begin{array}{l}
                \exists \V{L},\V{X},\V{Y}\st\\
                (\ls,\js{l})\pointsto\V{L}\sep(\ls,\js{x})\pointsto\V{X} \sep (\ls,\js{y})\pointsto\V{Y}\sep{}\\
                \V{L}\doteq\nil\sep{}\\
                \text{list}(\V{L}) \sep \text{list}(\V{X})
        \end{array}\right\}\\
        \left\{\begin{array}{l}
                \exists \V{L},\V{X},\V{Y}\st\\
                (\ls,\js{l})\pointsto\nil\sep(\ls,\js{x})\pointsto\V{X} \sep (\ls,\js{y})\pointsto\V{Y}\sep{}\\
                \text{list}(\V{X})
        \end{array}\right\}\\
        \quad \js{return x;}\\
        \left\{\begin{array}{ll}
                \exists \V{L},\V{X},\V{Y}\st\\
                (\ls,\js{l})\pointsto\nil\sep(\ls,\js{x})\pointsto\V{X} \sep (\ls,\js{y})\pointsto\V{Y}\sep{}\\
                \text{list}(\V{X})\sep\rv\doteq\V{X}
        \end{array}\right\}\\
        \}\\
\end{array}
\]}
\caption{Reversing a list}
\label{fig:revlist}
\end{figure}
}





\renewcommand\und{\undl}







\section{Related Work}

We believe this paper is the first to propose a program logic for reasoning about JavaScript. Our program logic adapts ideas from separation logic, and proves soundness with respect to a big-step operational semantics.  In this section, we discuss related work on separation logic and the semantics of JavaScript.

We build on the seminal work of O'Hearn, Reynolds and Yang~\cite{DBLP:conf/csl/OHearnRY01}, who introduced separation logic for reasoning about C-programs, and on the work of Parkinson and Bierman~\cite{Parkinson05,ParkinsonB08,Bierman03mj:an},  who adapted separation logic to reason about Java. 
%
We made several adaptations 
to their work in order to reason about JavaScript. As in~\cite{Parkinson05,ParkinsonB08,Bierman03mj:an},  we use 
assertions of the form $(\js{l},\js{x})\pointsto 5$ to denote that 
a field $\js{x}$ in object \js{l} has value $5$. We extend these assertions by  $(\js{l},\js{x})\pointsto \none$, which denotes that the field is {\em not} in $\js{l}$.  This is inspired by Dinsdale-Young {\sl et al.}'s use of the `out' predicate to state that values are not present in a concurrent set~\cite{CAP}. We introduce the sepish connective $\sepish$ to account for partially-shared data structures. 
We have not seen this connective before, which is surprising since shared data structures are common for example in Linux. There has been much work on various forms of concurrent separation logic with sharing~\cite{1236121,Vafeiadis07amarriage,denyguarantee}, but they all seem to take a different approach  to our $\sepish$ connective. 

We prove the soundness of our frame rule using a new technique
developed in Smith's PhD thesis~\cite{gdsThesis}. There are several
approaches to proving soundness of the separation-logic frame rule,
and we list the key developments here. The first and most commonly used 
approach by O'Hearn, Reynolds and Yang involves first proving that the
commands of the programming language under consideration are {\em
  local}, and then using that property to prove the frame
rule~\cite{DBLP:conf/csl/OHearnRY01}. Later, Birkedal and Yang devised
a method ``baking in'' the soundness of the frame rule into their
definition of Hoare triples~\cite{DBLP:conf/fossacs/BirkedalY07}. This
made it possible to prove the frame rule without reference to
locality, but did not extend well to concurrent programs. Vafeiadis
solved the concurrency problem in~\cite{MFPS11}, where he proves
soundness of concurrent separation logic without reference to
locality. Smith's thesis was written at the same time
as~\cite{MFPS11}, and takes a different approach. Rather than removing
all reference to locality from the soundness proof, Smith uses a
generalised {\em weak locality} property, which allows us to handle
some non-local behaviour.


%% Most work on separation logic proves soundness by requiring that commands are {\em local}. Javascript commands are inherently non-local,
%% since their behaviour changes depending on where the program variables reside in JavaScript's emulated  variable  store. We base our
%% soundness result on {\em weak locality}, recently introduced by Smith in his PhD thesis~\cite{gdsThesis}. At a similar time, Vafeiadis 
%% proved soundness of concurrent separation logic~\cite{MFPS11}, using an elegant technique which does not rely on traditional locality. This technique differs from Smith's in that it does not aim to be compatible with existing locality proofs. Smith's technique allows the re-use of existing locality proofs when  available.






We prove our soundness result with respect to a big-step operational semantics of JavaScript,  faithfully following the small-step semantics of  Maffeis \emph{et al.}~\cite{MMT-APLAS-TR08} except where discussed in Section~3.5.
%
Their semantics captures the  complete ECMAScript 3 language, at the same level of abstraction to where a JavaScript programmer reasons.
%
In contrast,Herman and Flanagan~\cite{HermanFlanagan} provide a definitional interpreter of JavaScript written in ML, which has the advantage of being directly executable, but includes implementation details that obscure the semantic meaning. 
%t
%Elsewhere, Guha \emph{et al.}~\cite{Guha2010} compile JavaScript to
%an intermediate Scheme-like language.
Elsewhere, Guha \emph{et al.}~\cite{Guha2010} compile JavaScript to
an intermediate Scheme-like language, in order to provide type-based
analyses on the object language. They justify their translation in a
novel way, by checking that it satisfies an established test suite of
JavaScript programs. However, the translation is complicated and it is
not immediately apparent that it is sound.
%
%% Moreover, in some cases the compilation-phase introduces a loss of precision (for example in the case of the \js{with} construct).
In fact, many approaches  translate JavaScript programs using  troublesome
features such as the \js{with} construct into programs which do not.
For example, Park, Lee and Ryu show that this is often feasible~\cite{RyuFOOL2011},
but do not handle interactions between \js{with} and \js{eval}.
%
There are  a number of more abstract models of JavaScript, which have proven useful to study selected language features~\cite{YuChander07,Giannini,ThiemannE}, but which are not sufficiently concrete for our purpose. 
%
Overall, we have chosen the semantics in~\cite{MMT-APLAS-TR08} because
it appears to be the most faithful to the actual JavaScript semantics.
%
As Richards {\em et al.} argue in~\cite{Richards2010}, all the unusual features of JavaScript are well-used in the wild, and cannot be easily abstracted away. 

%There has been a great deal of work on re-writing sytems for subsets of JavasScript~\cite{MMT-CSF-TR09,adsafe,caja,Sands08}, and on static analyses which approximate the call and prototype graphs of the full language~\cite{gatekeeper,Jang2009,pldi09-sif,thiemann-ai-js,jsapis}. 



% Jang2009,pldi09-sif,thiemann-ai-js,jsapis, MMT-CSF-TR09,adsafe,caja,Sands08,YuChander07,Giannini,ThiemannE


% MMT-APLAS-TR08,HermanFlanagan,Guha2010,YuChander07,Giannini,ThiemannE


%\cite{jsapis} proposes a context- and flow-insensitive points-to analysis that takes advantage of the less confusing nature of the newly released ECMAScript 5 to enforce confinement properties of APIs written in a JavaScript subset, with respect to client code written in the unrestricted language.










\section{Conclusions and Future Work}\label{sec:conclusions}

We have defined a program logic for reasoning about JavaScript, based
on an operational semantics which is essentially  faithful to 
ECMAScript~3. We have adapted separation logic to reason about
a JavaScript subset, modelling many complex features  such as
 prototype inheritance and \js{with}. We reason about the full
dynamic nature of JavaScript's functions, but do not provide 
higher-order reasoning. We also provide only conservative reasoning
about \js{eval}. Full reasoning about these features will be
technically challenging, although we believe that we can build on the
recent work of~\cite{billiejoe,Schwinghammer09nestedhoare,DreyerNB10}.
We do not currently reason about implicit type conversion. JavaScript
allows the programmer to define  functions  to convert values between different types. Adding this
feature to our operational semantics is simple. The complexity in
handling it with our program reasoning will be in reasoning about
higher-order functions,  as discussed above.

Due to our choice of operational semantics, we have been able to prove
a strong soundness result. Any library, formally specified 
using our reasoning, 
will behave well, even when called by arbitrary
JavaScript code.
%which makes use of features not currently included in
%our semantics. 
 In Section~\ref{sec:simplereasoningcomplexlanguage},  we
illustrated this property by  demonstrating that our \js{with} example behaves
according to its specification even when embedded in a program which
maliciously uses the non-standard \js{\_\_proto\_\_} feature.
Finally, our soundness result can be extended
compositionally to include more sophisticated reasoning about
higher-order functions and \js{eval}. 

We have given several examples of our reasoning, demonstrating with
small code examples that JavaScript is fiendish to understand and our reasoning can help. 
%
In particular, our \js{with} example  shows a potential bug that could easily go
unnoticed for some time, and perhaps lead to security holes in sanitised mashup
environments. Despite the complexity of the language and
the subtlety of the bug, reasoning about this and other examples is made
surprisingly simple by our example abstraction layers.
%   The overall complex behaviour of JavaScript means that our basic
% reasoning is also complex. However, we are able to build up several layers of
% abstraction, and establish that such abstractions lead to simple reasoning
% about `well-written' programs and more complex reasoning about `ugly' programs
% that break through the natural abstraction layers.


We hope that this work will form the core of a larger body of work on client-side web programming.  
%
For example, Thiemann~\cite{Thiemann05A} has defined a type-safe DOM API, and Smith~\cite{gdsThesis} has  developed   context-logic  reasoning about DOM Core Level 1. It would be valuable to integrate these approaches to DOM modelling with the  JavaScript reasoning presented here. 

Maffeis et al.~\cite{csf,esorics,oakland} have developed techniques for building secure JavaScript mashups out of untrusted code. They prove security properties of their enforcement mechanisms, but do not study their functional correctness. Our reasoning  makes such an  analysis possible.
%
We also intend to develop reasoning for high-level libraries such as
jQuery, Prototype.js and Slidy~\cite{jquery,prototype,slidy}. We will make each of these libraries
the focus of its own layer of abstraction, following the examples in
Section~\ref{sec:examples}, to make reasoning about
idiomatic uses of those libraries very natural. As with our existing
layers of abstraction, it will be possible to safely break these
abstractions where necessary in order to code and reason at a lower
level. 

While our work focuses on ECMAScript 3, the newer 
ECMAScript~5  and the ongoing ECMAScript Harmony both provide enticing
targets. Taly and others have recently given a small-step operational semantics of 
ECMAScript~5~\cite{jsapis}. It 
would certainly be interesting to  reason about ECMAScript 5 code, 
and to formalise the connections with our  reasoning presented here about ECMAScript~3.  We
are particularly interested in understanding the behaviour  of
libraries written in  ECMAScript~5 when called by code
written in  ECMAScript~3. 


%, incorporating a fiction of locality as in~\cite{AbstractionRefinement}.
%

To make this program reasoning genuinely useful for JavaScript
programmers, it is essential that we provide tool support. We intend
to produce analysis tools capable of spotting bugs such as the one
described in the \js{with} example in Section~\ref{sec:examples:with},
and integrate our tools with IDEs such as Eclipse or Visual Studio.

%Smith has developed
%reasoning about the W3C DOM Core Level 1 library for XML update~\cite{gdsThesis,Gardner08DOM}, using context-logic reasoning~\cite{Calcagno05}  which generalises separation-logic 
%reasoning to complex data structures such as XML. This DOM reasoning will be 
%compatible with the  JavaScript reasoning presented here. 






%\cite{jsapis} proposes a context- and flow-insensitive points-to analysis that enforces confinement properties of APIs written in a JavaScript subset, with respect to client code written in the unrestricted language.
%%
%Admittedly, the authors study JavaScript corresponding to the 5th edition of the ECMAScript Standard (ES5) because it is easier to analyze statically.
%% 
%We hope that our program logic will make it possible to produce analysis tools able to handle unrestricted JavaScript instead.

%  ............last paragraph on automatic tools, keep it simple...........................
%  
%  In addition to expanding the JLB language with JavaScript and DOM features,
%  there is considerable scope for future work in automation and library reasoning. 
%  Separation logic for both C and Java has proved to be very amenable
%  to automated reasoning~\cite{smallf,slayerp,spacep,1449782}, and the
%  prospect of similarly automated reasoning for JavaScript is tantalising. In
%  particular, automated reasoning about JavaScript libraries promises to be especially
%  interesting. JavaScript does not have a module system of the sort that is used
%  in many programming languages to encapsulate libraries. As a result, the
%  interfaces between JavaScript libraries can be unclear, and thorough testing
%  can be extremely challenging. These challenges are outweighed however, by the
%  enormous utility of JavaScript libraries on the web. Libraries such as
%  jQuery~\cite{jquery} and Prototype.js~\cite{prototype} smooth over implementation quirks of individual web
%  browsers, and provide functionality to JavaScript developers which
%  would be time-consuming for them to produce in-house. Since libraries can be
%  directly referenced in web pages, the cost of distributing the latest version
%  of a library is effectively zero.  A library may be written in a carefully
%  chosen subset of JavaScript, but it \emph{must} be capable of interfacing with
%  arbitrary programs written in full-JavaScript. 
%  %
%  Automated reasoning tools to reason about correctness and safety properties of such a library would surely be extremely valuable.
%  %
%  A first step in this direction can be found in~\cite{jsapis}.
%  %
%  The paper proposes a context- and flow-insensitive points-to analysis that enforces confinement properties of APIs written in a JavaScript subset, with respect to client code written in the unrestricted language.
%  %
%  Admittedly, the authors study JavaScript corresponding to the 5th edition of the ECMAScript Standard (ES5) because it is easier to analyze statically.
%  %
%  Our proposal is a further step towards enabling general-purpose analysis tools, able to cope with the subtleties of JavaScript based on ECMAScript 3, which constitute the overwhelming majority of web pages at the moment and in the foreseeable future.
%  


% Limitations.
% %
% We did not model some hard bits of JavaScript.
% %
% Complexity, lack of automation (inherited form separation logics).
% %
% Not enough compellingmotivating examples.



% Future work.
% %
% ECMA 5.
% %
% Reflection~\cite{}, higher-order store~\cite{billiejoe,Schwinghammer09nestedhoare}.%~\cite{Krishnaswami2006a}.
% %
% Connection with DOM.
% %
% Automatic reasoning tools (WHY, -FOOT).


\stitle{Acknowledgements}
%
Gardner and Smith are supported by EPSRC grant COTFM\_P21654.
Maffeis is supported by EPSRC grant EP/I004246/1.
We thank 
Charlton,
Dinsdale-Young, 
Ntzik,
O'Hearn,
da Rocha Pinto,
Wheelhouse,
and Wright
for insightful discussions.
We especially thank Daiva Naudziuniene for her impressive eye for detail.
%
% Please don't change line above (but you can move if you want). Other acks?

\iflong{
\bibliographystyle{plain}
\bibliography{gds}
}
\ifshort{
\begin{thebibliography}{10}

\bibitem{Giannini}
C.~Anderson, P.~Giannini, and S.~Drossopoulou.
\newblock Towards type inference for {JavaScript}.
\newblock In {\em Proc. of ECOOP'05}, 2005.

\bibitem{conf/fmco/BerdineCO05}
J.~Berdine, C.~Calcagno, and P.~O'Hearn.
\newblock Smallfoot: Modular automatic assertion checking with separation
  logic.
\newblock In {\em FMCO}, 2005.

\bibitem{slayerp}
J.~Berdine, B.~Cook, and S.~Ishtiaq.
\newblock Slayer: Memory safety for systems-level code.
\newblock In {\em CAV}, 2011.

\bibitem{Bierman03mj:an}
G.M. Bierman, M.J. Parkinson, and A.~M. Pitts.
\newblock {MJ}: An imperative core calculus for java and java with effects.
\newblock Technical report, Cambridge, 2003.

\bibitem{DBLP:conf/fossacs/BirkedalY07}
L.~Birkedal and H.~Yang.
\newblock Relational parametricity and separation logic.
\newblock In {\em FoSSaCS}, pages 93--107, 2007.

\bibitem{billiejoe}
N.~Charlton.
\newblock Hoare logic for higher order store using simple semantics.
\newblock In {\em Proc. of WOLLIC 2011}, 2011.

\bibitem{CAP}
T.~Dinsdale-Young, M.~Dodds, P.~Gardner, M.~Parkinson, and V.~Vafeiadis.
\newblock Concurrent abstract predicates.
\newblock {\em ECOOP}, 2010.

\bibitem{1449782}
D.~Distefano and M.~Parkinson.
\newblock {jStar}: towards practical verification for {J}ava.
\newblock In {\em OOPSLA '08}, pages 213--226. ACM, 2008.

\bibitem{denyguarantee}
M.~Dodds, X.~Feng, M.J. Parkinson, and V.~Vafeiadis.
\newblock Deny-guarantee reasoning, 2009.

\bibitem{DreyerNB10}
D.~Dreyer, G.~Neis, and L.~Birkedal.
\newblock The impact of higher-order state and control effects on local
  relational reasoning.
\newblock In {\em ICFP}, pages 143--156, 2010.

\ifshort{\bibitem{proofs}
P.~Gardner, S.~Maffeis, and G.~Smith.
\newblock Towards a program logic for {J}ava{S}cript.
\newblock Imperial College London Technical Report number DTR11-11, November
  2011.}

\bibitem{Guha2010}
A.~Guha, C.~Saftoiu, and S.~Krishnamurthi.
\newblock {The Essence of JavaScript}.
\newblock {\em ECOOP 2010}, pages 126--150, 2010.

\bibitem{HermanFlanagan}
D.~Herman and C.~Flanagan.
\newblock Status report: specifying {JavaScript} with {ML}.
\newblock In {\em Proc. of ML'07}, pages 47--52, 2007.

\bibitem{ecma262}
ECMA International.
\newblock {ECMAScript} language specification. stardard {ECMA}-262, 3rd
  {E}dition, 1999.

\bibitem{jquery}
{jQuery}: The write less, do more, {JavaScript} library.
\newblock \url{http://jquery.com}.

\bibitem{esorics}
S.~Maffeis, J.~C. Mitchell, and A.~Taly.
\newblock Isolating javascript with filters, rewriting, and wrappers.
\newblock In {\em ESORICS}, pages 505--522, 2009.

\bibitem{oakland}
S.~Maffeis, J.~C. Mitchell, and A.~Taly.
\newblock Object capabilities and isolation of untrusted web applications.
\newblock In {\em IEEE Symposium on Security and Privacy}, pages 125--140,
  2010.

\bibitem{MMT-APLAS-TR08}
S.~Maffeis, J.C. Mitchell, and A.~Taly.
\newblock An operational semantics for {JavaScript}.
\newblock In {\em Proc. of {APLAS}'08}, LNCS, 2008.

\bibitem{csf}
S.~Maffeis and A.~Taly.
\newblock Language-based isolation of untrusted javascript.
\newblock In {\em CSF}, pages 77--91, 2009.

\bibitem{DBLP:conf/csl/OHearnRY01}
P.~O'Hearn, J.~C. Reynolds, and H.~Yang.
\newblock Local reasoning about programs that alter data structures.
\newblock In {\em CSL}, 2001.

\bibitem{1236121}
P.~W. OHearn.
\newblock Resources, concurrency, and local reasoning.
\newblock {\em Theor. Comput. Sci.}, 375(1-3):271--307, 2007.

\bibitem{RyuFOOL2011}
Changhee Park, Hongki Lee, and Sukyoung Ryu.
\newblock An empirical study on the rewritability of the with statement in
  javascript.
\newblock In {\em FOOL}, 2011.
\ifshort{\vfill\eject}
\bibitem{ParkinsonB08}
M.~J.~Parkinson and G.~M. Bierman.
\newblock Separation logic, abstraction and inheritance.
\newblock In {\em POPL}, 2008.

\bibitem{Parkinson05}
M.~J. Parkinson.
\newblock Local reasoning for {Java}.
\newblock Technical Report 654, Univ. of Cambridge Computer Laboratory, 2005.
\newblock Ph.D.\ dissertation.

\bibitem{prototype}
{Prototype Core Team}.
\newblock Prototype {JavaScript} framework: {E}asy {A}jax and {DOM}
  manipulation for dynamic web applications.
\newblock \url{http://www.prototypejs.org}.

\bibitem{slidy}
Dave Raggett.
\newblock {W3C} {S}lidy.
\newblock \url{http://www.w3.org/Talks/Tools/Slidy2/}, 2005.

\bibitem{Vitek-Eval}
G.~Richards, C.~Hammer, B.~Burg, and J.~Vitek.
\newblock The {E}val that men do  {A} large-scale study of the use of {E}val
  in {JavaScript} applications.
\newblock Accepted for publication at ECOOP 2011.

\bibitem{Richards2010}
G.~Richards, S.~Lebresne, B.~Burg, and J.~Vitek.
\newblock {An analysis of the dynamic behavior of {JavaScript} programs}.
\newblock In {\em PLDI}, 2010.

\bibitem{Schwinghammer09nestedhoare}
J.~Schwinghammer, L.~Birkedal, B.~Reus, and H.~Yang.
\newblock Nested hoare triples and frame rules for higher-order store.
\newblock In {\em In Proc. of CSL'09}, 2009.

\bibitem{gdsThesis}
G.~D. Smith.
\newblock Local reasoning about web programs.
\newblock {PhD} Thesis, Dep. of Computing, Imperial College London, 2011.

\bibitem{jsapis}
A.~Taly, U.~Erlingsson, M.~S. Miller, J.~C. Mitchell, and J.~Nagra.
\newblock Automated analysis of security-critical javascript apis.
\newblock In {\em Proc. of {IEEE Security and Privacy}'11}. IEEE, 2011.

\bibitem{ThiemannE}
P.~Thiemann.
\newblock Towards a type system for analyzing javascript programs.
\newblock In {\em Proc. of ESOP'05}, volume 3444 of {\em LNCS}, 2005.

\bibitem{Thiemann05A}
P.~Thiemann.
\newblock A type safe {DOM API}.
\newblock In {\em Proc. of DBPL}, pages 169--183, 2005.

\bibitem{MFPS11}
V.~Vafeiadis.
\newblock Concurrent separation logic and operational semantics.
\newblock In {\em MFPS11}, 2011.

\bibitem{Vafeiadis07amarriage}
Viktor Vafeiadis and M.~Parkinson.
\newblock A marriage of rely/guarantee and separation logic.
\newblock In {\em IN 18TH CONCUR}. Springer, 2007.

\bibitem{spacep}
H.~{\!Y}ang, O.~{\!L}ee, J.~Berdine, C.~{\!C}alcagno, B.~{\!C}ook,
  D.~{\!D}istefano, and P.~{\!O}'Hearn.
\newblock Scalable shape analysis for systems code.
\newblock In {\em CAV}, 2008.

\bibitem{YuChander07}
D.~Yu, A.~Chander, N.~Islam, and I.~Serikov.
\newblock {JavaScript} instrumentation for browser security.
\newblock In {\em Proc. of POPL'07}, 2007.

\end{thebibliography}
}



\appendix
\iflong{\vfill\eject}


\section{Tables}\label{sec:tables}

\subsection{Notation}\label{sec:tables:jlb}
%
We summarize below the mathematical notation used to define the syntax and semantics of JavaScript.
%
% Sorts of JLB values
%
\begin{display}{Notation: Sorts and Constants.}
\entry{H {\;\in\;} \loc\times\vars\rightharpoonup\vals}{Heaps.}\\[\gap]
\entry{l {\;\in\;} \locb\triangleq \loc\cup\{\nil\}}{Locations.}\\[\gap]
\entry{L {\;\in\;} \scopechains\triangleq \loc^n}{Scope chains.}\\[\gap]
\entry{\lgo}{Global object.}\\[\gap]
\entry{\lop}{\js{Object.prototype}.}\\[\gap]
\entry{\lge}{\js{eval}.}\\[\gap]
\entry{\lep}{Prototype of \js{eval}.}\\[\gap]
\entry{\left\{\begin{array}{l}\protop,\thisp,\\
             \fscopep,\bodyp\end{array}\right\}\in\ivars}{Internal variables.}\\[\gap]
\entry{x\in\vars\triangleq \ivars\sep\uvars}{Variables.}\\[\gap]
\entry{\js x\in\uvars\subseteq \Strings}{User variables.}\\[\gap]
\entry{\njs{r} {\;\in\;} \valsr \triangleq \vals\cup \refs}{Return values.}\\[\gap]
\entry{\njs{v} {\;\in\;} \vals \triangleq \uvals\cup\locb\cup \scopechains \cup \sortfun}{Semantic values.}\\[\gap]
\entry{\js{v} {\;\in\;} \uvals\triangleq \sortnum\cup \Strings \cup \sortundef \cup \{\nil\}}{User values.}\\[\gap]
\entry{\js{n} {\;\in\;} \sortnum}{Numbers.}\\[\gap]
\entry{\js{m} {\;\in\;} \Strings}{Strings.}\\[\gap]
\entry{\und {\;\in\;} \sortundef}{Undefined.}\\[\gap]
\entry{l\sv\js{x} {\;\in\;} \refs}{References.}\\[\gap]
\entry{\lambda\js{x.e} {\;\in\;} \sortfun}{Function code.}\\[\gap]
\entry{\js{e} {\;\in\;} \sortexp}{Expressions.}
\end{display}


\begin{display}{Notation: Functions and Judgements.}
\entry{\domain(H)}{Domain of the store.}\\[\gap]
\entry{(l,x)\pointsto v}{Heap cell.}\\[\gap]
\entry{H(l,x)}{Heap read operation.}\\[\gap]
\entry{H\semup{(l,x)\pointsto v}}{Heap write/add operation.}\\[\gap]
\entry{H\setminus r}{Heap cell deletion.}\\[\gap]
\entry{H\sep H'}{Disjoint heap composition.}\\[\gap]
%
\entry{H\iswf}{Valid heap $H$.}\\[\gap]
\entry{\schain(H,l)}{Valid scope chain.}\\[\gap]
\entry{H\isok}{Well-formed heap $H$.}\\[\gap]
%
\entry{\scope(H,l,x)}{Find defining scope.}\\[\gap]
\entry{\proto(H,l,x)}{Find defining prototype.}\\[\gap]
\entry{\getValue(H,r)}{Read from reference.}\\[\gap]
\entry{H,L,\js e\levalsto H',r}{Expression evaluation.}\\[\gap]
\entry{H,L,\js e\gevalsto H',v}{Dereferenced evaluation.}\\[\gap]
%
\entry{\obj(l)}{Empty object at $l$.}\\[\gap]
\entry{\ReadWrite(H,r)}{Read-write reference.}\\[\gap]
\entry{\ReadOnly(H,r)}{Read-only reference.}\\[\gap]
\entry{\func(l,L,\js x,\js e,l')}{New function at $l$.}\\[\gap] % 
\entry{\pickThis(H,r)}{Determine self pointer.}\\[\gap]
\entry{\activ(l,\js x,v,l',\js e,l'')}{Activation object template.}\\[\gap]
\entry{\defs(\js x,l,\js e)}{Allocate local variables.}\\[\gap]
\entry{\parse(\js s)}{Parse \js s as JavaScript code.}\\[\gap]
\entry{\objOrGlob(v)}{Determine prototype for \js{new}.}\\[\gap]
\entry{\getBase(l,v)}{Determine object for \js{new}.}\\[\gap]
\entry{\istrue(v)}{Determine truth.}\\[\gap]
\entry{\isfalse(v)}{Determine falsity.}
\end{display}



\subsection{Syntax and Semantics}

\begin{display}{Scope resolution: $\scope(H,l,x)$.}
\jaxiom{\scope(H,{\emptylist},\njs{x})}{\nil}{}\\[\gap]
\jrule{\scope(H,l\cons L,\njs{x})}{l}{\proto(H,l,\njs{x}) \neq \nil}\rsep
\jrule{\scope(H,l\cons L,\njs{x})}{\scope(H,L,\njs{x})}{\proto(H,l,\njs{x}) = \nil}
\end{display}
%
\begin{display}{Prototype resolution: $\proto(H,l,x)$.}
\jaxiom{\proto(H,\nil,\njs{x})}{\nil}{}\\[\gap]
\jrule{\proto(H,l,\njs{x})}{l}{(l,\njs{x}) \in\domain(H)}\rsep
\jrule{\proto(H,l,\njs{x})}{\proto(H,l',\njs{x})}{(l,\njs{x}) \not\in\domain(H) \qquad H(l,\protop) = l'}
\end{display}
%
\begin{display}{Dereferencing values: $\getValue(H,r)$.}
\jrule{\getValue(H,\njs{r})}{\njs{r}}{\njs{r}\neq l\sv \js{x}}~
\jrule{\getValue(H,l\sv\js{x})}{\und}{\proto(H,l,\js{x}) = \nil\\ l\neq \nil}~
\jrule{\getValue(H,l\sv\js{x})}{H(l',\js{x})}{\proto(H,l,\js{x}) = l'\\ l\neq \nil}
\end{display}
%
\begin{display}{Update $H \semup{ (l,\js x)\pointsto\njs{v}}$ and deallocation $H\setminus \njs{r}$.}
%
\jrule{H \semup{ (l,\js x)\pointsto\njs{v}}}{H\sep(l,x)\pointsto\njs{v}}{(l,\js x)\not\in dom(H)\qquad l\neq\nil}
\\[\gap]
%
\jaxiom{(H\sep(l,\js x)\pointsto\njs{v}) \semup{ (l,\js x)\pointsto\njs{v'}}}{H\sep(l,\js x)\pointsto\njs{v'}}{}
\\[\gap]
%
\jaxiom{H\semup{(\nil,\js{x})\pointsto \njs{v}}}{H\semup{(\lgo,\js{x})\pointsto \njs{v}}}{}
\\[\gap]
%
\jaxiom{(H\sep(l,\js x)\pointsto v)\setminus l\sv \js x}{H}{}
~

\jrule{H\setminus l\sv \js x}{H}{(l,\js x)\not\in dom(H)}
~
%
\jrule{H\setminus \njs{r}}{H}{\njs{r}\neq l\sv \js{x}}
%
\end{display}
%
\begin{display}{Syntax of Terms: \js v, \js e.}
\clause{\mbox{$\begin{array}{lcl}
%  H & \defeq & H\sep (l,\js{x})\pointsto\js{v} \pipe \emp\\
\js{v} & \defeq & \js{n} \pipe \js{m} \pipe \und \pipe \nil\\  
\js{e} & \defeq & \js{e} ; \js{e} \pipe \js{x} \pipe \js{v} \pipe \js{if(e)\{e\}\{e\}} \pipe \js{while(e)\{e\}} \pipe \js{var}\ \js{x} \\
        && \pipe \this\pipe \js{delete e} \pipe \js{e} \oplus \js{e} \pipe \js{e.x} \pipe \js{e(e)} \pipe \js{e = e} \\
        && \pipe \jsfun{x}{e} \pipe \jsfun[x]{x}{e}\pipe \js{new e(e)}  \\
        && \pipe \{ \js{x}_1:\js{e}_1 \dots \js{x}_n:\js{e}_n \} \pipe \js{e[e]} \pipe \js{with(e)\{e\}}\\
\end{array}$}{}}
\end{display}






\begin{display}{Operational Semantics: $H,L,\js e\levalsto H',r$.}
%
Notation: $H,L,\js{e} \gevalsto H',v \triangleq \exists r. (H,L,\js{e} \levalsto H',r \wedge \getValue(H',r) = v)$.\\[\gap]



%
% EXPRESSIONS
%

\staterule{(Definition)}
{H,L,\js{e}\levalsto H',v}
{H,L,\js{var e} \levalsto H',\und}
\rsep  
\stateaxiom{(Value)}
{H,L,\js{v} \levalsto H,\js{v} }
\\[\gap]



\staterule{(Member Access)}
{H,L,\js{e} \gevalsto H',l' \\
 l'\neq \nil}
{H,L,\js{e.x} \levalsto H',l'\sv\js{x}}
\rsep
%
\staterule{(Computed Access)}
{H,L,\js{e1} \gevalsto H_1,l' \\
 l'\neq \nil\\
 H_1,L,\js{e2} \gevalsto H',\js x}
{H,L,\js{e1[e2]} \levalsto H',l'\sv \js x}
\\[\gap]


\staterule{(Variable )}
{\scope(H,L,\js{x})=l' }
{H,L,\js{x} \levalsto H,l'\sv\js{x}}
\rsep
%
\staterule{(Object)}
{H_0 = H \sep \obj(l',\lop)\\
 \forall i\in 1..n.\left(\begin{array}{l}
  H_{i-1},L,\js{ei}\gevalsto H_i',\njs{v_i} \\ 
  H_i = H_i' \semup{ (l',\js{xi}) \pointsto \njs{v_i}}\end{array}\right)}
{H,L,\{\js{x1:e1},\dots, \js{xn:en}\} \levalsto H_n,l'}
\\[\gap]


\staterule{(Binary Operators)}
{H,L,\js{e1} \gevalsto H'',\js{v1}\\
 H'',L,\js{e2} \gevalsto H',\js{v2}\\
 \js{v1}\primop\js{v2}=\js{v}}
{H,L, \js{e1} \oplus \js{e2} \levalsto H',\js{v}}
\rsep
%
\staterule{(Assignment)}
{H,L,\js{e1} \levalsto H_1,l'\sv\js{x}\\
 H_1,L,\js{e2} \gevalsto H_2,\njs{v}\\
 H'=H_2\semup{(l',\js{x})\pointsto\njs{v}}}
{H,L,\js{e1=e2} \levalsto H',\njs{v}}
\rsep
%
\\[\gap]


\staterule{(Delete True)}
{H,L,\js{e} \levalsto H',r\quad
\ReadWrite(H,r)\\
 H'' = H'\setminus \njs{r}}
{H,L,\js{delete e} \levalsto H'',1}
\rsep
%
\staterule{(Delete False)}
{H,L,\js{e} \levalsto H',r\quad
\ReadOnly(H,r)}
{H,L,\js{delete e} \levalsto H',0}
%
\\[\gap]


\staterule{(This)}
{\scope(H,L,\thisp)=l_1 \\ \proto(H,l_1,\thisp)=l_2\\ H(l_2,\thisp)=l'}
{H,L,\js{this} \levalsto H,l'}
~
%
\staterule{(Function)}
{H' = H \sep \obj(l,\lop) \sep \func(l',L,\js x,\js e,l)}
{H,L,\jsfun{x}{e} \levalsto H',l'}
\\[\gap]


\staterule{(Named Function)}
{H' = H \sep \obj(l,\lop)\sep \func(l',l_1\ty L,\js x,\js e,l) \sep l_1\pointsto\{\protop\ty \lop,\js{y}\ty l'\}}
{H,L,\jsfun[y]{x}{e} \levalsto H',l'}
\\[\gap]


\staterule{(Function Call)}
{H,L,\js{e1} \levalsto H_1,r_1\qquad
 \pickThis(H_1,\njs{r_1})=l_2\qquad
 \getValue(H_1,r_1)=l_1\\
 l_1\neq\lge\qquad H_1(l_1,\bodyp)=\lambda \js{x.e3}\qquad
 H_1(l_1,\fscopep)= L'\\
 H_1,L,\js{e2} \gevalsto H_2,\njs{v}\\
 H_3 = H_2\sep\activ(l,\js x,v,\js{e3},l_2)\qquad
 H_3,l\cons L',\js{e3} \gevalsto H',\njs{v'}}
{H,L,\js{e1(e2)} \levalsto H',\njs{v'}}
\\[\gap]


\staterule{(Eval)}
{H,L,\js{e1} \gevalsto H_1,\lge\qquad 
 H_1,L,\js{e2} \gevalsto H_2,\js{s}\\ 
 \parse(\js s)=\js{e}\qquad
 H_2,L,\js {e}\gevalsto H',v'}
{H,L,\js{e1(e2)} \levalsto H',\njs{v'}}
\\[\gap]


\staterule{(New)}
{H,L,\js{e1} \gevalsto H_1,\njs{l_1} \qquad
 l_1\neq \nil\qquad
 H_1(l_1,\bodyp)=\lambda \js{x.e3}\\
 H_1(l_1,\fscopep)= L'\qquad
 H_1(l_1,\js{prototype})= v\\
H_1,L,\js{e2} \gevalsto H_2,\njs{v_1}  \qquad  
 l_2 = \objOrGlob(v) \\
 H_3 = H_2\sep \obj(l_3,l_2) \sep\activ(l,\js x,v_1,\js{e3},l_3)\\ 
 H_3,l\cons L',\js{e3} \gevalsto H',v_2\qquad
 \getBase(l_3,v_2) = l'}
{H,L,\js{new e1(e2)} \levalsto H',\njs{l'}}
\\[\gap]

%\staterule{(Function Call)}
%{H,L,\js{e1} \levalsto H_1,r_1\\ 
% \pickThis(H_1,\njs{r_1})=l_2\\
% \getValue(H_1,r_1)=l_1\\
% l_1\neq\lge\\
% H_1(l_1,\bodyp)=\lambda \js{x.e3}\\
% H_1(l_1,\fscopep)= L'\\
% H_1,L,\js{e2} \gevalsto H_2,\njs{v}\\
% H_3 = H_2\sep\activ(l,\js x,v,\js{e3},l_2)\\
% H_3,l\cons L',\js{e3} \gevalsto H',\njs{v'}}
%{H,L,\js{e1(e2)} \levalsto H',\njs{v'}}
%\rsep
%%
%\staterule{(Eval)}
%{H,L,\js{e1} \gevalsto H_1,\lge\\ 
% H_1,L,\js{e2} \gevalsto H_2,\js{s}\\ 
% \parse(\js s)=\js{e}\\
% H_2,L,\js {e}\gevalsto H',v'}
%{H,L,\js{e1(e2)} \levalsto H',\njs{v'}}
%\\[\gap]
%
%
%\staterule{(New)}
%{H,L,\js{e1} \gevalsto H_1,\njs{l_1} \\
% l_1\neq \nil\\
% H_1(l_1,\bodyp)=\lambda \js{x.e3}\\
% H_1(l_1,\fscopep)= L'\\    
% H_1(l_1,\js{prototype})= v\\ 
% l_2 = \objOrGlob(v) \\  
% H_1,L,\js{e2} \gevalsto H_2,\njs{v_1} \\
% H_3 = H_2\sep \obj(l_3,l_2) \sep\activ(l,\js x,v_1,\js{e3},l_3)\\ 
% H_3,l\cons L',\js{e3} \gevalsto H',v_2\\  
% \getBase(l_3,v_2) = l'}
%{H,L,\js{new e1(e2)} \levalsto H',\njs{l'}}
%\\[\gap]




%
% STATEMENTS
%

\staterule{(Sequence)}
{H,L,\js{e1}\levalsto H'',\njs{r}'\\ H'',L,\js{e2}\levalsto H',\njs{r}}
{H,L, \js{e1 ; e2} \levalsto H',\njs{r}}
%
\\[\gap]

\staterule{(With)}
{H,L,\js{e1} \gevalsto H_1,l\\
l\neq\nil\\
 H_1,l\cons L,\js{e2} \levalsto H', \njs{r}}
{H,L,\js{with(e1)\{e2\}} \levalsto H',r}
%
\\[\gap]


\staterule{(If True)}
{H,L,\js{e1} \gevalsto H'',\njs{v} \qquad
 \istrue(\njs{v})\qquad
 H'',L,\js{e2} \levalsto H',\njs{r}}
{H,L,\js{if(e1)\{e2\}\{e3\}} \levalsto H',\njs{r} }
\\[\gap]

\staterule{(If False)}
{H,L,\js{e1} \gevalsto H'',\njs{v} \qquad
 \isfalse(\njs{v}) \qquad
 H'',L,\js{e3} \levalsto H',\njs{r}}
{H,L,\js{if(e1)\{e2\}\{e3\}} \levalsto H',\njs{r}}
\\[\gap]

\staterule{(While True)}
{H,L,\js{e1} \gevalsto H'',\njs{v} \qquad
 \istrue(\njs{v}) \\ 
 H'',L,\js{e2;while(e1)\{e2\}} \levalsto H',\njs{r}}
{H,L,\js{while(e1)\{e2\}} \levalsto H',\und }
\\[\gap]

\staterule{(While False)}
{H,L,\js{e1} \gevalsto H'',\njs{v} \qquad
 \isfalse(\njs{v})}
{H,L,\js{while(e1)\{e2\}} \levalsto H'',\und }


\end{display}
%






\begin{display}{Fault rules: $H,L,\js e\levalsto \fault$.}
%
Notation: $H,L,\js{e} \gevalsto H',v \triangleq \exists r. (H,L,\js{e} \levalsto H',r \wedge \getValue(H',r) = v)$.\\[\gap]



%
% EXPRESSIONS
%

\staterule{(Definition - \fault)}
{H,L,\js{e}\levalsto H',v}
{H,L,\js{var e} \levalsto H',\und}
\rsep  
%
\staterule{(Member Access - \nil)}
{H,L,\js{e} \gevalsto H',l' \\
 l'=\nil}
{H,L,\js{e.x} \levalsto \fault}
\\[\gap]
%
\staterule{(Member Access - \fault)}
{H,L,\js{e} \levalsto \fault}
{H,L,\js{e.x} \levalsto \fault}
\rsep
%
\staterule{(Member Access - not a reference)}
{H,L,\js{e} \gevalsto H',v \\
 v \not\in\loc}
{H,L,\js{e.x} \levalsto \fault}
\\[\gap]

\staterule{(Computed Access - \fault1)}
{H,L,\js{e1} \levalsto \fault}
{H,L,\js{e1[e2]} \levalsto \fault}
\\[\gap]

\staterule{(Computed Access - \nil)}
{H,L,\js{e1} \gevalsto H_1,l' \\
 l'= \nil}
{H,L,\js{e1[e2]} \levalsto \fault}
\rsep
%
\staterule{(Computed Access - \fault2)}
{H,L,\js{e1} \gevalsto H_1,l' \\
 l'\neq \nil\\
 H_1,L,\js{e2} \levalsto \fault}
{H,L,\js{e1[e2]} \levalsto \fault}
\\[\gap]
\staterule{(Computed Access - not a reference)}
{H,L,\js{e1} \levalsto H',v\\
v \not\in\loc}
{H,L,\js{e1[e2]} \levalsto \fault}
\\[\gap]



\staterule{(Object-\fault)}
{H_0 = H \sep \obj(l',\lop)\\
\exists j\in 1.n\st\left(\begin{array}{l}
 \forall i\in 1..j.\left(\begin{array}{l}
  H_{i-1},L,\js{ei}\gevalsto H_i',\njs{v_i} \\ 
  H_i = H_i' \semup{ (l',\js{xi}) \pointsto \njs{v_i}}\end{array}\right)\\
H_{j-1},L,\js{ej}\levalsto\fault\end{array}\right)}
{H,L,\{\js{x1:e1},\dots, \js{xn:en}\} \levalsto \fault}
\\[\gap]  



\staterule{(Binary Operators-\fault1)}
{H,L,\js{e1} \levalsto \fault}
{H,L, \js{e1} \oplus \js{e2} \levalsto \fault}
\\[\gap]
\staterule{(Binary Operators-\fault2)}
{H,L,\js{e1} \gevalsto H'',\js{v1}\\
 H'',L,\js{e2} \levalsto \fault}
{H,L, \js{e1} \oplus \js{e2} \levalsto \fault}
\rsep
%
\staterule{(Binary Operators-partial)}
{H,L,\js{e1} \gevalsto H'',\js{v1}\\
 H'',L,\js{e2} \gevalsto H',\js{v2}\\
 \neg\exists\js{v}\st\js{v1}\primop\js{v2}=\js{v}}
{H,L, \js{e1} \oplus \js{e2} \levalsto \fault}
\\[\gap]

\staterule{(Assignment-\fault1)}
{H,L,\js{e1} \levalsto \fault}
{H,L,\js{e1=e2} \levalsto \fault}
\\[\gap]
\staterule{(Assignment-notref)}
{H,L,\js{e1} \levalsto H_1,\js{v}\\
\neg\exists l',\js{x}\st \js{v}=l'\sv\js{x}}
{H,L,\js{e1=e2} \levalsto\fault}
\rsep
%
\staterule{(Assignment-\fault2)}
{H,L,\js{e1} \levalsto H_1,l'\sv\js{x}\\
 H_1,L,\js{e2} \levalsto\fault}
{H,L,\js{e1=e2} \levalsto\fault}
\\[\gap]



\staterule{(Delete-\fault)}
{H,L,\js{e} \levalsto \fault}
{H,L,\js{delete e} \levalsto \fault}
\\[\gap]
\staterule{(Delete-not a reference)}
{H,L,\js{e} \levalsto H',v\\
v\not\in\refs}
{H,L,\js{delete e} \levalsto \fault}
\\[\gap]



\staterule{(Function Call-\fault1)}
{H,L,\js{e1} \levalsto \fault}
{H,L,\js{e1(e2)} \levalsto \fault}
\\[\gap]
\staterule{(Function Call-notfunc)}
{H,L,\js{e1} \levalsto H_1,r_1\qquad
 \getValue(H_1,r_1)=l_1\\
 l_1\neq\lge\qquad
 (l_1,\bodyp)\not\in\domain(H_1) }
{H,L,\js{e1(e2)} \levalsto \fault}
\\[\gap]
\staterule{(Function Call-notref)}
{H,L,\js{e1} \levalsto H_1,r_1\qquad
 \getValue(H_1,r_1)=v\\
v\not\in\refs}
{H,L,\js{e1(e2)} \levalsto \fault}
\\[\gap]
\staterule{(Function Call-\fault2)}
{H,L,\js{e1} \levalsto H_1,r_1\qquad
 \pickThis(H_1,\njs{r_1})=l_2\qquad
 \getValue(H_1,r_1)=l_1\\
 l_1\neq\lge\qquad H_1(l_1,\bodyp)=\lambda \js{x.e3}\qquad
 H_1(l_1,\fscopep)= L'\\
 H_1,L,\js{e2} \levalsto \fault}
{H,L,\js{e1(e2)} \levalsto \fault}
\\[\gap]
\staterule{(Function Call-\fault3)}
{H,L,\js{e1} \levalsto H_1,r_1\qquad
 \pickThis(H_1,\njs{r_1})=l_2\qquad
 \getValue(H_1,r_1)=l_1\\
 l_1\neq\lge\qquad H_1(l_1,\bodyp)=\lambda \js{x.e3}\qquad
 H_1(l_1,\fscopep)= L'\\
 H_1,L,\js{e2} \gevalsto H_2,\njs{v}\\
 H_3 = H_2\sep\activ(l,\js x,v,\js{e3},l_2)\qquad
 H_3,l\cons L',\js{e3} \levalsto \fault}
{H,L,\js{e1(e2)} \levalsto \fault}
\\[\gap]



\staterule{(Eval-\fault1)}
{H,L,\js{e1} \levalsto \fault}
{H,L,\js{e1(e2)} \levalsto \fault}
\\[\gap]
\staterule{(Eval-\fault2)}
{H,L,\js{e1} \gevalsto H_1,\lge\qquad 
 H_1,L,\js{e2} \levalsto \fault}
{H,L,\js{e1(e2)} \levalsto \fault}
\\[\gap]
\staterule{(Eval-parse-fail)}
{H,L,\js{e1} \gevalsto H_1,\lge\qquad 
 H_1,L,\js{e2} \gevalsto H_2,\js{s}\\ 
 \neg\exists\js{e}\st\parse(\js s)=\js{e}}
{H,L,\js{e1(e2)} \levalsto \fault}
\\[\gap]
\staterule{(Eval-\fault3)}
{H,L,\js{e1} \gevalsto H_1,\lge\qquad 
 H_1,L,\js{e2} \gevalsto H_2,\js{s}\\ 
 \parse(\js s)=\js{e}\qquad
 H_2,L,\js {e}\levalsto \fault}
{H,L,\js{e1(e2)} \levalsto \fault}
\\[\gap]


\staterule{(New-\fault1)}
{H,L,\js{e1} \levalsto \fault}
{H,L,\js{new e1(e2)} \levalsto \fault}
\\[\gap]
\staterule{(New-notafunc)}
{H,L,\js{e1} \gevalsto H_1,\njs{l_1} \qquad
 (l_1,\bodyp)\not\in\domain(H_1)}
{H,L,\js{new e1(e2)} \levalsto \fault}
\\[\gap]
\staterule{(New-notaref)}
{H,L,\js{e1} \gevalsto H_1,v \qquad
v\not\in\refs}
{H,L,\js{new e1(e2)} \levalsto \fault}
\\[\gap]
\staterule{(New-\fault2)}
{H,L,\js{e1} \gevalsto H_1,\njs{l_1} \qquad
 l_1\neq \nil\qquad
 H_1(l_1,\bodyp)=\lambda \js{x.e3}\\
 H_1(l_1,\fscopep)= L'\qquad
 H_1(l_1,\js{prototype})= v\\
H_1,L,\js{e2} \levalsto \fault}
{H,L,\js{new e1(e2)} \levalsto \fault}
\\[\gap]
\staterule{(New-\fault3)}
{H,L,\js{e1} \gevalsto H_1,\njs{l_1} \qquad
 l_1\neq \nil\qquad
 H_1(l_1,\bodyp)=\lambda \js{x.e3}\\
 H_1(l_1,\fscopep)= L'\qquad
 H_1(l_1,\js{prototype})= v\\
H_1,L,\js{e2} \gevalsto H_2,\njs{v_1}  \qquad  
 l_2 = \objOrGlob(v) \\
 H_3 = H_2\sep \obj(l_3,l_2) \sep\activ(l,\js x,v_1,\js{e3},l_3)\\ 
 H_3,l\cons L',\js{e3} \levalsto \fault}
{H,L,\js{new e1(e2)} \levalsto \fault}
\\[\gap]

%\staterule{(Function Call)}
%{H,L,\js{e1} \levalsto H_1,r_1\\ 
% \pickThis(H_1,\njs{r_1})=l_2\\
% \getValue(H_1,r_1)=l_1\\
% l_1\neq\lge\\
% H_1(l_1,\bodyp)=\lambda \js{x.e3}\\
% H_1(l_1,\fscopep)= L'\\
% H_1,L,\js{e2} \gevalsto H_2,\njs{v}\\
% H_3 = H_2\sep\activ(l,\js x,v,\js{e3},l_2)\\
% H_3,l\cons L',\js{e3} \gevalsto H',\njs{v'}}
%{H,L,\js{e1(e2)} \levalsto H',\njs{v'}}
%\rsep
%%
%\staterule{(Eval)}
%{H,L,\js{e1} \gevalsto H_1,\lge\\ 
% H_1,L,\js{e2} \gevalsto H_2,\js{s}\\ 
% \parse(\js s)=\js{e}\\
% H_2,L,\js {e}\gevalsto H',v'}
%{H,L,\js{e1(e2)} \levalsto H',\njs{v'}}
%\\[\gap]
%
%
%\staterule{(New)}
%{H,L,\js{e1} \gevalsto H_1,\njs{l_1} \\
% l_1\neq \nil\\
% H_1(l_1,\bodyp)=\lambda \js{x.e3}\\
% H_1(l_1,\fscopep)= L'\\    
% H_1(l_1,\js{prototype})= v\\ 
% l_2 = \objOrGlob(v) \\  
% H_1,L,\js{e2} \gevalsto H_2,\njs{v_1} \\
% H_3 = H_2\sep \obj(l_3,l_2) \sep\activ(l,\js x,v_1,\js{e3},l_3)\\ 
% H_3,l\cons L',\js{e3} \gevalsto H',v_2\\  
% \getBase(l_3,v_2) = l'}
%{H,L,\js{new e1(e2)} \levalsto H',\njs{l'}}
%\\[\gap]




%
% STATEMENTS
%

\staterule{(Sequence-\fault1)}
{H,L,\js{e1}\levalsto \fault}
{H,L, \js{e1 ; e2} \levalsto \fault}
\rsep
%
\staterule{(Sequence-\fault2)}
{H,L,\js{e1}\levalsto H'',\njs{r}'\\ H'',L,\js{e2}\levalsto\fault}
{H,L, \js{e1 ; e2} \levalsto \fault}
\\[\gap]

\staterule{(With-not-a-pointer)}
{H,L,\js{e1} \gevalsto H_1,v\\
v\not\in\loc}
{H,L,\js{with(e1)\{e2\}} \levalsto \fault}
\\[\gap]

\staterule{(With-\fault1)}
{H,L,\js{e1} \levalsto\fault}
{H,L,\js{with(e1)\{e2\}} \levalsto \fault}
\rsep
%
\staterule{(With-\fault2)}
{H,L,\js{e1} \gevalsto H_1,l\\
 H_1,l\cons L,\js{e2} \levalsto \fault}
{H,L,\js{with(e1)\{e2\}} \levalsto \fault}
\\[\gap]
  
\staterule{(If Guard-\fault)}
{H,L,\js{e1} \levalsto \fault}
{H,L,\js{if(e1)\{e2\}\{e3\}} \levalsto \fault}
\\[\gap]

\staterule{(If True-\fault)}
{H,L,\js{e1} \gevalsto H'',\njs{v} \qquad
 \istrue(\njs{v})\qquad
 H'',L,\js{e2} \levalsto \fault}
{H,L,\js{if(e1)\{e2\}\{e3\}} \levalsto \fault}
\\[\gap]


\staterule{(If False-\fault)}
{H,L,\js{e1} \gevalsto H'',\njs{v} \qquad
 \isfalse(\njs{v}) \qquad
 H'',L,\js{e3} \levalsto \fault}
{H,L,\js{if(e1)\{e2\}\{e3\}} \levalsto \fault}
\\[\gap]

\staterule{(While Guard-\fault)}
{H,L,\js{e1} \evalsto \fault}
{H,L,\js{while(e1)\{e2\}} \levalsto \fault}
\\[\gap]

\staterule{(While Body-\fault)}
{H,L,\js{e1} \gevalsto H'',\njs{v} \qquad
 \istrue(\njs{v}) \\ 
 H'',L,\js{e2;while(e1)\{e2\}} \levalsto \fault}
{H,L,\js{while(e1)\{e2\}} \levalsto \fault}
\\[\gap]




\end{display}
%


%
%------------------------------------------
%
%\begin{display}{Operational Semantics: $H,L,\js e\levalsto H',r$.}
%%
%Notation: $H,L,\js{e} \gevalsto H',v \triangleq \exists r. (H,L,\js{e} \levalsto H',r \wedge \getValue(H',r) = v)$.\\[\gap]
%
%
%
%%
%% EXPRESSIONS
%%
%
%\staterule{(Definition)}
%{H,L,\js{e}\levalsto H',v}
%{H,L,\js{var e} \levalsto H',\und}
%\rsep  
%\staterule{(Definition - \fault)}
%{H,L,\js{e}\levalsto H',v}
%{H,L,\js{var e} \levalsto H',\und}
%%
%\\[\gap]
%\stateaxiom{(Value)}
%{H,L,\js{v} \levalsto H,\js{v} }
%\rsep  
%
%
%
%\staterule{(Member Access)}
%{H,L,\js{e} \gevalsto H',l' \\
% l'\neq \nil}
%{H,L,\js{e.x} \levalsto H',l'\sv\js{x}}
%\rsep
%%
%\staterule{(Member Access - \nil)}
%{H,L,\js{e} \gevalsto H',l' \\
% l'=\nil}
%{H,L,\js{e.x} \levalsto \fault}
%\\[\gap]
%%
%\staterule{(Member Access - \fault)}
%{H,L,\js{e} \levalsto \fault}
%{H,L,\js{e.x} \levalsto \fault}
%\rsep
%%
%\staterule{(Member Access - not a reference)}
%{H,L,\js{e} \gevalsto H',v \\
% v \not\in\loc}
%{H,L,\js{e.x} \levalsto \fault}
%\\[\gap]
%
%\staterule{(Computed Access)}
%{H,L,\js{e1} \gevalsto H_1,l' \\
% l'\neq \nil\\
% H_1,L,\js{e2} \gevalsto H',\js x}
%{H,L,\js{e1[e2]} \levalsto H',l'\sv \js x}
%\rsep
%%
%\staterule{(Computed Access - \fault1)}
%{H,L,\js{e1} \levalsto \fault}
%{H,L,\js{e1[e2]} \levalsto \fault}
%\\[\gap]
%
%\staterule{(Computed Access - \nil)}
%{H,L,\js{e1} \gevalsto H_1,l' \\
% l'= \nil}
%{H,L,\js{e1[e2]} \levalsto \fault}
%\rsep
%%
%\staterule{(Computed Access - \fault2)}
%{H,L,\js{e1} \gevalsto H_1,l' \\
% l'\neq \nil\\
% H_1,L,\js{e2} \levalsto \fault}
%{H,L,\js{e1[e2]} \levalsto H',l'\sv \js x}
%\\[\gap]
%\staterule{(Computed Access - not a reference)}
%{H,L,\js{e1} \levalsto H',v\\
%v \not\in\loc}
%{H,L,\js{e1[e2]} \levalsto \fault}
%\\[\gap]
%
%
%\staterule{(Variable )}
%{\scope(H,L,\js{x})=l' }
%{H,L,\js{x} \levalsto H,l'\sv\js{x}}
%\rsep
%%
%\staterule{(Object)}
%{H_0 = H \sep \obj(l',\lop)\\
% \forall i\in 1..n.\left(\begin{array}{l}
%  H_{i-1},L,\js{ei}\gevalsto H_i',\njs{v_i} \\ 
%  H_i = H_i' \semup{ (l',\js{xi}) \pointsto \njs{v_i}}\end{array}\right)}
%{H,L,\{\js{x1:e1},\dots, \js{xn:en}\} \levalsto H_n,l'}
%\\[\gap]
%\staterule{(Object-\fault)}
%{H_0 = H \sep \obj(l',\lop)\\
%\exists j\in 1.n\st\left(\begin{array}{l}
% \forall i\in 1..j.\left(\begin{array}{l}
%  H_{i-1},L,\js{ei}\gevalsto H_i',\njs{v_i} \\ 
%  H_i = H_i' \semup{ (l',\js{xi}) \pointsto \njs{v_i}}\end{array}\right)\\
%H_{j-1},L,\js{ej}\levalsto\fault\end{array}\right)}
%{H,L,\{\js{x1:e1},\dots, \js{xn:en}\} \levalsto \fault}
%\\[\gap]  
%
%
%\staterule{(Binary Operators)}
%{H,L,\js{e1} \gevalsto H'',\js{v1}\\
% H'',L,\js{e2} \gevalsto H',\js{v2}\\
% \js{v1}\primop\js{v2}=\js{v}}
%{H,L, \js{e1} \oplus \js{e2} \levalsto H',\js{v}}
%\rsep
%%
%\staterule{(Binary Operators-\fault1)}
%{H,L,\js{e1} \levalsto \fault}
%{H,L, \js{e1} \oplus \js{e2} \levalsto \fault}
%\\[\gap]
%\staterule{(Binary Operators-\fault2)}
%{H,L,\js{e1} \gevalsto H'',\js{v1}\\
% H'',L,\js{e2} \levalsto \fault}
%{H,L, \js{e1} \oplus \js{e2} \levalsto \fault}
%\rsep
%%
%\staterule{(Binary Operators-partial)}
%{H,L,\js{e1} \gevalsto H'',\js{v1}\\
% H'',L,\js{e2} \gevalsto H',\js{v2}\\
% \neg\exists\js{v}\st\js{v1}\primop\js{v2}=\js{v}}
%{H,L, \js{e1} \oplus \js{e2} \levalsto \fault}
%\\[\gap]
%\staterule{(Assignment)}
%{H,L,\js{e1} \levalsto H_1,l'\sv\js{x}\\
% H_1,L,\js{e2} \gevalsto H_2,\njs{v}\\
% H'=H_2\semup{(l',\js{x})\pointsto\njs{v}}}
%{H,L,\js{e1=e2} \levalsto H',\njs{v}}
%\rsep
%%
%\staterule{(Assignment-\fault1)}
%{H,L,\js{e1} \levalsto \fault}
%{H,L,\js{e1=e2} \levalsto \fault}
%\\[\gap]
%\staterule{(Assignment-notref)}
%{H,L,\js{e1} \levalsto H_1,\js{v}\\
%\neg\exists l',\js{x}\st \js{v}=l'\sv\js{x}}
%{H,L,\js{e1=e2} \levalsto\fault}
%\rsep
%%
%\staterule{(Assignment-\fault2)}
%{H,L,\js{e1} \levalsto H_1,l'\sv\js{x}\\
% H_1,L,\js{e2} \levalsto\fault}
%{H,L,\js{e1=e2} \levalsto\fault}
%\\[\gap]
%
%
%\staterule{(Delete True)}
%{H,L,\js{e} \levalsto H',r\quad
%\ReadWrite(H,r)\\
% H'' = H'\setminus \njs{r}}
%{H,L,\js{delete e} \levalsto H'',1}
%\rsep
%%
%\staterule{(Delete False)}
%{H,L,\js{e} \levalsto H',r\quad
%\ReadOnly(H,r)}
%{H,L,\js{delete e} \levalsto H',0}
%%
%\staterule{(Delete-\fault)}
%{H,L,\js{e} \levalsto \fault}
%{H,L,\js{delete e} \levalsto \fault}
%\\[\gap]
%\staterule{(Delete-not a reference)}
%{H,L,\js{e} \levalsto H',v\\
%v\not\in\refs}
%{H,L,\js{delete e} \levalsto \fault}
%\\[\gap]
%
%
%\staterule{(This)}
%{\scope(H,L,\thisp)=l_1 \\ \proto(H,l_1,\thisp)=l_2\\ H(l_2,\thisp)=l'}
%{H,L,\js{this} \levalsto H,l'}
%~
%%
%\staterule{(Function)}
%{H' = H \sep \obj(l,\lop) \sep \func(l',L,\js x,\js e,l)}
%{H,L,\jsfun{x}{e} \levalsto H',l'}
%\\[\gap]
%
%
%\staterule{(Named Function)}
%{H' = H \sep \obj(l,\lop)\sep \func(l',l_1\ty L,\js x,\js e,l) \sep l_1\pointsto\{\protop\ty \lop,\js{y}\ty l'\}}
%{H,L,\jsfun[y]{x}{e} \levalsto H',l'}
%\\[\gap]
%
%
%\staterule{(Function Call)}
%{H,L,\js{e1} \levalsto H_1,r_1\qquad
% \pickThis(H_1,\njs{r_1})=l_2\qquad
% \getValue(H_1,r_1)=l_1\\
% l_1\neq\lge\qquad H_1(l_1,\bodyp)=\lambda \js{x.e3}\qquad
% H_1(l_1,\fscopep)= L'\\
% H_1,L,\js{e2} \gevalsto H_2,\njs{v}\\
% H_3 = H_2\sep\activ(l,\js x,v,\js{e3},l_2)\qquad
% H_3,l\cons L',\js{e3} \gevalsto H',\njs{v'}}
%{H,L,\js{e1(e2)} \levalsto H',\njs{v'}}
%\\[\gap]
%\staterule{(Function Call-\fault1)}
%{H,L,\js{e1} \levalsto \fault}
%{H,L,\js{e1(e2)} \levalsto \fault}
%\\[\gap]
%\staterule{(Function Call-notfunc)}
%{H,L,\js{e1} \levalsto H_1,r_1\qquad
% \getValue(H_1,r_1)=l_1\\
% l_1\neq\lge\qquad
% (l_1,\bodyp)\not\in\domain(H_1) }
%{H,L,\js{e1(e2)} \levalsto \fault}
%\\[\gap]
%\staterule{(Function Call-notref)}
%{H,L,\js{e1} \levalsto H_1,r_1\qquad
% \getValue(H_1,r_1)=v\\
%v\not\in\refs}
%{H,L,\js{e1(e2)} \levalsto \fault}
%\\[\gap]
%\staterule{(Function Call-\fault2)}
%{H,L,\js{e1} \levalsto H_1,r_1\qquad
% \pickThis(H_1,\njs{r_1})=l_2\qquad
% \getValue(H_1,r_1)=l_1\\
% l_1\neq\lge\qquad H_1(l_1,\bodyp)=\lambda \js{x.e3}\qquad
% H_1(l_1,\fscopep)= L'\\
% H_1,L,\js{e2} \levalsto \fault}
%{H,L,\js{e1(e2)} \levalsto \fault}
%\\[\gap]
%\staterule{(Function Call-\fault3)}
%{H,L,\js{e1} \levalsto H_1,r_1\qquad
% \pickThis(H_1,\njs{r_1})=l_2\qquad
% \getValue(H_1,r_1)=l_1\\
% l_1\neq\lge\qquad H_1(l_1,\bodyp)=\lambda \js{x.e3}\qquad
% H_1(l_1,\fscopep)= L'\\
% H_1,L,\js{e2} \gevalsto H_2,\njs{v}\\
% H_3 = H_2\sep\activ(l,\js x,v,\js{e3},l_2)\qquad
% H_3,l\cons L',\js{e3} \levalsto \fault}
%{H,L,\js{e1(e2)} \levalsto \fault}
%\\[\gap]
%
%
%\staterule{(Eval)}
%{H,L,\js{e1} \gevalsto H_1,\lge\qquad 
% H_1,L,\js{e2} \gevalsto H_2,\js{s}\\ 
% \parse(\js s)=\js{e}\qquad
% H_2,L,\js {e}\gevalsto H',v'}
%{H,L,\js{e1(e2)} \levalsto H',\njs{v'}}
%\\[\gap]
%\staterule{(Eval-\fault1)}
%{H,L,\js{e1} \levalsto \fault}
%{H,L,\js{e1(e2)} \levalsto \fault}
%\\[\gap]
%\staterule{(Eval-\fault2)}
%{H,L,\js{e1} \gevalsto H_1,\lge\qquad 
% H_1,L,\js{e2} \levalsto \fault}
%{H,L,\js{e1(e2)} \levalsto \fault}
%\\[\gap]
%\staterule{(Eval-parse-fail)}
%{H,L,\js{e1} \gevalsto H_1,\lge\qquad 
% H_1,L,\js{e2} \gevalsto H_2,\js{s}\\ 
% \neg\exists\js{e}\st\parse(\js s)=\js{e}}
%{H,L,\js{e1(e2)} \levalsto \fault}
%\\[\gap]
%\staterule{(Eval-\fault3)}
%{H,L,\js{e1} \gevalsto H_1,\lge\qquad 
% H_1,L,\js{e2} \gevalsto H_2,\js{s}\\ 
% \parse(\js s)=\js{e}\qquad
% H_2,L,\js {e}\levalsto \fault}
%{H,L,\js{e1(e2)} \levalsto \fault}
%\\[\gap]
%
%
%\staterule{(New)}
%{H,L,\js{e1} \gevalsto H_1,\njs{l_1} \qquad
% l_1\neq \nil\qquad
% H_1(l_1,\bodyp)=\lambda \js{x.e3}\\
% H_1(l_1,\fscopep)= L'\qquad
% H_1(l_1,\js{prototype})= v\\
%H_1,L,\js{e2} \gevalsto H_2,\njs{v_1}  \qquad  
% l_2 = \objOrGlob(v) \\
% H_3 = H_2\sep \obj(l_3,l_2) \sep\activ(l,\js x,v_1,\js{e3},l_3)\\ 
% H_3,l\cons L',\js{e3} \gevalsto H',v_2\qquad
% \getBase(l_3,v_2) = l'}
%{H,L,\js{new e1(e2)} \levalsto H',\njs{l'}}
%\\[\gap]
%\staterule{(New-\fault1)}
%{H,L,\js{e1} \levalsto \fault}
%{H,L,\js{new e1(e2)} \levalsto \fault}
%\\[\gap]
%\staterule{(New-notafunc)}
%{H,L,\js{e1} \gevalsto H_1,\njs{l_1} \qquad
% (l_1,\bodyp)\not\in\domain(H_1)}
%{H,L,\js{new e1(e2)} \levalsto \fault}
%\\[\gap]
%\staterule{(New-notaref)}
%{H,L,\js{e1} \gevalsto H_1,v \qquad
%v\not\in\refs}
%{H,L,\js{new e1(e2)} \levalsto \fault}
%\\[\gap]
%\staterule{(New-\fault2)}
%{H,L,\js{e1} \gevalsto H_1,\njs{l_1} \qquad
% l_1\neq \nil\qquad
% H_1(l_1,\bodyp)=\lambda \js{x.e3}\\
% H_1(l_1,\fscopep)= L'\qquad
% H_1(l_1,\js{prototype})= v\\
%H_1,L,\js{e2} \levalsto \fault}
%{H,L,\js{new e1(e2)} \levalsto \fault}
%\\[\gap]
%\staterule{(New-\fault3)}
%{H,L,\js{e1} \gevalsto H_1,\njs{l_1} \qquad
% l_1\neq \nil\qquad
% H_1(l_1,\bodyp)=\lambda \js{x.e3}\\
% H_1(l_1,\fscopep)= L'\qquad
% H_1(l_1,\js{prototype})= v\\
%H_1,L,\js{e2} \gevalsto H_2,\njs{v_1}  \qquad  
% l_2 = \objOrGlob(v) \\
% H_3 = H_2\sep \obj(l_3,l_2) \sep\activ(l,\js x,v_1,\js{e3},l_3)\\ 
% H_3,l\cons L',\js{e3} \levalsto \fault}
%{H,L,\js{new e1(e2)} \levalsto \fault}
%\\[\gap]
%
%%\staterule{(Function Call)}
%%{H,L,\js{e1} \levalsto H_1,r_1\\ 
%% \pickThis(H_1,\njs{r_1})=l_2\\
%% \getValue(H_1,r_1)=l_1\\
%% l_1\neq\lge\\
%% H_1(l_1,\bodyp)=\lambda \js{x.e3}\\
%% H_1(l_1,\fscopep)= L'\\
%% H_1,L,\js{e2} \gevalsto H_2,\njs{v}\\
%% H_3 = H_2\sep\activ(l,\js x,v,\js{e3},l_2)\\
%% H_3,l\cons L',\js{e3} \gevalsto H',\njs{v'}}
%%{H,L,\js{e1(e2)} \levalsto H',\njs{v'}}
%%\rsep
%%%
%%\staterule{(Eval)}
%%{H,L,\js{e1} \gevalsto H_1,\lge\\ 
%% H_1,L,\js{e2} \gevalsto H_2,\js{s}\\ 
%% \parse(\js s)=\js{e}\\
%% H_2,L,\js {e}\gevalsto H',v'}
%%{H,L,\js{e1(e2)} \levalsto H',\njs{v'}}
%%\\[\gap]
%%
%%
%%\staterule{(New)}
%%{H,L,\js{e1} \gevalsto H_1,\njs{l_1} \\
%% l_1\neq \nil\\
%% H_1(l_1,\bodyp)=\lambda \js{x.e3}\\
%% H_1(l_1,\fscopep)= L'\\    
%% H_1(l_1,\js{prototype})= v\\ 
%% l_2 = \objOrGlob(v) \\  
%% H_1,L,\js{e2} \gevalsto H_2,\njs{v_1} \\
%% H_3 = H_2\sep \obj(l_3,l_2) \sep\activ(l,\js x,v_1,\js{e3},l_3)\\ 
%% H_3,l\cons L',\js{e3} \gevalsto H',v_2\\  
%% \getBase(l_3,v_2) = l'}
%%{H,L,\js{new e1(e2)} \levalsto H',\njs{l'}}
%%\\[\gap]
%
%
%
%
%%
%% STATEMENTS
%%
%
%\staterule{(Sequence)}
%{H,L,\js{e1}\levalsto H'',\njs{r}'\\ H'',L,\js{e2}\levalsto H',\njs{r}}
%{H,L, \js{e1 ; e2} \levalsto H',\njs{r}}
%\rsep
%%
%\staterule{(Sequence-\fault1)}
%{H,L,\js{e1}\levalsto \fault}
%{H,L, \js{e1 ; e2} \levalsto \fault}
%\rsep
%%
%\staterule{(Sequence-\fault2)}
%{H,L,\js{e1}\levalsto H'',\njs{r}'\\ H'',L,\js{e2}\levalsto\fault}
%{H,L, \js{e1 ; e2} \levalsto \fault}
%\\[\gap]
%
%\staterule{(With)}
%{H,L,\js{e1} \gevalsto H_1,l\\
% H_1,l\cons L,\js{e2} \levalsto H', \njs{r}}
%{H,L,\js{with(e1)\{e2\}} \levalsto H',r}
%\rsep
%%
%\staterule{(With-not a reference)}
%{H,L,\js{e1} \gevalsto H_1,v\\
%v\not\in\refs}
%{H,L,\js{with(e1)\{e2\}} \levalsto \fault}
%\\[\gap]
%
%\staterule{(With-\fault1)}
%{H,L,\js{e1} \levalsto\fault}
%{H,L,\js{with(e1)\{e2\}} \levalsto \fault}
%\rsep
%%
%\staterule{(With-\fault2)}
%{H,L,\js{e1} \gevalsto H_1,l\\
% H_1,l\cons L,\js{e2} \levalsto \fault}
%{H,L,\js{with(e1)\{e2\}} \levalsto \fault}
%\\[\gap]
%  
%\staterule{(If Guard-\fault)}
%{H,L,\js{e1} \levalsto \fault}
%{H,L,\js{if(e1)\{e2\}\{e3\}} \levalsto \fault}
%\\[\gap]
%
%\staterule{(If True)}
%{H,L,\js{e1} \gevalsto H'',\njs{v} \qquad
% \istrue(\njs{v})\qquad
% H'',L,\js{e2} \levalsto H',\njs{r}}
%{H,L,\js{if(e1)\{e2\}\{e3\}} \levalsto H',\njs{r} }
%\\[\gap]
%\staterule{(If True-\fault)}
%{H,L,\js{e1} \gevalsto H'',\njs{v} \qquad
% \istrue(\njs{v})\qquad
% H'',L,\js{e2} \levalsto \fault}
%{H,L,\js{if(e1)\{e2\}\{e3\}} \levalsto \fault}
%\\[\gap]
%
%
%\staterule{(If False)}
%{H,L,\js{e1} \gevalsto H'',\njs{v} \qquad
% \isfalse(\njs{v}) \qquad
% H'',L,\js{e3} \levalsto H',\njs{r}}
%{H,L,\js{if(e1)\{e2\}\{e3\}} \levalsto H',\njs{r}}
%\\[\gap]
%\staterule{(If False-\fault)}
%{H,L,\js{e1} \gevalsto H'',\njs{v} \qquad
% \isfalse(\njs{v}) \qquad
% H'',L,\js{e3} \levalsto \fault}
%{H,L,\js{if(e1)\{e2\}\{e3\}} \levalsto \fault}
%\\[\gap]
%
%\staterule{(While Guard-\fault)}
%{H,L,\js{e1} \evalsto \fault}
%{H,L,\js{while(e1)\{e2\}} \levalsto \fault}
%\\[\gap]
%
%\staterule{(While True)}
%{H,L,\js{e1} \gevalsto H'',\njs{v} \qquad
% \istrue(\njs{v}) \\ 
% H'',L,\js{e2;while(e1)\{e2\}} \levalsto H',\njs{r}}
%{H,L,\js{while(e1)\{e2\}} \levalsto H',\und }
%\\[\gap]
%\staterule{(While Body-\fault)}
%{H,L,\js{e1} \gevalsto H'',\njs{v} \qquad
% \istrue(\njs{v}) \\ 
% H'',L,\js{e2;while(e1)\{e2\}} \levalsto \fault}
%{H,L,\js{while(e1)\{e2\}} \levalsto \fault}
%\\[\gap]
%
%
%\staterule{(While False)}
%{H,L,\js{e1} \gevalsto H'',\njs{v} \qquad
% \isfalse(\njs{v})}
%{H,L,\js{while(e1)\{e2\}} \levalsto H'',\und }
%
%
%
%\end{display}
%
\begin{display}{Auxiliary Functions}
%
$\obj(l,l')\ \triangleq\ (l,\protop)\mapsto l'$\\
%
$\begin{array}{l}
\ReadOnly(H,l\sv\js{x})\triangleq (\js{x}=\js{prototype}\wedge (l,\bodyp)\in\domain(H))\\
\ReadWrite(H,r)\triangleq r\not\in\refs \vee \neg \ReadOnly(H,r)\end{array}$\\
%
$\func(l',L,\js x,\js e,l)\triangleq$\\
$ l'\mapsto\{\protop\ty\lfp,\js{prototype}\ty l,\fscopep\ty L,\bodyp\ty\lambda \js{x.e}\}$\\
%
$\begin{array}{rlll}
        \pickThis(H,l\sv \js{x})&\triangleq &l &[(l,\thisp)\not\in dom(H)]\\
        \pickThis(H,\njs{r})&\triangleq& \lgo &[\text{otherwise}]
\end{array}$\\
%
$\activ(l,\js{x},\njs{v},\js{e},l'') \triangleq$\\
$l\pointsto\{\js{x}\ty \njs{v},\thisp\ty l'',\protop\ty \nil\}\sep \defs(\js{x},l,\js{e})$\\
%
$\begin{array}{rll}
        \objOrGlob(l)&\triangleq& l\\
        \objOrGlob(v)&\triangleq& \lop \qquad[v\not\in\loc]
\end{array}$\\
%
$\begin{array}{rll}
        \getBase(l,l')&\triangleq& l'\\
        \getBase(l,v)&\triangleq & l\qquad[v\not\in\loc]
\end{array}$\\
%
$\begin{array}{rll}
        \istrue(v)&\triangleq& v\not\in\falsity\\
        \isfalse(v)&\triangleq &v\in\falsity
\end{array}$
%
\end{display}




\stitle{Well-formedness}
%
We define a ``Well-formed
heap'' (denoted by $\isok$), using the intermediate concept of a ``Valid heap'' (denoted by $\iswf$), according to the following rules.
  
  \begin{display}{Well-formedness for heaps: $H\iswf$, $\schain(H,L)$, $H\isok$.}
  %
  \staterule{}
  {(l,\protop)\in\domain(H)\\
  H\iswf}
  {H\sep(l,\js{x})\pointsto\js{u}\iswf}
  \rsep
  %
  \staterule{}
  {(l,\protop)\in\domain(H)\\
  (l',\protop)\in\domain(H)\\
  H\iswf}
  {H\sep(l,\js{x})\pointsto l'\iswf}
  \\[\gap]
  
  \staterule{}
  {(l',\protop)\in\domain(H)\\
  H\iswf}
  {H\sep(l,\protop)\pointsto l'\iswf}
  \rsep
  %
  \staterule{}
  {(l',\protop)\in\domain(H)\\
  H(l,\protop)=\nil\\
  H\iswf}
  {H\sep(l,\thisp)\pointsto l'\iswf}
  \\[\gap]
  %
  \staterule{}
  {}
  {\emp\iswf}
  \rsep
  %
  \staterule{}
  {H\iswf}
  {H\sep(l,\protop)\pointsto \nil\iswf}
  \\[\gap]
  
  \staterule{}
  {(l,\protop)\in\domain(H)\\
  (l',\protop)\in\domain(H)\\
 % l\neq l'\\ % commented this out because at runtime it can happen
  \schain(H,L)\\
  H\iswf}
  {H\sep l\pointsto\{\scopep\ty L, \bodyp\ty \lambda\js{y.e}, \js{prototype}\ty l'\}\iswf}
  \\[\gap]
  
  \staterule{}
  {\lgo\in L\\
  \forall l\in L. (l,\protop)\in \domain(H)}
  {\schain(H,L\append [\lgs])}
  \rsep
  %  
  \staterule{}
  {H\iswf\\
  (\lop,\protop)\in\domain(H)\\
  (\lfp,\protop)\in\domain(H)\\
  (\lge,\protop)\in\domain(H)\\  
  H(\lgs,\thisp) = \lgo}
  {H\isok}
  %
  \end{display}
%
%\remark{SM: note that although now any object (with a \nil prototype) can have a \thisp, it will be useful only when they are in a scope chain. moreover, we can have many prototype chains ending in \nil, but again that should not break the semantics (such heaps are not legal JavaScript heaps).}

%We only consider executions of programs that begin in well formed
%heaps, with valid scope chains. As noted in Section~\ref{sec:syntax2},
%many browsers begin execution with a slightly different heap. To
%handle this case, we introduce an alternative definition of a well
%formed heap, denoted $\isokgs$.
%
%\begin{display}{Alternative well-formedness rules: $\schaings(H,L)$ and $H\isokgs$.}
%
%  \staterule{}
%  {\lgo\in L\\
%  \forall l\in L. (l,\protop)\in \domain(H)}
%  {\schaings(H,L\append [\lgs])}
%  \rsep
%  %  
%  \staterule{}
%  {H\iswf\\
%  (\lgo,\protop)\in\domain(H)\\
%  (\lop,\protop)\in\domain(H)\\
%  (\lfp,\protop)\in\domain(H)\\
%  (\lge,\protop)\in\domain(H)\\
%  H(\lgs,\protop)=\nil}
%  {H\sep(\lgs,\thisp)\pointsto\lgo\isokgs}
%  %
%  \end{display}
%
%
%\stitle{Defined variables}
%%
%The rules to determine the local variables defined by a function body are reported below.
%
%\remark{SM: since \js{var x} is actually a statement, it cannot appear in the guard of an if-then-else etc, so the fact that we do pick up definitions also from there does not constitute a problem.}

% Defined variables of JLB
%
\begin{display}{Local Variable Definition.}
\jrule{\defs(\js x,l,\js{var}\ \js{y}) 		}{ (l,\js y) \pointsto \und}{\js x\neq \js y}\\[\gap]
\qrule{\defs(\js x,l,\js{e1 = e2}) 			}{ \defs(\js x,l,\js{e1}) }{} \\
\qrule{\defs(\js x,l,\js{e1;e2}) 				}{ \defs(\js x,l,\js{e1})\cup \defs(\js x,l,\js{e2})}{}\\
\qrule{\defs(\js x,l,\js{if(e1)\{e2\}\{e3\}}) 	}{ \defs(\js x,l,\js{e2}) \cup \defs(\js x,l,\js{e3})}{} \\
\qrule{\defs(\js x,l,\js{while(e1)\{e2\}}) 		}{ \defs(\js x,l,\js{e2})}{} \\
\qrule{\defs(\js x,l,\js{with(e1)\{e2\}}) 		}{ \defs(\js x,l,\js{e2})}{} \\[\gap]
\jrule{\defs(\js x,l,\js e) 					}{\emp}{otherwise}
\end{display}

%\begin{display}{Local Variable Definition.}
%\jrule{\defs(\js x,l,\js{var}\ \js{y}) 		}{ (l,\js y) \pointsto \und}{\js x\neq \js y}\\[\gap]
%\qrule{\defs(\js x,l,\js{var}\ \js{x}) 		}{ \emp}{}\\
%\qrule{\defs(\js x,l,\js{e1}\oplus \js{e2}) 	}{ \defs(\js x,l,\js{e1}) \sep \defs(\js x,l,\js{e2})}{} \\
%\qrule{\defs(\js x,l,\js{e.x}) 				}{ \defs(\js x,l,\js e)}{} \\
%\qrule{\defs(\js x,l,\js{e1(e2)}) 				}{ \defs(\js x,l,\js{e1}) \sep \defs(\js x,l,\js{e2})}{} \\
%\qrule{\defs(\js x,l,\js{e1 = e2}) 			}{ \defs(\js x,l,\js{e1}) \sep \defs(\js x,l,\js{e2})}{} \\
%\qrule{\defs(\js x,l,\js{\{x1:e1 \dots xn:en\}}) }{ \sep_{i\in 1..n}\defs(\js x,l,\js{ei})}{}\\[\gap]
%\qrule{\defs(\js x,l,\js{e1;e2}) 				}{ \defs(\js x,l,\js{e1})\sep \defs(\js x,l,\js{e2})}{}\\
%\qrule{\defs(\js x,l,\js{if(e1)\{e2\}\{e3\}}) 	}{ \sep_{i\in 1..3}\defs(\js x,l,\js{ei})}{}\\
%\qrule{\defs(\js x,l,\js{while(e1)\{e2\}}) 		}{ \defs(\js x,l,\js{e1}) \sep \defs(\js x,l,\js{e2})}{} \\
%\qrule{\defs(\js x,l,\js{with(e1)\{e2\}}) 		}{ \defs(\js x,l,\js{e1}) \sep \defs(\js x,l,\js{e2})}{} \\[\gap]
%\jrule{\defs(\js x,l,\js e) 					}{\emp}{\js e\in\{\js{x},\js{v},\this,\jsfun{x}{e},\jsfun[y]{x}{e}\}}
%\end{display}





























\subsection{Program Logics}\label{sec:tables:logics}

\begin{display}{Notation: Sorts and Constants}
%
\entry{\env\in\lvars \rightharpoonup \lvals}{Logical environment.}\\[\gap]
\entry{\V{v}\in\lvals}{Logical values.}\\[\gap]
\entry{\V{X}\in\lvars}{Logical variables.}\\[\gap]
\entry{\E{E}}{Logical expressions.}\\[\gap]
\entry{\eval{\Expr}^L_{\env}}{Logical evaluation.}\\[\gap]
\entry{av\in\avals \triangleq \vals \cup \{\none\}
}{Abstract values.}\\[\gap]
\entry{h \in (\loc\times\vars) \rightharpoonup\avals}{Abstract heap.}\\[\gap]
\entry{\heval{h}(l,x)}{Heap evaluation.}\\[\gap]
\entry{P}{Logical assertion.}\\[\gap]
\entry{\T{set}}{Generic set.}\\[\gap]
\entry{h,L,{\env} \satisfies P}{Satisfaction relation.}\\[\gap]
\entry{\scope(\Lista,\Listb,\E{X},\E{V})}{Find defining scope.}\\[\gap]
\entry{\proto(\List,\E{L_1},\E{X},\E{L_2})}{Find defining prototype.}\\[\gap]
\entry{\getValue(\List,\E{Ref},\V{V})}{Read from reference.}\\[\gap]
\entry{\pickThis(\E{L_1}\sv\E{X},\E{L_2})}{Determine self pointer.}\\[\gap]
\entry{\istrue(\E{E})}{Determine truth.}\\[\gap]
\entry{\isfalse(\E{E})}{Determine falsity.}\\[\gap]
\entry{\getBase(\E{L_1},\E{V},\E{L_2})}{Determine object for \js{new}.}\\[\gap]
\entry{\newobj(\E{L},\E{V_1},\dots,\E{V_n})}{Allocate object space.}\\[\gap]
\entry{\func(\E{F},\E{Closure},\E{Var},\E{Body},\E{Proto})}{Allocate function space.}\\[\gap]
\entry{\vardecls(\E{X},\E{L},\js e)}{Determine local variables.}\\[\gap]
\entry{\defs(\E{X},\E{L},\js e)}{Allocate local variables.}\\[\gap]
\entry{\tr P{\js e}Q}{Hoare triple.}\\[\gap]
%
\end{display}
%
\begin{display}{Abstract Values and Abstract Heap.}
$av\in\avals \defeq v \pipe \none$\qquad\qquad\qquad\qquad\qquad\qquad\quad
$h : (\loc\times\vars) \rightharpoonup\avals$\\[\gap]
$\heval{h}(l,x) \triangleq h(l,x) \text{ iff } (l,x) \in \domain(h) \land h(l,x) \not= \none$
\end{display}
%
\begin{display}{Logical Expressions and Evaluation: $\eval{\Expr}^L_{\env}$.}
~~~$ \V{v}\in\lvals \defeq e \pipe l\sv x \pipe av \pipe L $\qquad\qquad\qquad\qquad\qquad\quad
$ \env:\lvars \rightharpoonup \lvals$ \\[\gap]
$\begin{array}{rll}
  \Expr \defeq & \V X& \text{Logical variables} \\
  & \pipe \ls & \text{Scope list} \\
  & \pipe \V{v} & \text{Logical values} \\
  &\pipe \Expr \oplus \Expr%\pipe \Expr - \Expr\pipe \Expr * \Expr\pipe \Expr / \Expr & \text{Arithmetic}\\
  %&\pipe \Expr . \Expr 
        & \text{Binary Operators} \\  
  &\pipe \Expr \cons \Expr &\text{List cons} \\
%  &\pipe \Expr \in \T{set} & \text{Expression Type Checking}\\
  & \pipe \Expr \sv \Expr & \text{Reference construction}\\
  & \pipe \lambda\Expr.\Expr & \text{Lambda values}
\end{array}$\\[\gap]
%
~~~\jaxiom{\eval{\V{v}}^L_{\env}}{\V{v}}
\rsep
%
\jaxiom
{\eval{\ls}^L_{\env}}{ L }
\rsep
\jaxiom{\eval{\V{X}}^L_{\env}  }{{\env}(\V{X})}
\\[\gap]


\jrule
{\eval{{\Expr_1}\cons{\Expr_2}}^L_{\env} }{ \eval{{\Expr_1}}^L_{\env} \cons \List}
{\eval{{\Expr_2}}^L_{\env} = \List }
\rsep
%
\jrule
{\eval{{\Expr_1}\sv{\Expr_2}}^L_{\env}  }{ \eval{{\Expr_1}}^L_{\env} \sv \eval{{\Expr_2}}^L_{\env}}
{\eval{{\Expr_1}}^L_{\env} = l' \land \eval{{\Expr_2}}^L_{\env}=\js{x}}
\\[\gap]


\jrule
{\eval{{\Expr_1}\oplus{\Expr_2}}^L_{\env}  }{ v\primop v'}
{\eval{\Expr_1}^L_{\env} = v \land \eval{\Expr_2}^L_{\env} = v'}
\rsep
%
\jrule
{  \eval{\lambda{\Expr_1}.{\Expr_2}}^L_{\env}  }{  \lambda\eval{{\Expr_1}}^L_{\env}.\eval{{\Expr_2}}^L_{\env}}
{ \eval{{\Expr_1}}^L_{\env}=\js{x} }
%
\end{display}
%
\begin{display}{Assertions.}
$\begin{array}{rll}
  P \defeq 
 & P \land P \pipe P \lor P \pipe \neg P \pipe \true \pipe \false & \text{Boolean formulae}\\
 & \pipe P \sep P \pipe P \wand P \pipe P \sepish P %\pipe P \wandish P 
                         & \text{Structural formulae} \\
 & \pipe (\Expr,\Expr)\pointsto \Expr \pipe \lemp % \pipe \cancel{(\Expr,\Expr)}
                         & \text{JavaScript formulae} \\
%  & \pipe \LVAR & \text{logical (auxiliary) variables   TODO: Consider typing them.} \\
 & \pipe \Expr\doteqdot\Expr & \text{Expression equality} \\ % Might want to add string-inclusion?
 & \pipe \Expr \in \T{set} & \text{Set inclusion} \\
 & \pipe \Expr \elem \Expr  & \text{List element} \\
 & \pipe \exists\V{X}\st P  \pipe \forall\V{X}\st P &  \text{Quantification} \\
\end{array}\Gap$\\[\gap]
Notation: $E\not{\!\circ} E \triangleq \neg(E \circ E)$  for ${\circ}\in\{\doteqdot,\in\}$\\
\phantom{Notation: }$\Expr_1 \dot{\,\circ\,}\Expr_2 \triangleq \Expr_1 \circ \Expr_2 \land \lemp$ for ${\circ}\in\{\doteqdot,\not\doteqdot,\in,\notin\}$.
\end{display}
%
\newpage
\begin{display}{Satisfaction of assertions: $h,L,{\env} \satisfies P$.}
$\begin{array}{ll}
  h,L,{\env} \satisfies P \land Q & \iff (h,L,\env \satisfies P) \land (h,L,{\env} \satisfies Q)\\
  h,L,{\env} \satisfies P \lor Q & \iff (h,L,{\env} \satisfies P) \lor (h,L,{\env} \satisfies Q)\\
  h,L,{\env} \satisfies \neg P & \iff \neg (h,L,{\env} \satisfies P) \\
  h,L,{\env} \satisfies \true & \text{Always}\\
  h,L,{\env} \satisfies \false & \text{Never}\\
  
  h,L,{\env} \satisfies P \sep Q & \iff \exists h_1,h_2 \st  h \equiv h_1 \sep h_2 \land \\
        &\quad (h_1,L,{\env} \satisfies P) \land (h_2,L,{\env} \satisfies Q)\\
  h,L,{\env} \satisfies P \wand Q & \iff \forall h_1 \st (h_1,L,{\env} \satisfies P) \land h\mathbin{\#}h_1 \\
        &\qquad\implies ((h \sep h_1),L,{\env} \satisfies Q)\\  
  h,L,{\env} \satisfies P \sepish Q & \iff \exists h_1,h_2,h_3 \st \\
          & \qquad h \equiv h_1 \sep h_2 \sep h_3 \land {}\\
          & \qquad (h_1\sep h_3,L,{\env} \satisfies P) \land {}\\
          & \qquad (h_2\sep h_3,L,{\env} \satisfies Q)\\
  
  h,L,{\env} \satisfies ({\Expr_1},{\Expr_2})\pointsto {\Expr_3} & \iff h \equiv (\eval{{\Expr_1}}^L_{\env},\eval{{\Expr_2}}^L_{\env})\pointsto \eval{{\Expr_3}}^L_{\env}\\
  h,L,\env \satisfies \lemp & \iff h = \emp \\
  
  %h,L,{\env} \satisfies \LVAR & \iff h \equiv {\env}(\LVAR) \\
  
  h,L,{\env} \satisfies {\Expr_1} \doteqdot {\Expr_2} & \iff \eval{{\Expr_1}}^L_{\env} = \eval{{\Expr_2}}^L_{\env} \\
  h,L,{\env} \satisfies \Expr \in \T{set} & \iff \eval{\Expr}^L_{\env} \in \tset \\
  h,L,{\env} \satisfies \Expr_1 \elem \Expr_2 & \iff \eval{\Expr_1}^L_{\env} \text{ is in the list } \eval{\Expr_2}^L_{\env} \\

  h,L,{\env} \satisfies \exists\V X \st P & \iff \exists \V{v} \st h,L,[{\env} | \V X\takes \V{v}] \satisfies P \\
  h,L,{\env} \satisfies \forall\V X \st P & \iff \forall \V{v} \st
      h,L,[{\env} | \V X\takes \V{v}] \satisfies P \\
  h,L,{\env} \satisfies \bigsep_{x\in\{\}}P(x) & \iff h,L,{\env}\satisfies\emp\\
  h,L,{\env} \satisfies \bigsep_{x\in\T{set}}P(x) & \iff y\in\T{set}
  \land h,L,{\env} \satisfies P(y)\sep(\bigsep_{x\in(\T{set}\setminus y)}P(x))\\
\end{array}$
\end{display}
% 
\begin{display}{Logical Predicates: $\scope,\proto,\getValue$.}
$\begin{array}{l}
        \scope({\emptylist},{\emptylist},\_,\nil) ~~\triangleq~~ \lemp\\
        \scope([{\List}],\E{St}:\E{Sc},\E{Var},\E{St}) ~~\triangleq~~ 
         \exists\V{L}\st\proto({\List},\E{St}, \E{Var}, \V{L}) \sep \V{L}\not\doteq\nil \\
          \scope(({\Lista}:{\Listb}),\E{St}:\E{Sc},\E{Var},\E{L}) ~~\triangleq~~ \\
  \qquad\qquad\proto({\Lista},\E{St},\E{Var},\nil) \sepish {}
 \scope({\Listb},\E{Sc},\E{Var},\E{L})
\end{array}$\Gap\\[\gap]
%
$\begin{array}{l}
  \proto({\emptylist},\nil,\_,\nil) ~~\triangleq~~ \lemp\\
  \proto([\E{St}],\E{St},\E{Var},\E{St}) ~~\triangleq~~ 
 \exists\LVAL\st(\E{St},\E{Var})\pointsto \LVAL \sep \LVAL\not\doteq\none\\
  \proto((\E{St}:{\List}),\E{St},\E{Var},\E{L}) ~~\triangleq~~\\
 % \qquad \begin{array}[t]{l}
\qquad          \exists\V{N}\st
    (\E{St},\E{Var})\pointsto\none \sep {}
    (\E{St},\protop)\pointsto \V{N} \sep {}
    \proto({\List},\V{N},\E{Var},\E{L})
%  \end{array}\\
\end{array}$\Gap\\[\gap]
%
$\begin{array}{l}
  \getValue({\emptylist}, \E{Val},\E{Val}) ~~\triangleq~~ \E{Val} \notdotin\refs \\
  \getValue({\List}, \E{L}\sv\E{X}, \und) ~~\triangleq~~ \proto({\List},\E{L},\E{X}, \nil) \sep \E{L}\not\doteq\nil \\
  \getValue({\List}, \E{L_1}\sv\E{X}, \E{Val})~~\triangleq~~\\
\qquad\exists\V{L_2}\st \proto({\List},\E{L_1},\E{X}, \V{L_2}) \sepish {}         (\V{L_2},\E{X})\pointsto\E{Val} \sep \E{Val}\not\doteq\none\\
\end{array}$
\end{display}
%
\begin{display}{Auxiliary Predicates}
$\pickThis(\E{L}\sv\_,\E{L}) ~~~\triangleq~~~ (\E{L},\thisp)\pointsto\none\qquad\text{where }\E{L}\neq\lgo$\\
$\pickThis(\E{L}\sv\_,\lgo) ~~~\triangleq~~~ \exists\V{V}\st(\E{L},\thisp)\pointsto\V{V}\sep\V{V}\not\doteq\none$\\[\gap]
%
$\istrue(\E{E}) ~~~\triangleq~~~ \E{E}\notdotin \falsity$\\
$\isfalse(\E{E}) ~~~\triangleq~~~ \E{E}\dotin\falsity$\\[\gap]
%
$\objOrGlob(\E{L},\E{L}) ~~\triangleq~~ \E{L}\dotin\loc $\qquad\quad
$\objOrGlob(\E{V},\lop) ~~\triangleq~~ \E{V}\notdotin\loc $\\[\gap]
%
$\getBase(\_,\E{L},\E{L})  ~~\triangleq~~  \E{L}\dotin\loc $\qquad\qquad
$\getBase(\E{L},\E{V},\E{L})  ~~\triangleq~~  \E{V}\notdotin\loc$\\[\gap]
%
$\newobj(\E{L},\E{V}_1,\dots,\E{V}_n) ~~~\triangleq~~~ \bigsep_{\E{V} \in \vars\setminus\{\E{V}_1\dots\E{V}_n\}} (\E{L},\E{V}) \pointsto\none$\\[\gap]
%
$\begin{array}{l}
        \hspace{-5pt}\func(\E{F},\E{Closure},\E{Var},\E{Body},\E{Proto}) ~~~\triangleq
        \\ \qquad 
                (\E{F},\fscopep)\pointsto \E{Closure} \sep
                (\E{F},\bodyp )\pointsto \lambda\E{Var}.\E{Body} \sep{}\\
        \qquad  (\E{F},\js{prototype} )\pointsto \E{Proto} \sep
                (\E{F},\protop )\pointsto \lfp
\end{array}$\\[\gap]
%
$\vardecls(\E{X},\E{L},\js e) ~\triangleq~ \js{x1},\ldots,\js{xn}\quad\text{ where }(\E{L},\js xi)\in\domain(\defs(\E{X},\E{L},\js e)$
%
\end{display}
%
%
% Defined variables of JLB
%
\begin{display}{Local Storage Definition.}
%
\qrule{\defs(\E{X},\E{L},\js{var}\ \js{y}) 		}{(\E{L},\js y) \pointsto \und \sep X \not\doteq \js{y}}{}\\
\qrule{\defs(\E{X},\E{L},\js{e1 = e2}) 			}{ \defs(\E{X},\E{L},\js{e1})}{} \\
\qrule{\defs(\E{X},\E{L},\js{e1;e2}) 				}{ \defs(\E{X},\E{L},\js{e1})\sepish \defs(\E{X},\E{L},\js{e2})}{}\\
\qrule{\defs(\E{X},\E{L},\js{if(e1)\{e2\}\{e3\}}) 	}{ \sepish_{i\in 2..3}\defs(\E{X},\E{L},\js{ei})}{}\\
\qrule{\defs(\E{X},\E{L},\js{while(e1)\{e2\}}) 		}{  \defs(\E{X},\E{L},\js{e2})}{} \\
\qrule{\defs(\E{X},\E{L},\js{with(e1)\{e2\}}) 		}{ \defs(\E{X},\E{L},\js{e2})}{} \\[\gap]
%
\qrule{\defs(\E{X},\E{L},\js e) 					}{\lemp\quad (otherwise)}{}
%
\end{display}
%
%\begin{display}{Local Storage Definition.}
%%
%\qrule{\defs(\E{X},\E{L},\js{var}\ \js{y}) 		}{(\E{L},\js y) \pointsto \und \sep X \not\doteq \js{y}}{}\\
%\qrule{\defs(\E{X},\E{L},\js{var}\ \js{x}) 		}{ X \doteq \js{x}}{}\\
%\qrule{\defs(\E{X},\E{L},\js{e1}\oplus \js{e2}) 	}{ \defs(\E{X},\E{L},\js{e1}) \sepish \defs(\E{X},\E{L},\js{e2})}{} \\
%\qrule{\defs(\E{X},\E{L},\js{e.x}) 				}{ \defs(\E{X},\E{L},\js e)}{} \\
%\qrule{\defs(\E{X},\E{L},\js{e1(e2)}) 				}{ \defs(\E{X},\E{L},\js{e1}) \sepish \defs(\E{X},\E{L},\js{e2})}{} \\
%\qrule{\defs(\E{X},\E{L},\js{e1 = e2}) 			}{ \defs(\E{X},\E{L},\js{e1}) \sepish \defs(\E{X},\E{L},\js{e2})}{} \\
%\qrule{\defs(\E{X},\E{L},\js{\{x1:e1 \dots xn:en\}}) }{ \sepish_{i\in 1..n}\defs(\E{X},\E{L},\js{ei})}{}\\[\gap]
%%
%\qrule{\defs(\E{X},\E{L},\js{e1;e2}) 				}{ \defs(\E{X},\E{L},\js{e1})\sepish \defs(\E{X},\E{L},\js{e2})}{}\\
%\qrule{\defs(\E{X},\E{L},\js{if(e1)\{e2\}\{e3\}}) 	}{ \sepish_{i\in 1..3}\defs(\E{X},\E{L},\js{ei})}{}\\
%\qrule{\defs(\E{X},\E{L},\js{while(e1)\{e2\}}) 		}{ \defs(\E{X},\E{L},\js{e1}) \sepish \defs(\E{X},\E{L},\js{e2})}{} \\
%\qrule{\defs(\E{X},\E{L},\js{with(e1)\{e2\}}) 		}{ \defs(\E{X},\E{L},\js{e1}) \sepish \defs(\E{X},\E{L},\js{e2})}{} \\[\gap]
%%
%\qrule{\defs(\E{X},\E{L},\js e) 					}{E\dotin \{\js{x},\js{v},\this,\js{function}(\js{x})\{\js{e}\},\js{function y}(\js{x})\{\js{e}\}\}}{}
%%
%\end{display}
%%
%
\begin{display}{Inference Rules: $\tr P {\js{e}} Q$.}
%
%% \stateaxiom{(Definition)}
%% {\tr \emp {\js{var x}} {\rv\doteq\und}}
\staterule{(Definition)}
{\tr P {\js{e}} Q \qquad \rv\not\in\fv(Q)}
{\tr P {\js{var e}} {Q\sep\rv\doteq\und}}
\rsep
%
\stateaxiom{(Value)}
{\tr \lemp {\js{v}} {\rv\doteq\js{v}}}
\\[\gap]



\staterule{(Variable)}
{P = \scope({\Lista},\ls,\js{x},\E{L})\sepish\getValue({\Listb},\E{L}\sv\js{x},\E{V})}
{\tr P {\js{x}} {P \sep \rv\doteq\E{L}\sv\js{x}}}
~%\rsep
%
\staterule{(Variable Null)}
{P = \scope({\List},\ls,\js{x},\nil)}
{\tr P {\js{x}}{P\sep \rv\doteq\nil\sv\js{x}}}
\\[\gap]


\staterule{(Member Access)}
{\tr P {\js e} {Q\sep\rv\doteq\E{V}}\qquad
Q = R\sep\getValue({\List},\E{V},\E{L})\sep\E{L}\not\doteq\nil}
{\tr P {\js{e.x}} {Q\sep\rv\doteq\E{L}\sv\js{x}}}
\\[\gap]


\staterule{(Computed Access)}
{\tr P {\js e1} {R\sep\rv\doteq\E{V_1}}\qquad
R = S_1\sep\getValue({\Lista},\E{V}_1,\E{L})\sep\E{L}\not\doteq\nil\\
\tr {R} {\js e2} {Q\sep X \dotin \uvars \sep\rv\doteq\E{V}_2}\qquad
Q = S_2\sep\getValue({\Listb},\E{V}_2,\E{X})}
{\tr P {\js{e1[e2]}} {Q\sep\rv\doteq\E{L}\sv\E{X}}}
\\[\gap]




%\staterule{(Object)}
%{\forall i\in 1..n\quad\left(\begin{array}{l}
%						 	P_i = R_i\sep\getValue(\List_i,\E{Y_i},\E{X_i})\\
%                             \tr  {P_{i-1}} {\js{ei}} {P_i\sep\rv\doteq\E{Y_i}}
%                             \end{array}\right)\\
% \js{x1} \neq \dots \neq \js{xn}\\ 
% Q = \left( P_n \sep \exists \V{L} \st \left(
% 	\begin{array}{l}
%        \newobj(\V{L},\protop,\js{x1},\dots,\js{xn}) \sep {}\\
%        (\V{L},\js{x1})\pointsto\E{X_1} \sep \dots \sep (\V{L},\js{xn})\pointsto\E{X_n} \sep{}\\
%        (\V{L},\protop)\pointsto \lop \sep \rv\doteq \V{L}
%		\end{array}\right)\right)\\
% \rv\not\in \fv(P_n)}
%{\tr {P_0} {\js{\{x1}\js{:e1},\dots,\js{xn}\js{:en}\js{\}}} Q}
%  \\[\gap]

\staterule{(Object)}
{\forall i\in 1..n.~ \big(
						 	P_i = R_i\sep\getValue(\List_i,\E{Y_i},\E{X_i})\quad
                             \tr  {P_{i-1}} {\js{ei}} {P_i\sep\rv\doteq\E{Y_i}}\big)\\[\gap]
 Q = \left( P_n \sep \exists \V{L} \st \left(
 	\begin{array}{l}
        \newobj(\V{L},\protop,\js{x1},\dots,\js{xn}) \sep {}\\
        (\V{L},\js{x1})\pointsto\E{X_1} \sep \dots \sep (\V{L},\js{xn})\pointsto\E{X_n} \sep{}\\
        (\V{L},\protop)\pointsto \lop \sep \rv\doteq \V{L}
		\end{array}\right)\right)\Gap\\
\js{x1} \neq \dots \neq \js{xn}\qquad \rv\not\in \fv(P_n)}
{\tr {P_0} {\js{\{x1}\js{:e1},\dots,\js{xn}\js{:en}\js{\}}} Q}
  \\[\gap]

\staterule{(Binary Operators)}
{\tr P {\js{e1}} {R\sep\rv\doteq\E{V_1}}  \qquad
    R = S_1 \sep\getValue({\Lista},\E{V_1},\E{V_3})\\
 \tr R {\js{e2}} {Q\sep\rv\doteq\E{V_2}} \qquad
    Q = S_2\sep\getValue({\Listb},\E{V_2},\E{V_4})\\
    \E{V} = \E{V_3}\primop\E{V_4}}
{\tr   P {\js{e1}\oplus\js{e2}} { Q\sep\rv\doteq \E{V} }}
  \\[\gap]


\staterule{(Assign Global)}
{\tr P {\js{e1}} {R \sep\rv\doteq \nil\sv\E{X}}\\
\tr R {\js{e2}} {Q \sep (\lgo,\E{X}) \pointsto\none \sep\rv\doteq \E{V_1}}\qquad
Q = S\sep\getValue(\List,\E{V_1},\E{V_2})}
{ \tr P {\js{e1 = e2}} {Q\sep {} (\lgo,\E{X})\pointsto\E{V_2} \sep\rv\doteq \E{V_2}}}
  \\[\gap]


\staterule{(Assign Local)}
{\tr P {\js{e1}} {R \sep\rv\doteq \E{L}\sv\E{X}}\\
\tr R {\js{e2}} {Q \sep (\E{L},\E{X}) \pointsto \E{V_3} \sep\rv\doteq \E{V_1}}\qquad
Q = S\sep\getValue(\List,\E{V_1},\E{V_2})}
{\tr P {\js{e1 = e2}} {Q\sep (\E{L},\E{X})\pointsto\E{V_2} \sep\rv\doteq \E{V_2}}}
\\[\gap]


\staterule{(Delete True)}
{\tr P  {\js e} R\\
R =         \left(\begin{array}{l}
                Q \sep (\E{L},\E{X})\pointsto\_ \sep \rv\doteq\E{L}\sv\E{X}\sep {}\\
                \E{X}\doteq\js{prototype}\Rightarrow (\E{L},\bodyp)\pointsto\none)
        \end{array}\right)}
{\tr  P {\js{delete e}} {Q \sep\rv\doteq 1}}
\\[\gap]


\staterule{(Delete False)}
{\tr P  {\js e} R\\
R =         \left(\begin{array}{l}
                Q \sep \rv\doteq\E{L}\sv\E{X}\sep {}\\
                \E{X}\doteq\js{prototype} \sep (\E{L},\bodyp)\pointsto\E{V} \sep \E{V}\not\doteq \none)
        \end{array}\right)}
{\tr  P {\js{delete e}} {Q \sep (\E{L},\bodyp)\pointsto\E{V} \sep\rv\doteq 0}}
\\[\gap]


\staterule{(Delete Nothing)}
{\tr P {\js e} { Q \sep \rv\doteq\E{V} \sep \E{V}\notdotin\refs}}
{\tr P {\js{delete e}} { Q \sep\rv\doteq 1 }}
\\[\gap]




%\staterule{(This)}
%{P = \left(\begin{array}{cc}
%\scope({\Lista},\ls,\js{\thisp},\E{L_1})\sepish\\
%\proto({\Listb},\E{L_1},\js{\thisp},\E{L_2})\sepish\\
%(\E{L_2},\js{\thisp})\mapsto \E{V}
%\end{array}\right)}
%{\tr P {\this} {P\sep\rv\doteq\E{V}}}
%\\[\gap]

\staterule{(This)}
{P = \left(\begin{array}{cc}
\scope({\Lista},\ls,\js{\thisp},\E{L_1})\sepish~
\proto({\Listb},\E{L_1},\js{\thisp},\E{L_2})\sepish\\
(\E{L_2},\js{\thisp})\mapsto \E{V}
\end{array}\right)}
{\tr P {\this} {P\sep\rv\doteq\E{V}}}
\\[\gap]


\staterule{(Function)}
{Q = \left(\begin{array}{l}
        \exists \V{L_1},\V{L_2}\st
        \newobj(\V{L_1},\protop) \sep (\V{L_1},\protop)\pointsto\lop \sep {}\\
        \newobj(\V{L_2},\protop,\js{prototype},\scopep, \bodyp) \sep {}\\
        \func(\V{L_2},\ls,\js{x},\js{e},\V{L_1}) \sep \rv \doteq \V{L_2}
 \end{array}\right)}
{\tr {\lemp}{\jsfun{x}{e}}{Q}}
\\[\gap]


\staterule{(Named Function)}
{Q = \left(\begin{array}{l}
        \exists \V{L_1},\V{L_2},\V{L_3} \st
        \newobj(\V{L_1},\protop) \sep {}\\
        (\V{L_1},\protop)\pointsto\lop \sep  \newobj(\V{L_3},\protop,\js{y}) \sep {}\\
        (\V{L_3},\protop)\pointsto\lop \sep (\V{L_3},\js{y})\pointsto \V{L_2} \sep \\ 
        \newobj(\V{L_2},\protop,\js{prototype},\scopep, \bodyp) \sep {}\\
        \func(\V{L_2},(\V{L_3}:\ls),\js{x},\js{e},\V{L_1}) \sep \rv \doteq \V{L_2}
\end{array}\right)}
{\tr {\lemp}{\jsfun[y]{x}{e}}{Q}}
\\[\gap]


\staterule{(Function Call)}
{\tr P {\js{e1}} {R_1 \sep\rv\doteq \E{F_1}}\\
 R_1 = \left(\begin{array}{l}
          S_1 \sepish \pickThis(\E{F_1},\E{T})\sepish \getValue(\Lista,\E{F_1},\E{F_2}) \sep\E{F_2}\not\doteq\lge\sep\\
          (\E{F_2},\bodyp)\pointsto \lambda\E{X}.\js{e3} \sep {}
          (\E{F_2},\fscopep)\pointsto\Listb
     \end{array}\right)\Gap\\
 \tr {R_1} {\js{e2}} {R_2 \sep \ls\doteq\List_3\sep\rv\doteq \E{V_1}}\quad
 R_2 = S_2\sep \getValue(\List_4,\E{V_1},\E{V_2})\\[\gap]
 R_3 = \left(\begin{array}{l} 
            R_2 \sep \exists\V{L}\st \ls\doteq\V{L}\cons\Listb \sep (\V{L},\E{X})\pointsto \E{V_2} \sep\\
            (\V{L},\thisp)\pointsto\E{T} \sep {} \\
            (\V{L},\protop)\pointsto \nil  \sep \defs(\E{X},\V{L},\js{e3})  \sep \\
            \newobj(\V{L}, \protop,\thisp, \E{X}, \vardecls(\E{X},\V{L},\js{e3}))
      \end{array}\right)\\[\gap]
 \tr {R_3} {\js{e3}} {\exists \V{L}\st Q \sep \ls\doteq\V{L}\cons\Listb}\qquad
 \ls\not\in \fv(Q)\cup \fv(R_2)}
{\tr P {\js{e1(e2)}} {\exists \V{L}\st Q \sep\ls\doteq\List_3}}
\\[\gap]


\staterule{(Eval)}
{\tr P {\js{e1}} {R_1} \qquad
R_1 = S_1 \sepish \getValue(\Lista,\E{V_1},\lge)\sep \rv\doteq\E{V_1}\\
 \tr {R_1} {\js{e2}} {R_2}\qquad
 R_2 = S_2 \sepish \getValue(\Listb,\E{V_2},\E{Str}) \sep \rv\doteq\E{V_2}\\
 \tr{R_2}{\js{e}} Q \qquad \parse(\E{Str}) = \js{e}}
{\tr P {\js{e1(e2)}} Q }
\\[\gap]


\staterule{(New)}
{\tr P {\js{e1}} {R_1 \sep\rv\doteq \E{F_1}}\\
 R_1 = \left(\begin{array}{l}
          S_1 \sepish \getValue(\Lista,\E{F_1},\E{F_2}) \sep{}
          (\E{F_2},\bodyp)\pointsto \lambda\E{X}.\js{e3} \sep {}\\
          (\E{F_2},\fscopep)\pointsto\Listb\sep{}
          (\E{F_2},\js{prototype})\pointsto \E{Pr_1} \sep{}\\
          \objOrGlob(\E{Pr_1},\E{Pr_2})
      \end{array}\right)\Gap\\
 \tr {R_1} {\js{e2}} {R_2 \sep \ls\doteq\List_3\sep\rv\doteq \E{V_1}}\quad
 R_2 = S_2\sep \getValue(\List_4,\E{V_1},\E{V_2})\\[\gap]
 R_3 = \left(\begin{array}{l} 
            R_2 \sep \exists\V{L_1},\V{L_2}\st \ls\doteq\V{L_1}\cons\Listb \sep (\V{L_1},\E{X})\pointsto \E{V_2} \sep\\
            (\V{L_1},\thisp)\pointsto\V{L_2} \sep {} \\
            (\V{L_1},\protop)\pointsto \nil  \sep \defs(\E{X},\V{L_1},\js{e3})  \sep \\
            \newobj(\V{L_1}, \protop,\thisp, \E{X}, \vardecls(\E{X},\V{L_1},\js{e3}))\sep{}\\
            (\V{L_2},\protop)\pointsto\E{Pr_2} \sep \newobj(\V{L_2},\protop) 
      \end{array}\right)\\[\gap] 
 \tr {R_3} {\js{e3}} {\exists \V{L_1},\V{L_2}\st Q \sep \ls\doteq\V{L_1}\cons\Listb \sep \rv\doteq\E{V_3} \sep \getBase(\V{L_2},\E{V_3},\E{V_4})}\\
 \rv \not\in \fv(Q)\qquad
 \ls\not\in \fv(Q)\cup \fv(R_2)}
{\tr P {\js{new e1(e2)}} {\exists \V{L_1},\V{L_2}\st Q \sep\ls\doteq\List_3 \sep \rv\doteq\E{V_4}}}
\\[\gap]


%
% Statements
%

\staterule{(Sequence)}
{\tr P {\js{e1}} R\qquad
 \tr R {\js{e2}} Q}
{\tr P {\js{e1;e2}} Q}
\\[\gap]


\staterule{(With)}
{\tr {P \sep \ls\doteq\E{L}} {\js{e1}} {S\sep \ls\doteq\E{L}\sep \rv\doteq\E{V_1}} \qquad
S =  R \sep \getValue(\List,\E{V_1},\E{L_1}) \sep \E{L_1}\not\doteq\nil\\
 \tr {S\sep \ls\doteq\E{L_1}:\E{L}}{ \js{e2} }{ Q\sep \ls\doteq\E{L_1}:\E{L} }\qquad
 \ls \not\in P, Q, R}
{\tr { P \sep \ls\doteq\E{L}}{ \js{with(e1)\{e2\}}} { Q \sep \ls\doteq\E{L}}}
\\[\gap]


\staterule{(If True)}
{\tr P {\js{e1}}{S\sep \istrue(\E{V_2})\sep\rv\doteq\E{V_1}} \qquad
 S = R \sep \getValue({\List},\E{V_1},\E{V_2})\\
 \tr {S}{\js{e2}} Q}
{\tr P {\js{if(e1)\{e2\}\{e3\}}} Q}
\\[\gap]


\staterule{(If False)}
{\tr P {\js{e1}}{S\sep \isfalse(\E{V_2})\sep\rv\doteq\E{V_1}} \qquad
 S = R \sep \getValue({\List},\E{V_1},\E{V_2})\\
  \tr {S}{\js{e3}} Q}
{\tr P {\js{if(e1)\{e2\}\{e3\}}} Q}
\\[\gap]


\staterule{(While)}
{\tr P {\js{e1}} {S\sep\rv\doteq\E{V_1}} \qquad
S = R \sep \getValue({\List},\E{V_1},\E{V_2})\\
 \tr {S \sep \istrue(\E{V_2})} {\js{e2}} P\\
 Q = S \sep \isfalse(\E{V_2})\sep\rv\doteq\und\qquad
 \rv\not\in \fv(R)}
{\tr P {\js{while(e1)\{e2\}}} Q}
\\[\gap]



%
% Logics
%

\staterule{(Frame)}
{\tr P {\js{e}} Q}
{\tr {P\sep R} {\js{e}} {Q\sep R}}
\rsep
%
\staterule{(Consequence)}
{\tr {P_1} {\js{e}} {Q_1}\\
 P\implies P_1\qquad Q_1 \implies Q}
{\tr P {\js{e}} Q}
\\[\gap]


\staterule{(Elimination)}
{\tr P {\js{e}} Q}
{\tr {\exists\V X\st P}{\js{e}}{\exists\V X\st Q}}
\rsep
%
\staterule{(Disjunction)}
{ \tr {P_1} {\js{e}} {Q_1} \qquad
 \tr {P_2} {\js{e}} {Q_2}}
{\tr {P_1\lor P_2} {\js{e}} {Q_1\lor Q_2}}
%
\end{display}


































\section{Proofs for Section~\ref{sec:JLB}}
\label{sec:proofs:JLB}

% Delete lemma
%
\begin{lemma}[Delete]\label{lemma:delete}
If $H\sep(l,\js{x})\pointsto v\isok$ and $\js x\neq\js{prototype}$ then $H\isok$.
\end{lemma}
%
\begin{proof}
By definition of $\isok$ and then by a simple induction on the derivation of $\iswf$, noting that $\js x\in\uvars$ and $\uvars\cap\ivars=\emptyset$.
\end{proof}


% Proto-chain lemma
%
\begin{lemma}[Prototypes]\label{lemma:protochain}
If $H\isok$ then $\forall l,x\st (l,x)\in\domain(H) \Rightarrow (l,\protop)\in\domain(H)$.
\end{lemma}
%
\begin{proof}
By definition of $H\isok$, $(\lgo,\protop)\in\domain(H)$ and $H\iswf$.
%
The results follow by a simple induction on the derivation of $H\iswf$.
\end{proof}




% Allocation lemma
%
\begin{lemma}[Allocation]\label{lemma:allocation}
If $H\isok$ and $\schain(H,L)$ 
\[\scope(H,L,x)=l'\vee
\getValue(H,r)=l'\vee
H(l,\thisp)=l'\]
then $(l',\protop)\in\domain(H)$.
\end{lemma}
%
\begin{proof}
%
The proof for \scope\ is by induction on the derivation, using the hypotheses $H\isok$ and $\schain(H,L)$.
%
The proof for \getValue\ is by induction on the derivation, using the hypothesis $H\isok$.
%
If $H(l,\thisp)=l'$, by $H\isok$ it must be the case that $H=H'\sep(\lgo,\thisp)\pointsto \lgo\isok$ and $H'\iswf$.
%
If $l\neq \lgo$, then by definition of $H(l,\thisp)$, it must be the case that $H'=H''\sep(l,\thisp)\pointsto l'\isok$, so $(l',\protop)\in\domain(H'')$ and therefore $(l',\protop)\in\domain(H)$.
%
If $l=\lgo$, then $l'=\lgo$ and $(\lgo,\scopep)\in \domain(H')$.
%
Since $H'\iswf$, it must be the case that $H'=H''\sep(\lgo,\scopep)\pointsto l''\isok$ and therefore $(\lgo,\protop)\in\domain(H'')$, hence $(\lgo,\protop)\in\domain(H)$.
%
\end{proof}


%
%% Scope constant lemma
%%
%\begin{lemma}[Scope Invariance]\label{lemma:scopeconst}
%If $H,L,\js{e}\levalsto H',\njs{r}$ then
%\[\forall l_s.H(l_s,\scopep)=l_s'\Rightarrow H'(l_s,\scopep)=l_s'.\]
%\end{lemma}
%%
%\begin{proof}
%%
%By induction the derivation of $H,L,\js{e}\levalsto H',\njs{r}$, noting that the only operations overwriting or deallocating heap cells operate on user variables, and therefore cannot modify \scopep.
%%
%\end{proof}




% Heap-chains-lemma
%
\begin{lemma}[Semantics Invariants]
        \label{lemma:heapchains}
%
Let $H,L$ be such that $H\isok$ and $\schain(H,L)$. 
%
Given a valid derivation tree $\D(H,L,\js{e})$ for $H,L,\js{e}\levalsto H',\njs{r}$, 
%
\[(H_n,L_n,\js{en}\levalsto H_n',\njs{r_n})\in\D(H,L,\js{e})\quad\Rightarrow\]
%
\begin{enumerate}
\item $H_n'\isok\wedge \schain(H_n',L_n)$
\item $(\njs{r_n}=l_n\wedge H_n'(l_n,\fscopep)=L_n') \Rightarrow \schain(H_n',L_n')$
\item $\njs{r_n}\in\{l_n,l_n\sv\js{x}|l_n\neq\nil\} \Rightarrow (l_n,\protop)\in\domain(H_n')$
\item $(l_n,\protop)\in\domain(H_n)\Rightarrow (l_n,\protop)\in\domain(H_n')$
\end{enumerate}
%
\end{lemma}
%
\begin{proof} (Sketch.)
By complete induction on the depth $d$ of $\D(H,L,\js{e})$. 
%
\begin{description}
%
\item[($d=1$)] 
%
(Definition) and (Value) are easy. 
%
(This) and (Variable) follow by Lemma~\ref{lemma:allocation}. 
%
(Function) and (Named Function) follow by Lemma~\ref{lemma:protochain}, and then adding the new object properties one at a time, while appealing to the corresponding well-formedness rules.
%
\item[($d=n+1$)]  
%
All inductive cases use the hypothesis, and  Lemma~\ref{lemma:allocation} for $\getValue$.
%
Cases (Member Access), (Computed Access), (Binary Operators), (Eval), (Sequence), (If -) and (While -) follow easily.
%
Cases (Delete -) follow by Lemma~\ref{lemma:delete} and definition of $\ReadWrite$ and $\ReadOnly$.
%
(Assignment) follows by a case analysis on $\semup{}$ and, in the case of $\lgo$, an argument that $(\lgo,\protop)$ is in the heap by well-formedness.
%
(Object) is similar to (Assignment).
%
(Function Call) and (New) combine the reasoning used in the points above, and use the assumption of well-formedness of stored $\fscopep$ pointers to derive $\schain(H_n',L_n)$. 
%
(This) uses the fact that, by well-formedness hypothesis, each scope chains contains at least the global object $\lgo$.
%
\end{description}
%
\end{proof}



  \begin{thm}[Well-Formedness]\label{thoerem:wfheap}
  %
  Let $H,L$ be such that $H\isok$ and $\schain(H,L)$. 
  %
  If $H,L,\js{e}\levalsto H',\njs r$ then $H'\isok$. 
  %
  \end{thm}
  %
  \begin{proof}
  By Lemma~\ref{lemma:heapchains}.
  \end{proof}






%\renewcommand{\und}{\unds}








\section{Soundness}
\label{sec:soundness}

\begin{defn}[Soundness of a Hoare triple]
        \label{defn:soundness}
A Hoare triple $\{P\}\js{e}\{Q\}$ is sound if it satisfies the following two properties:

\begin{itemize}
                \item \emph{Fault Avoidance}:
                        \[
                        \forall h,l,\env\st
                        h,l,(\env\setminus\rv) \satisfies P \implies \heval{h},l,\js e \not\!\!\!\levalsto \fault
                        \]
                \item \emph{Safety}: 
                        \[
                        \begin{array}{l}
                                \forall h,l,\env,H,v\st\\
                                h,l,(\env\setminus\rv) \satisfies P \land \heval{h},l,\js e \levalsto H,r \implies \\
                                \qquad\exists h' \st H=\heval{h'} \land h',l,[\env|\rv\takes r] \satisfies Q
                        \end{array}
                        \]
\end{itemize}
\end{defn}
Notice that we are not limited to reasoning about only well-formed heaps. While
it is the case that all JavaScript programs maintain the well-formedness of the
heap, we are also able to reason about programs that run on partial-heaps,
which may not be well formed. For example, the JavaScript expression \js{4} can be
considered as a program in its own right, which returns the integer ``4''. This
program can run on any heap, well formed or not, and we are able to reason
about it.

In order to show soundness for all Hoare triples, we will also need to show weak locality of all commands.


\begin{defn}[Weak Locality]
        \label{defn:locality}
A JavaScript expression $\js{e}$ is local with respect to a formula $P$ if it satisfies the following two properties:
\begin{itemize}
        \item \emph{Safety Monotonicity}
                \[ \begin{array}{l}
                        \forall h,L,\env,h'\st\\
                        h,L,(\env\setminus \rv) \satisfies P \land \heval{h},L,\js{e}\not\!\!\!\!\levalsto\fault \land h\disj h' \\
                        \implies\\
                        \heval{h\sep h'},L,\js{e}\not\!\!\!\!\levalsto\fault
                \end{array}
                \]
        \item \emph{Frame Property}
                \[ \begin{array}{l}
                        \forall h,L,\env,h',H\st\\
                        h,L,(\env\setminus \rv) \satisfies P \land \heval{h},L,\js{e}\not\!\!\!\!\levalsto\fault \land \heval{h\sep h'},L,\js{e}\levalsto H \\
                        \implies \\
                        \exists h'' \st \heval{h},L,\js{e}\levalsto \heval{h''} \land H\equiv \heval{h''\sep h'}
                \end{array}
                \]
\end{itemize}
\end{defn}

Notice that weak locality is a weakening of the locality described in~\cite{Yang02asemantic}. This means that any command which is ``local'' in the sense of~\cite{Yang02asemantic} is also Weakly Local with respect to all formulae.

In this section we prove soundness of every derivable triple by induction on the derivation tree. At each step, we show fault avoidance, safety and weak locality. In order to do this, we will require some lemmas about the soundness of particular predicates:

\subsection{Predicate Soundness}

Proving soundness of rules which use predicates like $\scope$ and $\proto$ will require some lemmas relating their semantic and logic versions.

\begin{lemma}[Proto Soundness]
        \label{lemma:protosoundness}
        \[ \begin{array}{l}
                \forall h,L,\env \st h,L,\env\satisfies \proto(\E{List},\E{Start},\E{Var},\E{Loc}) \implies \\
                \qquad\qquad\qquad\qquad \eval{\E{Loc}}_{\env}^L = \proto(\heval{h},\eval{\E{Start}}_{\env}^L,\eval{\E{Var}}_{\env}^L)
        \end{array}\]
        \begin{proof}
                By induction on the definition of the logical predicate $\proto$. There are three cases.

                \textbf{Case 1}\\
                $\proto([],\nil,\_,\nil) \triangleq \lemp$\\
                Follows from the definition of the proto function:\\
                $\proto(H,\nil,x)\triangleq\nil$

                \textbf{Case 2}\\
                $\proto([\E{Start}],\E{Start},\E{Var},\E{Start}) \triangleq \exists \LVAL\st (\E{Start},\E{Var})\pointsto\LVAL \sep \LVAL\not\doteq\none $
                Follows from the definition of the proto function:\\
                $\proto(H,l,x) \triangleq l   \iff (l,x)\in\domain(H)$

                \textbf{Case 3}\\
                \[\proto((\E{Start}:\E{List}),\E{Start},\E{Var},\E{Loc}) \triangleq \begin{array}[t]{l}
                        \exists \V{NEXT}\st (\E{Start},\E{Var}) \pointsto\none \sep{}\\
                        (\E{Start},\protop)\pointsto\V{NEXT} \sep{}\\
                        \proto(\E{List},\V{NEXT},\E{Var},\E{Loc})
                \end{array}\]
                Follows from the inductive hypothesis and the definition of the proto function:\\
                $\proto(H,l,x)\triangleq\proto(H,l',x) \iff (l,x)\not\in\domain(H) \land H(l,\protop) = l'$
        \end{proof}
\end{lemma}



\begin{lemma}[Scope Soundness]
        \label{lemma:scopesoundness}
\[
\begin{array}{l}
\forall h,L,\env \st h,L,\env\satisfies \scope(\E{List},\E{Start},\E{Var},\E{Loc}) \implies \\
\qquad\qquad\qquad\qquad\eval{Loc}^L_{\env} = \scope(\heval{h},\eval{\E{Start}}^L_{\env},\eval{\E{Var}}^L_{\env})
\end{array}
\]
\begin{proof}
        The proof is by induction on the definition of the predicate $\scope$, which closely follows the structure of the function $\scope$.
\end{proof}
\end{lemma}



\begin{lemma}[GetValue Soundness]
        \label{lemma:gvsoundness}
        \[\begin{array}{l}
                \forall h,L,\env \st h,L,\env\satisfies \getValue(\E{List},\E{Val1},\E{Val2}) \implies \\
                \qquad\qquad\qquad\qquad \eval{\E{Val2}}^L_\env = \getValue(\heval{h},\eval{\E{Val1}}^L_\env)
        \end{array}
        \]
        \begin{proof}
                The proof follows directly from the definitions, and from Lemma~\ref{lemma:protosoundness}
        \end{proof}
\end{lemma}



% \begin{lemma}[Locality of JLB]
%         For all derivable triples $\{P\}\js{e}\{Q\}$, the expression $\js{e}$ is local to the precondition $P$ according to Definitions~\ref{defn:safetymonotonicity} and~\ref{defn:frameproperty}.
% \end{lemma}
% 
% \begin{lemma}[Soundness of JLB]
%         All derivable triples $\{P\}\js{e}\{Q\}$ are sound according to Definition~\ref{defn:soundness}.
% \end{lemma}
% 
% The proof of these two lemmas requires a simultaneous induction on the derivation of Hoare triples, with axioms as base cases and inference rules as inductive steps.
% 
% 

\subsection{The Induction}

For every axiom $\{P\}\js{e}\{Q\}$ we wish to show soundness of the axiom, and weak locality of the command with respect to the precondition.
For every inference rule we wish to show the same of the conclusion, given the inductive hypothesis of soundness and weak locality of the premises.

\subsubsection{Sequence}
\label{sec:sequence}

The inference rule for sequence is:

\[
\frac{\tr P {\js{e1}} R\qquad
\tr R {\js{e2}} Q}
{\tr P {\js{e1 ; e2}} Q} \]

The operational rule is:
\[
\frac{H,L,\js{e1}\levalsto H'',\njs{r}'\\ H'',L,\js{e2}\levalsto H',\njs{r}}
{H,L, \js{e1 ; e2} \levalsto H',\njs{r}}
\]

The arguments for Fault Avoidance and Safety are standard.

For {\bf safety monotonicity} and the {\bf frame property}.
\begin{enumerate}
\item
Choose $h,L,\env$ such that $h,L,(\env\setminus\rv)\satisfies P$, and choose arbitrary $h2$ such that $h\disj h2$. 
\item
By Safety of the first premise, $\heval{h},L,\js{e1}\levalsto \heval{h''}$ such that $h'',L,\env\satisfies R$. 
\item
By Safety Monotonicity of the first premise, $\heval{h\sep h2},L,\js{e1}\not\!\!\!\levalsto\fault$.
\item
By the frame property of the first premise, $\heval{h\sep h2},L,\js{e1}\levalsto\heval{h''\sep h2}$
\item \label{lst:seq:sm}
By safety and safety monotonicity of the second premise, \\
$\heval{h''\sep h2},L,\js{e2}\not\!\!\!\!\levalsto\fault$.
\item
        By the operational rule for sequence and \ref{lst:seq:sm} we have {\bf safety monotonicity} for the conclusion.
\item \label{lst:seq:fp}
        By the frame property of the second premise, $\heval{h''\sep h2},L,\js{e2}\levalsto\heval{h'\sep h2}$.
\item 
        By the operational rule for sequence and \ref{lst:seq:fp} we have the {\bf frame property} for the conclusion.
\end{enumerate}


\subsubsection{Definition}
The inference rule for Definition is:
%% \staterule{(Definition)}
%% {\tr P {\js{e}} Q \qquad \rv\not\in\fv(Q)}
%% {\tr P {\js{var e}} {Q\sep\rv\doteq\und}}

\[\frac {\tr P {\js{e}} Q \qquad \rv\not\in\fv(Q)}
{\tr P {\js{var e}} Q\sep\rv\doteq\und}
\]

The operational rule is:
\[\frac{H,L,\js{x} \levalsto H,\njs{r}}
{H,L,\js{var x} \levalsto H,\njs{r}}
\]

Safety, Fault Avoidance, Safety Monotonicity and the Frame Property all follow trivially from the premise and the operational definition.

\subsubsection{Value}

The axiom for value is:
\[
\tr \lemp {\js{v}} {\rv\doteq\js{v}}
\]

The operational rule is:
\[\frac
{}
{H,L,\js{v} \levalsto H,\js{v} }
\]

Since this expression does not depend on the heap, Safety Monotonicity and the Frame Property trivially hold. Safety and Fault Avoidance follow directly from the definitions.

\subsubsection{This}

The axiom for This is:

\[
\left\{\begin{array}{cc}
\scope(\E{List1},\ls,\js{\thisp},\V{L1})\sepish\\
\proto(\E{List2},\V{L1},\js{\thisp},\V{L2})\sepish\\
(\V{L2},\js{\thisp})\mapsto \E{V}
\end{array}\right\}\\
\this 
\left\{\begin{array}{cc}
\scope(\E{List1},\ls,\js{\thisp},\V{L1})\sepish\\
\proto(\E{List2},\V{L1},\js{\thisp},\V{L2})\sepish\\
(\V{L2},\js{\thisp})\mapsto \E{V}
\sep\rv\doteq\E{V}
\end{array}\right\}\\
\]

The operational rule is:
\[\frac
{\begin{array}{l} \scope(H,L,\thisp)=l_1 \\ \proto(H,l_1,\thisp)=l_2\\ H(l_2,\thisp)=l' \end{array}}
{H,L,\js{this} \levalsto H,l'}
\]

Safety and Fault Avoidance follow from the definitions, and from Lemmas~\ref{lemma:protosoundness} and~\ref{lemma:scopesoundness}. Safety Monotonicity and the Frame Property hold trivially, since the ``this'' expression does not alter the heap, and only reads from heap locations mentioned in the precondition.

\subsubsection{Variable}

The axiom for Variable is:
\[\begin{array}{c}
\{\scope(\E{List},\ls,\js{x},\V{L})\sepish\getValue(\E{List2},\V{L}\sv\js{x},\LVAL)\}\\
{\js{x}}\\
\{\scope(\E{List},\ls,\js{x},\V{L})\sepish\getValue(\E{List2},\V{L}\sv\js{x},\LVAL)\sep \rv\doteq\V{L}\sv\js{x}\}
\end{array}
\]

The operational rule is:
\[\frac
{\scope(H,L,\js{x})=l' }
{H,L,\js{x} \levalsto H,l'\sv\js{x}}
\]

Safety and Fault avoidance follow trivially from the definitions and from Lemma~\ref{lemma:scopesoundness}. Safety Monotonicity and the Frame Property hold trivially, since the ``this'' expression does not alter the heap, and only reads from heap locations mentioned in the precondition.

\subsubsection{Variable Null}

The axiom for Variable Null is:
\[
\begin{array}{c}
\{\scope(\E{List},\ls,\js{x},\nil)\}\\
{\js{x}}\\
\{\scope(\E{List},\ls,\js{x},\nil) \sep \rv\doteq\nil\sv\js{x}\}
\end{array}
\]

The operational rule is:
\[\frac
{\scope(H,L,\js{x})=l' }
{H,L,\js{x} \levalsto H,l'\sv\js{x}}
\]

Safety and Fault avoidance follow trivially from the definitions and from Lemma~\ref{lemma:scopesoundness}. Safety Monotonicity and the Frame Property hold trivially, since the ``this'' expression does not alter the heap, and only reads from heap locations mentioned in the precondition.

\subsubsection{If True}
\label{sec:iftrue}

The inference rule for If True is:
\[\frac
{\begin{array}{l}
        \tr P {\js{e1}}{R \sep \getValue(\E{List},\LVAL,\E{Val}')\sep \istrue(\E{Val}')\sep\rv\doteq\LVAL} \\
    %\E{Val}'\doteqdot v\wedge  \\
    \tr {R  \sep \getValue(\E{List},\LVAL,\E{Val}')}{\js{e2}} Q
    \end{array}}
{\tr P {\js{if(e1)\{e2\}\{e3\}}} Q}
\]

The operational rule is:
\[\frac
{  \begin{array}{l}
 H,L,\js{e1} \levalsto H'',\njs{r'} \\
 \getValue(H'',\njs{r'})=\njs{v}\\
 \istrue(\njs{v})
  \\ H'',L,\js{e2} \levalsto H',\njs{r}
  \end{array}
}
{H,L,\js{if(e1)\{e2\}\{e3\}} \levalsto H',\njs{r} }
\]

These rules make use of the logical predicate:
\[
\begin{array}{ll}
        \istrue(\E{E}) &\triangleq \E{E}\notdotin\{0,\str,\nil,\und\}\\
\end{array}
\]

And the operational predicate:
\[\begin{array}{rll}
        \istrue(v)&\triangleq& v\not\in\falsity\\
\end{array}\]

The arguments for Fault Avoidance and Safety are standard but for the use of the $\istrue$ predicate and the $\getValue$ predicate. The soundness of the logical predicates with respect to the operational semantics follows directly from the definitions and from Lemma~\ref{lemma:gvsoundness}.

The arguments for Safety Monotonicity and the Frame Property are almost identical to those for Sequence given in Section~\ref{sec:sequence}.

\subsubsection{If False}
\label{sec:iffalse}

The inference rule for If False is:
\[\frac
{\begin{array}{l} \tr P {\js{e1}}{R \sep \getValue(\E{List},\LVAL,\E{Val}')\sep \isfalse(\E{Val}')\sep\rv\doteq\LVAL} \\
    %\E{Val}'\doteqdot v\wedge \isfalse(v) \\
    \tr {R  \sep \getValue(\E{List},\LVAL,\E{Val}')}{\js{e3}} Q\end{array}}
{\tr P {\js{if(e1)\{e2\}\{e3\}}} Q}
\]

The operational rule is:
\[\frac
{
\begin{array}{l}
 H,L,\js{e1} \levalsto H'',\njs{r'} \\
 \getValue(H'',\njs{r'})=\njs{v} \\
 \isfalse(\njs{v}) \\
 H'',L,\js{e3} \levalsto H',\njs{r}
\end{array}}
{H,L,\js{if(e1)\{e2\}\{e3\}} \levalsto H',\njs{r}}
\]

This makes use of the logical predicate:
\[
\begin{array}{ll}
        \isfalse(\E{E}) &\triangleq \E{E}\dotin\{0,\str,\nil,\und\}
\end{array}
\]

And the operational predicate:
\[\begin{array}{rll}
        \isfalse(v)&\triangleq &v\in\falsity
\end{array}\]

The arguments for If False are similar to those for If True given in Section~\ref{sec:iftrue}.

\subsubsection{While}

The inference rule for While is:

\[\frac
{\begin{array}{l}
        \tr P {\js{e1}} {R \sep \getValue(\E{List},\LVAL',\E{Val})\sep\rv\doteq\LVAL'} \\ 
    \tr {(R\sep\getValue(\E{List},\LVAL',\E{Val})) \sep \istrue(\E{Val})} {\js{e2}} P\\
Q = (R\sep\getValue(\E{List},\LVAL',\E{Val})) \sep \isfalse(\E{Val})\sep\rv\doteq\und\\
\rv\not\in \fv(R)\end{array}}
{\tr P {\js{while(e1)\{e2\}}} Q}
\]

The operational rules are:
\[\frac
{  \begin{array}{l}
 H,L,\js{e1} \levalsto H'',\njs{r'} \\ 
 \getValue(H'',\njs{r'})=\njs{v}\\
 \istrue(\njs{v}) \\ 
 H'',L,\js{e2;while(e1)\{e2\}} \levalsto H',\njs{r}
 \end{array}
}
{H,L,\js{while(e1)\{e2\}} \levalsto H',\und }
\]

\[\frac
{\begin{array}{l}
 H,L,\js{e1} \levalsto H'',\njs{r} \\ 
 \getValue(H'',\njs{r})=\njs{v} \\
 \isfalse(\njs{v})
 \end{array}
}
{H,L,\js{while(e1)\{e2\}} \levalsto H'',\und }
\]

As with the rules for If (\ref{sec:iftrue}, \ref{sec:iffalse}), the arguments for While are standard, but for the use of simple logical predicates:

\[
\begin{array}{ll}
        \istrue(\E{E}) &\triangleq \E{E}\notdotin\{0,\str,\nil,\und\}\\
        \isfalse(\E{E}) &\triangleq \E{E}\dotin\{0,\str,\nil,\und\}
\end{array}
\]

which correspond to the operational predicates:
\[\begin{array}{rll}
        \istrue(v)&\triangleq& v\not\in\falsity\\
        \isfalse(v)&\triangleq &v\in\falsity
\end{array}\]


\subsubsection{Binary Operators}

The inference rule for Binary Operators is:
\[\frac
{\begin{array}{l}
        \tr P {\js{e1}} {R\sep\rv\doteq\V{VAL1}}  \\
 \tr R {\js{e2}} {Q\sep\rv\doteq\V{VAL2}} \\
    R = S \sep\getValue(\E{List1},\V{VAL1},\E{Val1}') \\
    Q = S'\sep\getValue(\E{List2},\V{VAL2},\E{Val2}')\\
    \E{Val} = \E{Val1}'\primop\E{Val2}'\end{array}}
{\tr   P {\js{e1}\oplus\js{e2}} { Q\sep\rv\doteq \E{Val} }}
\]

The operational rule is:
\[\frac{\begin{array}{l}
    H,L,\js{e1} \levalsto H'',\njs{r_1}\\
    \getValue(H'',\njs{r_1}) = \js{v1}\\
    H'',L,\js{e2} \levalsto H',\njs{r_2}\\
    \getValue(H',\njs{r_2}) = \js{v2}\\ 
    \js{v1}\primop\js{v2}=\js{v}
    \end{array}
}
{H,L, \js{e1} \oplus \js{e2} \levalsto H',\js{v}}
\]

The argument for Safety and Fault avoidance is standard, and the argument for Safety Monotonicity and the Frame Property is similar to that for Sequence in Section~\ref{sec:sequence}.

\subsubsection{Member Access}

The inference rule for Member Access is:
\[\frac
{\tr P {\js e} {Q\sep\getValue(\E{List},\LVAL,\E{Loc})\sep\V{L}\not\doteq\nil\sep\rv\doteq\LVAL}}
{\tr P {\js{e.x}} {Q\sep\getValue(\E{List},\LVAL,\E{Loc})\sep\V{L}\not\doteq\nil\sep\rv\doteq\E{Loc}\sv\js{x}}}
\]
The operational rule is:
\[\frac
{\begin{array}{l}H,L,\js{e} \levalsto H',\njs{r} \\
\getValue(H',\njs{r}) = l'\\
l'\neq \nil\end{array}}
{H,L,\js{e.x} \levalsto H',l'\sv\js{x}}
\]

The Safety and Fault Avoidance arguments follow directly from the definitions and from Lemma~\ref{lemma:gvsoundness}.

\subsubsection{Function Call}

The inference rule for Function Call is:
\[\frac
{  \begin{array}{l}
        \tr P {\js{e1}} {R \sep\rv\doteq \V{FUNC}}\\
  \\
  R = \begin{array}[t]{l}
          R' \sepish \pickThis(\V{FUNC},\V{THIS})\sepish \getValue(\V{LIST},\V{FUNC},\V{F}) \sep{}\\
          (\V{F},\bodyp)\pointsto \lambda\V{X}.\js{e3} \sep {}\\
          (\V{F},\fscopep)\pointsto\V{LS}'\sep\V{F}\not\doteq\lge
  \end{array}
        \\\\
  \tr R {\js{e2}} {S \sep \ls\doteq\V{LS}\sep\rv\doteq \LVAL'}\\
  %
  S = S'\sep \getValue(\V{LIST}',\LVAL',\LVAL'')\\
  \\
  P' = %\left\{
    \begin{array}[t]{l} 
            S \sep \exists\V{L}\st \ls\doteq\V{L}:\V{LS}' \sep (\V{L},\V{X})\pointsto \LVAL'' \sep\\
            (\V{L},\thisp)\pointsto\V{THIS} \sep {} \\
            (\V{L},\text{@proto})\pointsto \nil  \sep defs(\V{X},\V{L},\js{e3})  \sep \\
            \newobj(\V{L}, \protop,\thisp, \V{X}, \text{vardecls}(\js{e3}))
    \end{array} 
 % \right\}
  \\  \\
  %
  \tr {P'} {\js{e3}} {Q \sep \ls\doteq\V{L}:\V{LS}'}\\
%
\ls\not\in \fv(Q)\cup \fv(S)
\end{array}
}
{\tr P {\js{e1(e2)}} {Q \sep\ls\doteq\V{LS}}}
\]

The operational rule is:
\[\frac
{\begin{array}{l}
        H,L,\js{e1} \levalsto H_1,r_1\\ 
 \pickThis(H_1,\njs{r_1})=l_2\\
 \getValue(H_1,r_1)=l_1\\
 l_1\neq\lge\\
 H_1(l_1,\bodyp)=\lambda \js{x.e3}\\
 H_1(l_1,\fscopep)= L'\\
 H_1,L,\js{e2} \gevalsto H_2,\njs{v}\\
 H_3 = H_2\sep\activ(l,\js x,v,\js{e3},l_2)\\
 H_3,l\cons L',\js{e3} \gevalsto H',\njs{v'}
 \end{array}
}
{H,L,\js{e1(e2)} \levalsto H',\njs{v'}}
\]

The arguments for Safety, Fault Avoidance, Safety Monotonicity and the Frame Property of the conclusion are similar to those for sequential composition.

\subsubsection{Frame}

The inference rule for Frame is:
\[\frac{\tr P {\js{e}} Q}
{\tr{P\sep R}{\js{e}}{Q \sep R}}
\]

The Fault Avoiding and Safety properties of the frame rule follow directly from the Safety Monotonicity and Frame Property of the premise.

The Safety Monotonicity and Frame Property of the conclusion also follows from the Safety Monotonicity and Frame Property of the premise, and the associativity of $\sep$.


\subsubsection{Consequence}

The inference rule for Consequence is:
\[\frac
{\begin{array}{l}P\implies P'\\ 
 Q' \implies Q\\
 \tr {P'} {\js{e}} {Q'}\end{array}}
{\tr P {\js{e}} Q}
\]

Fault Avoidance, Safety, Safety Monotonicity and Frame for the conclusion follow directly from the definition of implication, and the Fault Avoidance, Safety, Safety Monotonicity and Frame of the premise.



\subsubsection{Variable Elimination}

The inference rule for Variable Elimination is:
\[\frac{\tr P {\js{e}} Q}
{\tr {\exists\LVAR\st P}{\js{e}}{\exists\LVAR\st Q}}\]

Fault Avoidance, Safety, Safety Monotonicity and Frame for the conclusion follow directly from the definition of existential variables, and the Fault Avoidance, Safety, Safety Monotonicity and Frame of the premise.

\subsubsection{Disjunction}

The inference rule for Disjunction is:

\[\frac{\tr {P1}{\js{e}}{Q1}\\
\tr {P2}{\js{e}}{Q2}\\}
{ \tr {P1\lor P2}{\js{e}}{Q1\lor Q2}\\}\]

Fault Avoidance, Safety, Safety Monotonicity and Frame for the conclusion follow directly from the definition of disjunction, and the Fault Avoidance, Safety, Safety Monotonicity and Frame of the premise.

\subsubsection{Function}

The axiom for Function is:
\[
\begin{array}{c}
\{ \lemp \}\\
\jsfun{x}{e}\\
\left\{\begin{array}{l}
        \exists \V{L},\V{L}'\st
        \newobj(\V{L},\protop) \sep {}\\
        (\V{L},\protop)\pointsto\lop \sep {}\\
        \newobj(\V{L}',\protop,\js{prototype},\scopep, \bodyp) \sep {}\\
        \func(\V{L}',\ls,\js{x},\js{e},\V{L}) \sep \rv \doteq \V{L}'
\end{array}\right\}
\end{array}
\]

The operational rule is:
\[\frac
{H' = H \sep \obj(l) \sep \func(l',L,\js x,\js e,l)}
{H,L,\jsfun{x}{e} \levalsto H',l'}
\]

The arguments for Safety, Fault Avoidance, Safety Monotonicity and the Frame Property of the conclusion follow directly from their counterparts in the premise.

\subsubsection{Named Function}

The inference rule for Named Function is:
\[
\begin{array}{c}
\{\lemp\}\\
\jsfun[y]{x}{e}\\
\left\{ \begin{array}{l}
        \exists \V{L},\V{L}_1,\V{L}' \st
        \newobj(\V{L},\protop) \sep {}\\
        (\V{L},\protop)\pointsto\lop \sep {}\\
        \newobj(\V{L}_1,\protop,\js{y}) \sep {}\\
        (\V{L}_1,\protop)\pointsto\lop \sep (\V{L}_1,\js{y})\pointsto \V{L}' \sep {}\\
        \newobj(\V{L}',\protop,\js{prototype},\scopep, \bodyp) \sep {}\\
        \func(\V{L}',(\V{L}_1:\ls),\js{x},\js{e},\V{L}) \sep \rv \doteq \V{L}'
\end{array}\right\}
\end{array}
\]

The operational rule is:
\[\frac
{H' = H \sep \obj(l)\sep \func(l',l_1\ty L,\js x,\js e,l) \sep l_1\pointsto\{\protop\ty \lop,\js{y}\ty l'\}}
{H,L,\jsfun[y]{x}{e} \levalsto H',l'}
\]

The arguments for Safety, Fault Avoidance, Safety Monotonicity and the Frame Property of the conclusion follow directly from their counterparts in the premise.

\subsubsection{Delete}

The inference rule for Delete is:
\[\frac
{\tr P {\js e} {Q \sep (\V{L},\V{X})\pointsto\_ \sep \rv\doteq\V{L}\sv\V{X}}}
{\tr  P {\js{delete e}} {Q \sep\rv\doteq 1}}
\]

The operational rule is:
\[\frac
{\begin{array}{l}H,L,\js{e} \levalsto H',\njs{r}\\%l'\sv x\\ 
        H'' = H'\setminus \njs{r}\end{array}}%l'\sv x}
{H,L,\js{delete e} \levalsto H'',1}
\]

The arguments for Safety, Fault Avoidance, Safety Monotonicity and the Frame Property of the conclusion follow directly from their counterparts in the premise.

\subsubsection{Delete Nothing}

The inference rule for Delete Nothing is:
\[\frac
{\tr P {\js e} { Q \sep \rv\doteq\E{V} \sep \E{V}\not\in\refs}}
{\tr P {\js{delete e}} { Q \sep\rv\doteq 1 }}
\]

The operational rule is:
\[\frac
{\begin{array}{l}H,L,\js{e} \levalsto H',\njs{r}\\%l'\sv x\\ 
        H'' = H'\setminus \njs{r}\end{array}}%l'\sv x}
{H,L,\js{delete e} \levalsto H'',1}
\]

The arguments for Safety, Fault Avoidance, Safety Monotonicity and the Frame Property of the conclusion follow directly from their counterparts in the premise.

\subsubsection{Literal Object}

The inference rule for Literal Object is:
\[\frac
{\begin{array}{l}
        Q_0 = P \\
        \forall i\in 1..n\\
\qquad\big(Q_i = Q_i'\sep\getValue(\V{LS}_i,\V{X}_i',\V{X}_i)\\
\qquad     ~\tr  {Q_{i-1}} {\js{ei}} {Q_i\sep\rv\doteq\V{X}_i'}\big)\\
        \js{x1} \neq \dots \neq \js{xn}\\ 
%
Q = \left\{ Q_n \sep \exists \V{L} \st \left(\begin{array}{l}
        \newobj(\V{L},\text{@proto},\js{x1},\dots,\js{xn}) \sep {}\\
        (\V{L},\text{@proto})\pointsto \lop \sep{}\\
        (\V{L},\js{x1})\pointsto\V{X}_1 \sep \dots \sep (\V{L},\js{xn})\pointsto\V{X}_n \sep{}\\
        \rv\doteq \V{L}
\end{array}\right)\right\}\\
%
\rv\not\in \fv(Q_n)\end{array}}
{\tr P {\js{\{x1}\js{:e1},\dots,\js{xn}\js{:en}\js{\}}} Q}
\]

The operational rule is:
\[\frac
{\begin{array}{l}
  (l',\protop) \not\in\domain(H) \\ %ah, the magic of well-formedness
  H_0 = H \sep (l',\protop)\pointsto \lop \\
  \forall i\in 1..n\\
  \qquad\big(H_{i-1},L,\js{ei}\levalsto H_i',\njs{r_i} \\ 
  \qquad\getValue(H_i',\njs{r_i}) = \njs{v_i}\\
  \qquad H_i = H_i' \semup{ (l',\js{xi}) \pointsto \njs{v_i}}\big)
  \end{array}}
{H,L,\{\js{x1:e1},\dots, \js{xn:en}\} \levalsto H_n,l'}
\]


In order to show Safety and Fault Avoidance:
\begin{enumerate}
        \item Consider arbitrary $h,L,\env$ such that $h,L,\env \satisfies P$
        \item let $H = \heval{h}$.
        \item \label{lst:litob:forall} For each $i \in 1..n$ :
                By the Fault Avoidance, Safety, Safety Monotonicity and Frame Properties of 
                \[ \begin{array}{rcl}
                        \{Q_{0}\}&{\js{e1}}&\{Q_1 \sep \rv \doteq \V{X}_1'\}\\
                        &\vdots&\\
                        \{Q_{i-1}\}&{\js{ei}}&\{Q_i \sep \rv \doteq \V{X}_i'\}
                \end{array}\] 
                we have:
                \[
                H_i,L,\env \satisfies Q_i \sep \exists\V{L}\st \left(
                \begin{array}{l}
                        \newobj(\V{L},\protop,\js{x1},\dots,\js{xi} \sep {}\\
                        (\V{L},\protop)\pointsto \lop \sep {} \\
                        (\V{L},\js{x1})\pointsto\V{X}_1 \sep \dots \sep (\V{L},\js{xi})\pointsto\V{X}_i
                \end{array}
                \right)
                \]
        \item By~\ref{lst:litob:forall} in the case where $i=n$, and by the operational rule, we have Fault Avoidance and Safety for the conclusion.
\end{enumerate}

The argument for Safety Monotonicity and the Frame Property follows a similar structure:

\begin{enumerate}
        \item Consider arbitrary $h,L,\env,h'$ such that $h,L,\env \satisfies P$ and $h\disj h'$
        \item let $H = \heval{h}$.
        \item  For each $i \in 1..n$ :
                By the Fault Avoidance, Safety, Safety Monotonicity and Frame Properties of
                \[ \begin{array}{rcl}
                        \{Q_{0}\}&{\js{e1}}&\{Q_1 \sep \rv \doteq \V{X}_1'\}\\
                        &\vdots&\\
                        \{Q_{i-1}\}&{\js{ei}}&\{Q_i \sep \rv \doteq \V{X}_i'\}
                \end{array}\] 
                we have:
                \begin{enumerate}
                        \item \label{lst:litob:SM} \[ (H_{i-1} \sep \heval{h'}),L,\js{ei} \not\!\!\!\!\levalsto\fault \]
                        \item \label{lst:litob:FP} 
                                \[\begin{array}{l}
                                        \exists H' \st H' = H_i \sep \heval{h'} \land {}\\
                                        (H_{i-1} \sep \heval{h'}),L,\js{ei} \levalsto H',v_i \land {} \\
                                        H_{i-1},L,\js{ei} \levalsto H_i,v_i
                                \end{array}\]
                \end{enumerate}
        \item By~\ref{lst:litob:SM} in the case where $i=n$, and by the operational rule, we have Safety Monotonicity for the conclusion.
        \item By~\ref{lst:litob:FP} in the case where $i=n$, and by the operational rule, we have the Frame Property for the conclusion.
\end{enumerate}

\subsubsection{Assign Global}

The inference rule for Assign Global is:
\[\frac
{\begin{array}{l}
        \tr P {\js{e1}} {R \sep\rv\doteq \nil\sv\V{X}}\\
\tr R {\js{e2}} {S\sep\getValue(\V{LIST},\LVAL',\LVAL) \sep (\lgo,\V{X}) \pointsto\none \sep\rv\doteq \LVAL'}\\
Q = \{S\sep\getValue(\V{LIST},\LVAL',\LVAL) \sep {} (\lgo,\V{X})\pointsto\LVAL \sep\rv\doteq \LVAL\}
\end{array}}
{ \tr P {\js{e1 = e2}} Q}
\]

The operational rule is:
\[\frac
{\begin{array}{l}
  H,L,\js{e1} \levalsto H_1,l'\sv\js{x}\\
  H_1,L,\js{e2} \levalsto H_2,\njs{r}\\
    \getValue(H_2,\njs{r}) = \njs{v}\\
  H'=H_2\semup{(l',\js{x})\pointsto\njs{v}}
\end{array}}
{H,L,\js{e1=e2} \levalsto H',\njs{v}}
\]

The arguments for Safety, Fault Avoidance, Safety Monotonicity and the Frame Property are similar to those for Sequence given in Section~\ref{sec:sequence}. The only details of note are that logical predicate $\getValue$ corresponds to the operational function of the same name by Lemma~\ref{lemma:gvsoundness}, and that $H\semup{(\nil,\js{x})\pointsto\njs{v}}$ is by definition equivalent to $H\semup{(\lgo,\js{x})\pointsto\njs{v}}$.

\subsubsection{Assign Local}

The inference rule for Assign Local is:
\[\frac
{\begin{array}{l}
        \tr P {\js{e1}} {R \sep\rv\doteq \V{L}\sv\V{X}}\\
\tr R {\js{e2}} {S\sep\getValue(\V{LIST},\LVAL',\LVAL) \sep (\V{L},\V{X}) \pointsto\LVAL'' \sep\rv\doteq \LVAL'}\\
Q = S\sep\getValue(\V{LIST},\LVAL',\LVAL) \sep (\V{L},\V{X})\pointsto\LVAL \sep\rv\doteq \LVAL
\end{array}}
{\tr P {\js{e1 = e2}} Q}
\]

The operational rule is:
\[\frac
{\begin{array}{l}
  H,L,\js{e1} \levalsto H_1,l'\sv\js{x}\\
  H_1,L,\js{e2} \levalsto H_2,\njs{r}\\
    \getValue(H_2,\njs{r}) = \njs{v}\\
  H'=H_2\semup{(l',\js{x})\pointsto\njs{v}}
\end{array}}
{H,L,\js{e1=e2} \levalsto H',\njs{v}}
\]

The arguments for Safety, Fault Avoidance, Safety Monotonicity and the Frame Property are similar to those for Sequence given in Section~\ref{sec:sequence}. The only detail of note are that logical predicate $\getValue$ corresponds to the operational function of the same name by Lemma~\ref{lemma:gvsoundness}.

\subsubsection{With}

The inference rule for With is:
\[\frac
{\begin{array}{l}
        \tr {P \sep \ls\doteq\V{L}} {\js{e1}} { R \sep \getValue(\V{LS},\V{V},\V{L}') \sep \V{L}'\not\doteq\nil \sep \ls\doteq\V{L}\sep \rv\doteq\V{V}} \\
\tr {R \sep \getValue(\V{LS},\V{V},\V{L}') \sep \V{L}'\not\doteq\nil\sep \ls\doteq\V{L}'}{ \js{e2} }{ Q\sep \ls\doteq\V{L}' }\\
\ls \not\in P, Q, R\end{array}}
{\tr { P \sep \ls\doteq\V{L}}{ \js{with(e1)\{e2\}}} { Q \sep \ls\doteq\V{L}}}
\]

The operational rule is:
\[\frac
{\begin{array}{l}
        H,L,\js{e1} \levalsto H',l\\
l\neq\nil\\
 H',l\cons L,\js{e2} \levalsto H'', \njs{r}
 \getValue(H'',\njs{r}) = v
 \end{array}}
{H,L,\js{with(e1)\{e2\}} \levalsto H'',v}
\]

The arguments for Safety, Fault Avoidance, Safety Monotonicity and the Frame Property are similar to those for Sequence given in Section~\ref{sec:sequence}. The only detail of note are that logical predicate $\getValue$ corresponds to the operational function of the same name by Lemma~\ref{lemma:gvsoundness}.

\subsubsection{Computed Access}

The inference rule for Computed Access is:
\[\frac
{\begin{array}{l}\tr P {\js e1} {R\sep\rv\doteq\LVAL_1}\\
\tr R {\js e2} {Q\sep\getValue(\E{List},\LVAL_2,\V{X})\sep X \dotin \uvars \sep\rv\doteq\LVAL_2}\\
R = S\sep\getValue(\E{List},\LVAL_1,\V{L})\sep\V{L}\not\doteq\nil\end{array}}
{\tr P {\js{e1[e2]}} {Q\sep\getValue(\E{List},\LVAL,\V{L})\sep\rv\doteq\V{L}\sv\V{X}}}
\]

The operational rule is:
\[\frac
{\begin{array}{l}H,L,\js{e1} \levalsto H_1,\njs{r_1} \\
\getValue(H_1,\njs{r_1}) = l'\\
l'\neq \nil\\
H_1,L,\js{e2} \levalsto H',\njs{r_2}\\
\getValue(H',\njs{r_2}) = \js{x}\end{array}}
{H,L,\js{e1[e2]} \levalsto H',l'\sv \js x}
\]

The argument for Safety, Fault Avoidance, Safety Monotonicity and the Frame Property are similar to those for Sequence in Section~\ref{sec:sequence}.


%% \bibliographystyle{plain}
%% \bibliography{gds}


\section{Abstraction Layer 1: Proofs for Section~\ref{sec:layer1}}
\label{sec:abslayer1}


\begin{lemma}[Scope Equality]
        \label{lemma:scopeprimeproof}
        \[ \begin{array}{l}
                \forall h,L,\env \st h,L,\env\satisfies \scope(\E{List},\E{Scope},\E{Var},\E{Loc}) \iff\\
                \qquad\qquad h,L,\env\satisfies \scopepr(\E{List},\E{Scope},\E{Var},\E{Loc})
        \end{array}\]

        \begin{proof}
                By induction on the definitions of $\scope$ and $\scopepr$. First, the cases for $\scope$.

                \textbf{Case 1}\\
\[
\begin{array}{c}
  \scope([],\nil,\_,\nil) \\
  \iff\\
  \lemp\\
  \iff\\
  \notscope([],\nil,\_,\nil)\\
  \iff\\
  \scopepr([],\nil,\_\nil)
\end{array}
\]

                \textbf{Case 2}
\[
\begin{array}{c}
        \scope([\E{List2}],(\E{Start}:\_),\E{Var},\E{Start}) \\
  \iff\\
  \exists\V{L}\st\proto(\E{List2},\E{Start}, \E{Var}, \V{L}) \sep \V{L}\not\doteq\nil \\
  \iff\\
  \lemp \sep 
  \exists\V{L}\st\proto(\E{List2},\E{Start}, \E{Var}, \V{L}) \sep \V{L}\not\doteq\nil \\
  \iff\\
  \notscope([],(\E{Start}:\_),\V{Var},\E{Start})\sep {}\\
  \exists\V{L}\st\proto(\E{List2},\E{Start}, \E{Var}, \V{L}) \sep \V{L}\not\doteq\nil \\
  \iff\\
  \scopepr([]++[\E{List2}],(\E{Start}:\_),\E{Var},\E{Start}\\
  \iff\\
  \scopepr([\E{List2}],(\E{Start}:\_),\E{Var},\E{Start}\\
\end{array}
\]
                \textbf{Case 3}
\[
\begin{array}{cr}
        \scope((\E{List2}:\E{List}),(\E{Start}:\E{Scope}),\E{Var},\E{Loc}) \\
  \iff\\
  \proto(\E{List2},\E{Start},\E{Var},\nil) \sepish {}\\
%  (\exists \V{NEXT}\st(\E{Start},\scopep)\pointsto \V{NEXT} \sep{}\\
  \scope(\E{List},\E{Scope},\E{Var},\E{Loc})\\
  \iff &\text{[Inductive Step]}\\
  \proto(\E{List2},\E{Start},\E{Var},\nil) \sepish {}\\
  %(\exists \V{NEXT}\st(\E{Start},\scopep)\pointsto \V{NEXT} \sep{}\\
  \scopepr(\E{List},\E{Scope},\E{Var},\E{Loc})\\
  \text{Case Split} 
\end{array}
\]
                \textbf{Case 3.1: $\E{Loc}=\nil$}
\[
\begin{array}{c}
        \proto(\E{List2},\E{Start},\E{Var},\nil) \sepish {}\\
        %(\exists\V{NEXT}\st(\E{Start},\scopep)\pointsto \V{NEXT} \sep{}\\
  \scopepr(\E{List},\E{Scope},\E{Var},\nil)\\
  \iff\\
  \proto(\E{List2},\E{Start},\E{Var},\nil) \sepish {}\\
  %(\exists\V{NEXT}\st(\E{Start},\scopep)\pointsto \V{NEXT} \sep{}\\
  \notscope(\E{List},\E{Scope},\E{Var},\nil)\\
  \iff\\
  \notscope((\E{List2}:\E{List}),(\E{Start}:\E{Scope}),\E{Var},\nil)\\
  \iff\\
  \notscope((\E{List2}:\E{List}),(\E{Start}:\E{Scope}),\E{Var},\E{Loc})
\end{array}
\]
                \textbf{Case 3.2: $\E{Loc}\neq\nil$}
\[
\begin{array}{c}
        \proto(\E{List2},\E{Start},\E{Var},\nil) \sepish {}\\
        %(\exists\V{NEXT}\st(\E{Start},\scopep)\pointsto \V{NEXT} \sep{}\\
  \scopepr(\E{List},\E{Scope},\E{Var},\E{Loc})\\\\
  \iff \\
  \text{[Let $\E{List}\equiv\E{List1}'++[\E{List2}']$]}\\\\
  \proto(\E{List2},\E{Start},\E{Var},\nil) \sepish {}\\
  \left(\begin{array}{l}
          %\exists\V{NEXT}\st(\E{Start},\scopep)\pointsto \V{NEXT} \sep {}\\
          \notscope(\E{List1}',\E{Scope},\E{Var},\E{Loc}) \sep{}\\ 
          \exists\V{L2}\st\proto(\E{List2}',\E{Loc},\E{Var},\E{L2}) \sep{}\\
          \V{L2}\not\doteq\nil 
  \end{array}\right)\\\\
  \iff \\
  \text{[Since the proto chain of $\E{Start}$ doesn't contain $\E{Var}$]}\\\\
  \proto(\E{List2},\E{Start},\E{Var},\nil) \sepish {}\\
  %\left(\begin{array}{l}
          %\exists\V{NEXT}\st(\E{Start},\scopep)\pointsto \V{NEXT} \sep {}\\
          \notscope(\E{List1}',\E{Scope},\E{Var},\E{Loc})% \sep{}\\ 
  %\end{array}\right) \\
  \sep \\
  \left(\begin{array}{l}
          \exists\V{L2}\st\proto(\E{List2}',\E{Loc},\E{Var},\E{L2})\\
          {}\sep\V{L2}\not\doteq\nil 
  \end{array}\right) \\\\
  \iff \\
  \notscope(\E{List2}:\E{List1'},(\E{Start}:\E{Scope}),\E{Var},\E{Loc})\\
  \sep \\
  \left(\begin{array}{l}
          \exists\V{L2}\st\proto(\E{List2}',\E{Loc},\E{Var},\E{L2})\\
          {}\sep\V{L2}\not\doteq\nil 
  \end{array}\right) \\
  \iff \\
  \scopepr(\E{List2}:\E{List1'}++\E{List2}',(\E{Start}:\E{Scope}),\E{Var},\E{Loc})\\
  \iff \\
  \scopepr(\E{List2}:\E{List},(\E{Start}:\E{Scope}),\E{Var},\E{Loc})\\
\end{array}
\]
                
The first case for $\scopepr$ is trivial, since in the $\nil$ case $\scopepr$ and $\notscope$ are identical. The second case for $\scopepr$ is similar to the third case for $\scope$.
        \end{proof}
\end{lemma}

\subsection{Assigning a constant to a variable}
\label{sec:constantvar}

\iflong{This section contains proofs of the triples given in Section~\ref{sec:layer1}.}

\ifshort{
Here we prove the following simple assignment rules:

\begin{display}{Simple Assignments.}
\nohrule
{P = \scope(\E{L_1}{\append}((\lgo\cons\E{L_2})\cons\E{L_3}),\ls,\js{x},\nil)\\[\gap]
 Q = \left(\begin{array}{c}     \exists\V{L_1'},\V{L_3'},\V{Sc},\V{G}\st~~
                                \notscopeg(\V{L_1'},\ls,\js{x},\lgo) \sepish\\ \proto(\E{L_2},\V{G},\js{x},\nil) \sepish {}
                                \notscopeg(\V{L_3'},\V{Sc},\js{x},\nil) \sep {}                                (\lgo,\js{x})\pointsto \js{v} \sep\\
 (\lgo,\protop)\pointsto\V{G} \sep \ls\doteq \_{\append}(\lgo \cons \V{Sc}) \sep {}
                                \rv\doteq  \js{v} \end{array}\right)}
{\tr{P}{\js{x = v}}{Q}}
\\[\gap]


\nohrule
{P = \scope(\E{L_1}{\append}[\E{L}\cons\E{L_2}]),\ls,\js{x},\E{L}) \sepish (\E{L},\js{x})\pointsto \none\sepish
                               \getValue(\E{L}\cons\E{L_2},\js{x},\E{V})\\[\gap]
 Q =                         \left(\begin{array}{l}
                                \exists\V{L'}\st
                                \notscope(\E{L_1},\ls,\js{x},\E{L})  \sep {}
                                (\E{L},\js{x})\pointsto \js{v} \sep  (\E{L},\protop)\pointsto\E{Pr} \sep{}\\
                                \proto(\E{L_2},\E{Pr},\js{x},\V{L'}) \sepish (\V{L'},\js{x})\pointsto\E{V}
                                \sep\rv\doteq \E{L}\sv\js{x}
                        \end{array}\right)}
{\tr P{\js{x = v}}Q}
\\[\gap]

                
\nohrule
{P = \scope(\E{L_1}{\append}[[\E{L}]],\ls,\js{x},\E{L}) \sepish (\E{L},\js{x})\pointsto\E{V}\sep\E{V}\not\doteq\none\\
 Q =                        
                                \notscope(\E{L_1},\ls,\js{x},\E{L}) \sep {}
                                (\E{L},\js{x})\pointsto \js{v} \sep\rv\doteq  \js{v} 
                        }
{\tr P{\js{x = v}}Q}
\\[\gap]


\nohrule
{P = \left(\begin{array}{l}
                                \scope(\Lista,\ls,\js{y},\E{L}_y)  \sepish \getValue(\Listb,\E{L}_y\sv\js{y},\E{V}_y)  \sepish{}\\
                                \scope(\E{L_1}{\append}((\E{L}\cons{\emptylist})\cons{\emptylist}),\ls,\js{x},\E{L}) \sepish {}
                                (\E{L},\js{x})\pointsto\E{V}\sep\E{V}\not\doteq\none 
                        \end{array}\right)\Gap\\[\gap]
                         Q =  \scope(\Lista,\ls,\js{y},\E{L}_y)  \sepish \notscope(\E{L_1},\ls,\js{x},\E{L}) \sep{} (\E{L},\js{x})\pointsto \E{V}_y \sep\rv\doteq  \E{V}_y}
{\tr P{\js{x = y}}Q}
%
\end{display}}

The proofs are in
Figures~\ref{fig:assignmentproofnew},~\ref{fig:assignmentproofnew2} and~\ref{fig:assignmentproofnew3}. 


\begin{sidewaysfigure*}[h]
%        \scriptsize
        \begin{center}
\infer[cons]{
\begin{array}{c}
        %\left\{\begin{array}{c}
        %        \notscope(\V{L1},\ls,\js{x},\lgo) \sepish \proto(\V{L2},\V{GP},\js{x},\nil) \sep {}\\
        %        (\lgo,\js{x})\pointsto \none \sep (\lgo,\scopep)\pointsto\nil \sep (\lgo,\protop)\pointsto\V{GP} 
        %\end{array}\right\} \\
        \{ \scope(\V{L1}++((\lgo:\V{L2}):\V{L3}),\ls,\js{x},\nil) \} \\
        \js{x = v}\\
        \left\{\begin{array}{c}
                \exists\V{L1}',\V{L3}',\V{SCOPE}',\V{GP}\st\\
                \notscopeg(\V{L1}',\ls,\js{x},\lgo) \sepish \proto(\V{L2},\V{GP},\js{x},\nil) \sepish {}\\
                \notscopeg(\V{L3}',\V{SCOPE}',\js{x},\nil) \sep {}\\
                (\lgo,\js{x})\pointsto \js{v} \sep \ls \doteq \_++(\lgo:\V{SCOPE}') \sep {} \\
                (\lgo,\text{@proto})\pointsto\V{GP} \sep\rv\doteq  \js{v} 
        \end{array}\right\} \\
        %\{ \notscopeg(\V{L1},\ls,\js{x},\lgo) \sep (\lgo,\js{x})\pointsto v \sep (\lgo,\scopep)\pointsto\nil \sep (\lgo,\protop)\pointsto\V{GP} \sep \proto(\V{L2},\V{GP},\js{x},\nil) | \js{v} \}
\end{array}
}{
        \infer[assignment]{
        \begin{array}{c}
                \left\{\begin{array}{c}
                        \exists\V{L1}',\V{L3}',\V{SCOPE}',\V{GP}\st\\
                        \notscopeg(\V{L1}',\ls,\js{x},\lgo) \sepish \proto(\V{L2},\V{GP},\js{x},\nil) \sepish {}\\
                        \notscopeg(\V{L3}',\V{SCOPE}',\js{x},\nil) \sep {}\\
                        (\lgo,\js{x})\pointsto \none \sep \ls\doteq\_++(\lgo:\V{SCOPE}') \sep {}\\
                        (\lgo,\protop)\pointsto\V{GP} 
                \end{array}\right\} \\
                \js{x = v} \\
                \left\{\begin{array}{c}
                        \exists\V{L1}',\V{L3}',\V{SCOPE}',\V{GP}\st\\
                        \notscopeg(\V{L1}',\ls,\js{x},\lgo) \sepish \proto(\V{L2},\V{GP},\js{x},\nil) \sepish {}\\
                        \notscopeg(\V{L3}',\V{SCOPE}',\js{x},\nil) \sep {}\\
                        (\lgo,\js{x})\pointsto \js{v} \sep \ls \doteq \_++(\lgo:\V{SCOPE}') \sep {}\\
                        (\lgo,\text{@proto})\pointsto\V{GP} \sep\rv\doteq \js{v}
                \end{array}\right\} \\
                %\{ \notscope(\V{L1},\ls,\js{x},\lgo) \sep (\lgo,\js{x})\pointsto v \sep (\lgo,\scopep)\pointsto\nil \sep (\lgo,\protop)\pointsto\V{GP} \sep \proto(\V{L2},\V{GP},\js{x},\nil) | v \}
        \end{array}
        }{
                \infer[cons]{
                \begin{array}{c}
                        \left\{\begin{array}{c}
                                \exists\V{L1}',\V{L3}',\V{SCOPE}',\V{GP}\st\\
                                \notscopeg(\V{L1}',\ls,\js{x},\lgo) \sepish \proto(\V{L2},\V{GP},\js{x},\nil) \sepish {}\\
                                \notscopeg(\V{L3}',\V{SCOPE}',\js{x},\nil) \sep {}\\
                                (\lgo,\js{x})\pointsto \none \sep \ls\doteq\_++(\lgo:\V{SCOPE}') \sep {}\\
                                (\lgo,\protop)\pointsto\V{GP} 
                        \end{array}\right\} \\
                        \js{x}\\
                        \left\{\begin{array}{c}
                                \exists\V{L1}',\V{L3}',\V{SCOPE}',\V{GP}\st\\
                                \notscopeg(\V{L1}',\ls,\js{x},\lgo) \sepish \proto(\V{L2},\V{GP},\js{x},\nil) \sepish {}\\
                                \notscopeg(\V{L3}',\V{SCOPE}',\js{x},\nil) \sep {}\\
                                (\lgo,\js{x})\pointsto \none \sep \ls\doteq\_++(\lgo:\V{SCOPE}') \sep {}\\
                                (\lgo,\text{@proto})\pointsto\V{GP} \sep\rv\doteq \nil\sv\js{x}
                        \end{array}\right\} 
                \end{array}
                }{
                       \infer[variable\ axiom]{
                       \begin{array}{c}
                                \{\scope(\V{L1}++((\lgo:\V{L2}):\V{L3}),\ls,\js{x},\nil)\}\\
                                \js{x}\\
                                \{\scope(\V{L1}++((\lgo:\V{L2}):\V{L3}),\ls,\js{x},\nil) \sep\rv\doteq \nil\sv\js{x}\} 
                        \end{array}
                        }{}
                }
                \quad 
                        \infer[frame]{
                        \begin{array}{c}
                        \left\{\begin{array}{c}
                                \exists\V{L1}',\V{L3}',\V{SCOPE}',\V{GP}\st\\
                                \notscopeg(\V{L1}',\ls,\js{x},\lgo) \sepish \proto(\V{L2},\V{GP},\js{x},\nil) \sepish {}\\
                                \notscopeg(\V{L3}',\V{SCOPE}',\js{x},\nil) \sep {}\\
                                (\lgo,\js{x})\pointsto \none \sep \ls\doteq\_++(\lgo:\V{SCOPE}') \sep {}\\
                                (\lgo,\protop)\pointsto\V{GP} 
                        \end{array}\right\} \\
                                \js{v}\\
                        \left\{\begin{array}{c}
                                \exists\V{L1}',\V{L3}',\V{SCOPE}',\V{GP}\st\\
                                \notscopeg(\V{L1}',\ls,\js{x},\lgo) \sepish \proto(\V{L2},\V{GP},\js{x},\nil) \sepish {}\\
                                \notscopeg(\V{L3}',\V{SCOPE}',\js{x},\nil) \sep {}\\
                                (\lgo,\js{x})\pointsto \none \sep \ls\doteq\_++(\lgo:\V{SCOPE}') \sep {}\\
                                (\lgo,\text{@proto})\pointsto\V{GP} \sep\rv\doteq \js{v} 
                        \end{array}\right\} \\
                        \end{array}
                        }{
                                \infer[value\ axiom]{\{\lemp\} \js{v}\{\lemp \sep\rv\doteq \js{v}\}}{}
                        }
        }
}
        \end{center}
        \caption{Proof of assignment to a fresh global variable}
        \label{fig:assignmentproofnew}
\end{sidewaysfigure*}




\begin{sidewaysfigure*}[h]
%        \scriptsize
        \begin{center}
\infer[cons]{
\begin{array}{c}
        %\left\{\begin{array}{c}
        %        \notscope(\V{L1},\ls,\js{x},\lgo) \sep \proto(\V{L2},\V{GP},\js{x},\nil) \sep {}\\
        %        (\lgo,\js{x})\pointsto \none \sep (\lgo,\scopep)\pointsto\nil \sep (\lgo,\protop)\pointsto\V{GP} 
        %\end{array}\right\} \\
        \{ \scope(\V{L1}++[\V{L}:\V{L2}]),\ls,\js{x},\V{L}) \sepish (\V{L},\js{x})\pointsto \none\sepish
               \getValue(\V{L}:\V{L2},\V{L}\sv\js{x},\LVAL) \} \\
        \js{x = v}\\
        \left\{\begin{array}{l}
                \exists\V{L}'\st\\
                \notscope(\V{L1},\ls,\js{x},\V{L})  \sep {}\\
                (\V{L},\js{x})\pointsto \js{v} \sep (\V{L},\text{@proto})\pointsto\V{PR} \sep{}\\
                \proto(\V{L2},\V{PR},\js{x},\V{L}') \sepish (\V{L}',\js{x})\pointsto\LVAL
                \sep\rv\doteq \V{L}\sv\js{x}
        \end{array}\right\} 
        %\{ \notscope(\V{L1},\ls,\js{x},\lgo) \sep (\lgo,\js{x})\pointsto v \sep (\lgo,\scopep)\pointsto\nil \sep (\lgo,\protop)\pointsto\V{GP} \sep \proto(\V{L2},\V{GP},\js{x},\nil) | \js{v} \}
\end{array}
}{
        \infer[assignment]{
        \begin{array}{c}
                \left\{\begin{array}{l}
                        \exists\V{L}'\st\\
                        \notscope(\V{L1},\ls,\js{x},\V{L}) \sep {}\\
                        (\V{L},\js{x})\pointsto \none \sep (\V{L},\protop)\pointsto\V{PR} \sep {}\\
                        \proto(\V{L2},\V{PR},\js{x},\V{L}') \sepish (\V{L}',\js{x})\pointsto\LVAL
                \end{array}\right\} \\
                \js{x = v} \\
                \left\{\begin{array}{l}
                        \exists\V{L}'\st\\
                        \notscope(\V{L1},\ls,\js{x},\V{L})  \sep {}\\
                        (\V{L},\js{x})\pointsto \js{v} \sep (\V{L},\text{@proto})\pointsto\V{PR} \sep{}\\
                        \proto(\V{L2},\V{PR},\js{x},\V{L}') \sepish (\V{L}',\js{x})\pointsto\LVAL
                        \sep\rv\doteq \V{L}\sv\js{x}
                \end{array}\right\} 
                %\{ \notscope(\V{L1},\ls,\js{x},\V{L}) \sep (\V{L},\js{x})\pointsto v \sep (\V{L},\scopep)\pointsto\nil \sep (\V{L},\protop)\pointsto\V{PR} \sep \proto(\V{L2},\V{PR},\js{x},\nil) | v \}
        \end{array}
        }{
                \infer[cons]{
                \begin{array}{c}
                        \left\{\begin{array}{l}
                                \exists\V{L}'\st\\
                                \notscope(\V{L1},\ls,\js{x},\V{L}) \sep {}\\
                                (\V{L},\js{x})\pointsto \none \sep (\V{L},\protop)\pointsto\V{PR} \sep {}\\
                                \proto(\V{L2},\V{PR},\js{x},\V{L}') \sepish (\V{L}',\js{x})\pointsto\LVAL
                        \end{array}\right\} \\
                        \js{x}\\
                        \left\{\begin{array}{l}
                                \exists\V{L}'\st\\
                                \notscope(\V{L1},\ls,\js{x},\V{L})  \sep {}\\
                                (\V{L},\js{x})\pointsto \none \sep (\V{L},\text{@proto})\pointsto\V{PR} \sep{}\\
                                \proto(\V{L2},\V{PR},\js{x},\V{L}') \sepish (\V{L}',\js{x})\pointsto\LVAL
                                \sep\rv\doteq \V{L}\sv\js{x}
                        \end{array}\right\} 
                \end{array}
                }{
                       \infer[variable\ axiom]{
                       \begin{array}{c}
                               \left\{\begin{array}{l}
                                       \scope(\V{L1}++[\V{L}:\V{L2}],\ls,\js{x},\V{L}) \sepish{}\\
                                       \getValue(\V{L}:\V{L2},\V{L}\sv\js{x},\LVAL)
                               \end{array}\right\}\\
                                \js{x}\\
                               \left\{\begin{array}{l}
                                       \scope(\V{L1}++[\V{L}:\V{L2}]),\ls,\js{x},\V{L}) \sepish{}\\
                                       \getValue(\V{L}:\V{L2},\V{L}\sv\js{x},\LVAL)
                                       \sep\rv\doteq \V{L}\sv\js{x}
                               \end{array}\right\}\\
                        \end{array}
                        }{}
                }
                \quad 
                        \infer[frame]{
                        \begin{array}{c}
                        \left\{\begin{array}{l}
                                \exists\V{L}'\st\\
                                \notscope(\V{L1},\ls,\js{x},\V{L}) \sep {}\\
                                (\V{L},\js{x})\pointsto \none \sep (\V{L},\protop)\pointsto\V{PR} \sep {}\\
                                \proto(\V{L2},\V{PR},\js{x},\V{L}') \sepish (\V{L}',\js{x})\pointsto\LVAL
                        \end{array}\right\} \\
                                \js{v}\\
                        \left\{\begin{array}{l}
                                \exists\V{L}'\st\\
                                \notscope(\V{L1},\ls,\js{x},\V{L})  \sep {}\\
                                (\V{L},\js{x})\pointsto \none \sep (\V{L},\text{@proto})\pointsto\V{PR} \sep{}\\
                                \proto(\V{L2},\V{PR},\js{x},\V{L}') \sepish (\V{L}',\js{x})\pointsto\LVAL
                                \sep\rv\doteq \js{v} 
                        \end{array}\right\} \\
                        \end{array} 
                        }{
                                \infer[value\ axiom]{\{\lemp\} \js{v}\{\lemp \sep\rv\doteq \js{v}\}}{}
                        }
        }
}
        \end{center}
        \caption{Proof of an overriding assignment}
        \label{fig:assignmentproofnew2}
\end{sidewaysfigure*}



\begin{sidewaysfigure*}[h]
%        \scriptsize
        \begin{center}
\infer[cons]{
\begin{array}{c}
        %\left\{\begin{array}{c}
        %        \notscope(\V{L1},\ls,\js{x},\lgo) \sepish \proto(\V{L2},\V{GP},\js{x},\nil) \sep {}\\
        %        (\lgo,\js{x})\pointsto \none \sep (\lgo,\scopep)\pointsto\nil \sep (\lgo,\protop)\pointsto\V{GP} 
        %\end{array}\right\} \\
        \{ \scope(\V{L1}++[[\V{L}]],\ls,\js{x},\V{L}) \sepish (\V{L},\js{x})\pointsto\LVAL\sep\LVAL\not\doteq\none \} \\
        \js{x = v}\\
        \left\{\begin{array}{c}
                \notscope(\V{L1},\ls,\js{x},\V{L}) \sep {}\\
                (\V{L},\js{x})\pointsto \js{v} \sep\rv\doteq  \js{v} 
        \end{array}\right\} \\
        %\{ \notscope(\V{L1},\ls,\js{x},\lgo) \sep (\lgo,\js{x})\pointsto v \sep (\lgo,\scopep)\pointsto\nil \sep (\lgo,\protop)\pointsto\V{GP} \sep \proto(\V{L2},\V{GP},\js{x},\nil) | \js{v} \}
\end{array}
}{
        \infer[assignment]{
        \begin{array}{c}
                \left\{\begin{array}{c}
                        \notscope(\V{L1},\ls,\js{x},\V{L}) \sep {}\\
                        (\V{L},\js{x})\pointsto \LVAL \sep \LVAL\not\doteq\none 
                \end{array}\right\} \\
                \js{x = v} \\
                \left\{\begin{array}{c}
                        \notscope(\V{L1},\ls,\js{x},\V{L}) \sep {}\\
                        (\V{L},\js{x})\pointsto \js{v} \sep\rv\doteq \js{v}
                \end{array}\right\} \\
                %\{ \notscope(\V{L1},\ls,\js{x},\V{L}) \sep (\V{L},\js{x})\pointsto v \sep (\V{L},\scopep)\pointsto\nil \sep (\V{L},\protop)\pointsto\V{PR} \sep \proto(\V{L2},\V{PR},\js{x},\nil) | v \}
        \end{array}
        }{
                \infer[cons]{
                \begin{array}{c}
                        \left\{\begin{array}{c}
                                \notscope(\V{L1},\ls,\js{x},\V{L}) \sep {}\\
                                (\V{L},\js{x})\pointsto \LVAL \sep \LVAL\not\doteq\none 
                        \end{array}\right\} \\
                        \js{x}\\
                        \left\{\begin{array}{c}
                                \notscope(\V{L1},\ls,\js{x},\V{L}) \sep {}\\
                                (\V{L},\js{x})\pointsto \LVAL \sep \LVAL\not\doteq\none \sep\rv\doteq \V{L}\sv\js{x}
                        \end{array}\right\} 
                \end{array}
                }{
                       \infer[variable\ axiom]{
                       \begin{array}{c}
                                \left\{\begin{array}{c}
                                        \scope(\V{L1}++[[\V{L}]],\ls,\js{x},\V{L}) \sepish {}\\
                                        (\V{L},\js{x})\pointsto \LVAL \sep \LVAL\not\doteq\none 
                                \end{array}\right\} \\
                                \js{x}\\
                                \left\{\begin{array}{c}
                                        \scope(\V{L1}++[[\V{L}]],\ls,\js{x},\V{L}) \sepish {}\\
                                        (\V{L},\js{x})\pointsto \LVAL \sep \LVAL\not\doteq\none 
                                        \sep\rv\doteq \V{L}\sv\js{x} 
                                \end{array}\right\} \\
                        \end{array}
                        }{}
                }
                \quad 
                        \infer[frame]{
                        \begin{array}{c}
                        \left\{\begin{array}{c}
                                \notscope(\V{L1},\ls,\js{x},\V{L})  \sep {}\\
                                (\V{L},\js{x})\pointsto \LVAL \sep \LVAL\not\doteq\none 
                        \end{array}\right\} \\
                                \js{v}\\
                        \left\{\begin{array}{c}
                                \notscope(\V{L1},\ls,\js{x},\V{L})  \sep {}\\
                                (\V{L},\js{x})\pointsto \LVAL \sep \LVAL\not\doteq\none \sep\rv\doteq \js{v} 
                        \end{array}\right\} \\
                        \end{array}
                        }{
                                \infer[value\ axiom]{\{\lemp\} \js{v}\{\lemp \sep\rv\doteq \js{v}\}}{}
                        }
        }
}
        \end{center}
        \caption{Proof of an assignment to an existing object-variable}
        \label{fig:assignmentproofnew3}
\end{sidewaysfigure*}
\iflong{
\subsection{Assigning the value of a variable to another variable}
\label{sec:assignvarvar}

The proof of the triple given in Section~\ref{sec:assignvarvar} of the main document is in Figure~\ref{fig:assignmentvarproofnew3}.
}
\begin{sidewaysfigure*}[h]
%        \scriptsize
        \begin{center}
\infer[cons]{
\begin{array}{c}
        %\left\{\begin{array}{c}
        %        \notscope(\V{L1},\ls,\js{x},\lgo) \sepish \proto(\V{L2},\V{GP},\js{x},\nil) \sep {}\\
        %        (\lgo,\js{x})\pointsto \none \sep (\lgo,\scopep)\pointsto\nil \sep (\lgo,\protop)\pointsto\V{GP} 
        %\end{array}\right\} \\
        \{ \scope(\V{LIST},\ls,\js{y},\V{L}_y)  \sepish \getValue(\V{VALLIST},\V{L}_y\sv\js{y},\LVAL_y)  \sepish \scope(\V{L1}++[[\V{L}]],\ls,\js{x},\V{L}) \sepish (\V{L},\js{x})\pointsto\LVAL\sep\LVAL\not\doteq\none \} \\
        \js{x = y}\\
        \{        \scope(\V{LIST},\ls,\js{y},\V{L}_y)  \sepish \notscope(\V{L1},\ls,\js{x},\V{L}) \sep
        (\V{L},\js{x})\pointsto \LVAL_y \sep\rv\doteq  \LVAL_y   \}
        %\{ \notscope(\V{L1},\ls,\js{x},\lgo) \sep (\lgo,\js{x})\pointsto v \sep (\lgo,\scopep)\pointsto\nil \sep (\lgo,\protop)\pointsto\V{GP} \sep \proto(\V{L2},\V{GP},\js{x},\nil) | \js{v} \}
\end{array}
}{
        \infer[assignment]{
        \begin{array}{c}
        \left\{\begin{array}{l}
                \scope(\V{LIST},\ls,\js{y},\V{L}_y)  \sepish \getValue(\V{VALLIST},\V{L}_y\sv\js{y},\LVAL_y)  \sepish{}\\(
                        \notscope(\V{L1},\ls,\js{x},\V{L})  \sep 
                        (\V{L},\js{x})\pointsto \LVAL \sep \LVAL\not\doteq\none 
                ) \\
        \end{array}\right\} \\
                \js{x = y}\\
        \left\{\begin{array}{ll}
                (\scope(\V{LIST},\ls,\js{y},\V{L}_y) \sepish {}\\
                \getValue(\V{VALLIST},\V{L}_y\sv\js{y},\LVAL_y) \sepish{}\\
                \notscope(\V{L1},\ls,\js{x},\V{L}))  \sep{}\\
                        (\V{L},\js{x})\pointsto \LVAL_y \sep \LVAL\not\doteq\none 
                 \sep\rv\doteq \LVAL_y
        \end{array}\right\} \\
        \end{array}
        }{
                \infer[cons]{
                        \begin{array}{c}
                        \left\{\begin{array}{l}
                                \scope(\V{LIST},\ls,\js{y},\V{L}_y)  \sepish \getValue(\V{VALLIST},\V{L}_y\sv\js{y},\LVAL_y)  \sepish{}\\(
                                        \notscope(\V{L1},\ls,\js{x},\V{L})  \sep 
                                        (\V{L},\js{x})\pointsto \LVAL \sep \LVAL\not\doteq\none 
                                ) \\
                        \end{array}\right\} \\
                                \js{x}\\
                        \left\{\begin{array}{ll}
                                \scope(\V{LIST},\ls,\js{y},\V{L}_y) )  \sepish \getValue(\V{VALLIST},\V{L}_y\sv\js{y},\LVAL_y) \sepish{}\\(
                                        \notscope(\V{L1},\ls,\js{x},\V{L})  \sep
                                        (\V{L},\js{x})\pointsto \LVAL \sep \LVAL\not\doteq\none 
                                )  \sep\rv\doteq \V{L}\sv\js{x}
                        \end{array}\right\} \\
                        \end{array}
                }{
                        \infer[frame]{
                                \begin{array}{c}
                                        \left\{\begin{array}{l}
                                                (\notscope(\V{L1},\ls,\js{x},\V{L}) \sep 
                                                (\V{L},\js{x})\pointsto \LVAL \sep \LVAL\not\doteq\none ) \sep (\\
                                                        \quad(\notscope(\V{L1},\ls,\js{x},\V{L}) \sep (\V{L},\js{x})\pointsto \LVAL \sep \LVAL\not\doteq\none ) \wand ( \\
                                                                \qquad \scope(\V{LIST},\ls,\js{y},\V{L}_y)  \sepish \getValue(\V{VALLIST},\V{L}_y\sv\js{y},\LVAL_y) \sepish (\\
                                                                        \qquad\quad \notscope(\V{L1},\ls,\js{x},\V{L})  \sep {}\\
                                                                        \qquad\quad (\V{L},\js{x})\pointsto \LVAL \sep \LVAL\not\doteq\none \\
                                                                \qquad)\\
                                                        \quad)\\
                                                )\\
                                        \end{array}\right\} \\
                                        \js{x}\\
                                        \left\{\begin{array}{ll}
                                                (\notscope(\V{L1},\ls,\js{x},\V{L}) \sep 
                                                (\V{L},\js{x})\pointsto \LVAL \sep \LVAL\not\doteq\none ) \sep (\\
                                                        \quad(\notscope(\V{L1},\ls,\js{x},\V{L}) \sep (\V{L},\js{x})\pointsto \LVAL \sep \LVAL\not\doteq\none ) \wand ( \\
                                                                \qquad \scope(\V{LIST},\ls,\js{y},\V{L}_y)  \sepish \getValue(\V{VALLIST},\V{L}_y\sv\js{y},\LVAL_y) \sepish (\\
                                                                        \qquad\quad \notscope(\V{L1},\ls,\js{x},\V{L})  \sep {}\\
                                                                        \qquad\quad (\V{L},\js{x})\pointsto \LVAL \sep \LVAL\not\doteq\none \\
                                                                \qquad)\\
                                                        \quad )\\
                                                )  \sep\rv\doteq \V{L}\sv\js{x}\\
                                        \end{array}\right\} \\
                                \end{array}
                        }{
                                \infer[cons]{
                                \begin{array}{c}
                                        \left\{\begin{array}{c}
                                                \notscope(\V{L1},\ls,\js{x},\V{L}) \sep {}\\
                                                (\V{L},\js{x})\pointsto \LVAL \sep \LVAL\not\doteq\none 
                                        \end{array}\right\} \\
                                        \js{x}\\
                                        \left\{\begin{array}{c}
                                                \notscope(\V{L1},\ls,\js{x},\V{L}) \sep {}\\
                                                (\V{L},\js{x})\pointsto \LVAL \sep \LVAL\not\doteq\none \sep\rv\doteq \V{L}\sv\js{x}
                                        \end{array}\right\} 
                                \end{array}
                                }{
                                       \infer[var\ axiom]{
                                       \begin{array}{c}
                                                \left\{\begin{array}{c}
                                                        \scope(\V{L1}++[[\V{L}]],\ls,\js{x},\V{L}) \sepish{}\\
                                                        (\V{L},\js{x})\pointsto \LVAL \sep \LVAL\not\doteq\none 
                                                \end{array}\right\} \\
                                                \js{x}\\
                                                \left\{\begin{array}{c}
                                                        \scope(\V{L1}++[[\V{L}]],\ls,\js{x},\V{L}) \sepish{}\\
                                                        (\V{L},\js{x})\pointsto \LVAL \sep \LVAL\not\doteq\none 
                                                        \sep\rv\doteq \V{L}\sv\js{x} 
                                                \end{array}\right\} \\
                                        \end{array}
                                        }{}
                                }
                        }
                }
                \quad 
%REDUNDANT                \infer[cons]{
%REDUNDANT                                \begin{array}{c}
%REDUNDANT                                \left\{\begin{array}{l}
%REDUNDANT                                        \scope(\V{LIST},\ls,\js{y},\V{L}_y)  \sepish{}\\(
%REDUNDANT                                                \notscope(\V{L1},\ls,\js{x},\V{L})  \sep 
%REDUNDANT                                                (\V{L},\js{x})\pointsto \LVAL \sep \LVAL\not\doteq\none 
%REDUNDANT                                        ) \\
%REDUNDANT                                \end{array}\right\} \\
%REDUNDANT                                        \js{y}\\
%REDUNDANT                                \left\{\begin{array}{ll}
%REDUNDANT                                        (\scope(\V{LIST},\ls,\js{y},\V{L}_y) \sepish {}\\
%REDUNDANT                                        \getValue(\V{VALLIST},\V{L}_y\sv\js{y},\LVAL_y) \sepish{}\\
%REDUNDANT                                        \notscope(\V{L1},\ls,\js{x},\V{L}))  \sep{}\\
%REDUNDANT                                                (\V{L},\js{x})\pointsto \LVAL \sep \LVAL\not\doteq\none 
%REDUNDANT                                         \sep\rv\doteq \V{L}_y\sv\js{y}
%REDUNDANT                                \end{array}\right\} \\
%REDUNDANT                                \end{array}
%REDUNDANT                }{
                \infer[cons]{
                        \begin{array}{c}
                        \left\{\begin{array}{l}
                                \scope(\V{LIST},\ls,\js{y},\V{L}_y) \sepish \getValue(\V{VALLIST},\V{L}_y\sv\js{y},\LVAL_y) \sepish{}\\(
                                        \notscope(\V{L1},\ls,\js{x},\V{L})  \sep 
                                        (\V{L},\js{x})\pointsto \LVAL \sep \LVAL\not\doteq\none 
                                ) \\
                        \end{array}\right\} \\
                                \js{y}\\
                        \left\{\begin{array}{ll}
                                \scope(\V{LIST},\ls,\js{y},\V{L}_y)  \sepish \getValue(\V{VALLIST},\V{L}_y\sv\js{y},\LVAL_y)\sepish{}\\(
                                        \notscope(\V{L1},\ls,\js{x},\V{L})  \sep
                                        (\V{L},\js{x})\pointsto \LVAL \sep \LVAL\not\doteq\none 
                                )  \sep\rv\doteq \V{L}_y\sv\js{y}
                        \end{array}\right\} \\
                        \end{array}
                }{
                        \infer[frame]{
                        \begin{array}{c}
                        \left\{\begin{array}{l}
                                (\\
                                        \quad \scope(\V{LIST},\ls,\js{y},\V{L}_y) \sepish \getValue(\V{VALLIST},\V{L}_y\sv\js{y},\LVAL_y)\wand (\\
                                                \qquad \scope(\V{LIST},\ls,\js{y},\V{L}_y) \sepish \getValue(\V{VALLIST},\V{L}_y\sv\js{y},\LVAL_y)\sepish (\\
                                                        \qquad\quad \notscope(\V{L1},\ls,\js{x},\V{L})  \sep {}\\
                                                        \qquad\quad (\V{L},\js{x})\pointsto \LVAL \sep \LVAL\not\doteq\none \\
                                                \qquad) \\
                                        \quad)\\
                                ) \sep \scope(\V{LIST},\ls,\js{y},\V{L}_y)
                        \end{array}\right\} \\
                                \js{y}\\
                        \left\{\begin{array}{ll}
                                (\\
                                        \quad \scope(\V{LIST},\ls,\js{y},\V{L}_y) \sepish \getValue(\V{VALLIST},\V{L}_y\sv\js{y},\LVAL_y)\wand (\\
                                                \qquad \scope(\V{LIST},\ls,\js{y},\V{L}_y) \sepish \getValue(\V{VALLIST},\V{L}_y\sv\js{y},\LVAL_y)\sepish (\\
                                                        \qquad\quad \notscope(\V{L1},\ls,\js{x},\V{L})  \sep {}\\
                                                        \qquad\quad (\V{L},\js{x})\pointsto \LVAL \sep \LVAL\not\doteq\none \\
                                                \qquad) \\
                                        \quad)\\
                                ) \sep \scope(\V{LIST},\ls,\js{y},\V{L}_y)  \sep\rv\doteq \V{L}_y\sv\js{y}
                        \end{array}\right\} \\
                        \end{array}
                        }{
                                \infer[var\ axiom]{
                                        \begin{array}{c}
                                                \{\scope(\V{LIST},\ls,\js{y},\V{L}_y)\sepish \getValue(\V{VALLIST},\V{L}_y\sv\js{y},\LVAL_y)\}\\
                                                \js{y}\\
                                                \{\scope(\V{LIST},\ls,\js{y},\V{L}_y)\sepish \getValue(\V{VALLIST},\V{L}_y\sv\js{y},\LVAL_y)\sep\rv\doteq \V{L}_y\sv\js{y}\}
                                        \end{array}
                                }{}
                        }
                }
%REDUNDANT                }
        }
}
        \end{center}
        \caption{Proof of an assignment of the value of a variable to an existing object-variable}
        \label{fig:assignmentvarproofnew3}
\end{sidewaysfigure*}

\section{Abstraction Layer 2: Proofs for Section~\ref{sec:examples:abstractvarstore}}
\label{sec:varscope}

This layer introduces the \store abstraction and the following rules:

\begin{display}{Writing to a \store}
%
Let $Q_1 = \store_\ls(\LVAR_1\dots \LVAR_n | \js{x}\cons v,\LVAR'_1\cons \LVAL_1 \dots \LVAR'_m\cons \LVAL_m)$.\\
Let $Q_2 = \store_\ls(
                        \LVAR_1\dots \LVAR_n | 
                        \js{x}\cons \LVAL,\js{y}\cons \LVAL,\LVAR'_1\cons \LVAL_1 \dots \LVAR'_m\cons \LVAL_m
$.                \\[\gap] 

% Init with constant
\nohrule
{\js{x}\neq\LVAR_1 \neq \dots \neq \LVAR_n \neq \LVAR'_1 \neq \dots \neq \LVAR'_m \\
 P = \store_\ls(\js{x},\LVAR_1\dots \LVAR_n | \LVAR'_1\cons \LVAL_1 \dots \LVAR'_m\cons \LVAL_m)}
{\tr P {\js{x = v}}{Q_1
                {}\sep \true \sep\rv\doteq v}}
\\[\gap]


%Overwrite/override with constant
\nohrule
{\js{x}\neq\LVAR_1 \neq \dots \neq \LVAR_n \neq \LVAR'_1 \neq \dots \neq \LVAR'_m \\
P = \store_\ls(\LVAR_1\dots \LVAR_n | \js{x}\cons \LVAL,\LVAR'_1\cons \LVAL_1 \dots \LVAR'_m\cons \LVAL_m)}
{\tr{P}{        \js{x = v}}{Q_1
                {}\sep \true \sep\rv\doteq v}}
\\[\gap]


% Init with variable
\nohrule
{       \js{x}\neq\js{y}\neq\LVAR_1 \neq \dots \neq \LVAR_n \neq \LVAR'_1 \neq \dots \neq \LVAR'_m \\
P = \store_\ls(\js{x},\LVAR_1\dots \LVAR_n | \js{y}\cons \LVAL,\LVAR'_1\cons \LVAL_1 \dots \LVAR'_m\cons \LVAL_m)}
{\tr{P}{\js{x = y}}{Q_2{}\sep \true \sep\rv\doteq \LVAL}}
\\[\gap]



% Overwrite/override with variable
\nohrule
{        \js{x}\neq\js{y}\neq\LVAR_1 \neq \dots \neq \LVAR_n \neq \LVAR'_1 \neq \dots \neq \LVAR'_m \\
P = \store_\ls(\LVAR_1\dots \LVAR_n | \js{x}\cons \LVAL',\js{y}\cons \LVAL,\LVAR'_1\cons \LVAL_1 \dots \LVAR'_m\cons \LVAL_m)}
{\tr{P}{\js{x = y}}{Q_2
                {}\sep \true \sep\rv\doteq \LVAL}}
\end{display}
\begin{display}{Writing to a \store from a deeper scope}
%\begin{lemma}[Variable initialisation from a deeper scope]

Let $S =\left(\begin{array}{l} (\V{L},\protop)\pointsto \nil \sep (\V{L},\js{x})\pointsto\none\\ 
                        {} \sep (\V{L},\js{y})\pointsto\LVAL' \sep
                        \ls\doteq \V{L}:\V{LS}\end{array}\right)$.\\
Let $Q = \store_\V{LS}\left(
                        \begin{array}{l}
                                \LVAR_1,\dots,\LVAR_n | 
                                \js{x}:\LVAL',\LVAR'_1:\LVAL'_1,\dots,\LVAR'_m:\LVAL'_m
                        \end{array}\right)$. \\[\gap]

\nohrule
{\js{x}\neq\js{y}\neq\LVAR_1 \neq \dots \neq \LVAR_n \neq \LVAR'_1 \neq \dots \neq \LVAR'_m\\
P_1 = \store_\V{LS}\left(\begin{array}{l}
                                \js{x},\LVAR_1,\dots,\LVAR_n |
                                \LVAR'_1:\LVAL'_1,\dots,\LVAR'_m:\LVAL'_m
                        \end{array}\right)}
{\tr {P_1\sep S}{\js{x=y}}{Q\sep S\sep \true}}
\\[\gap]


\nohrule
{\js{x}\neq\js{y}\neq\LVAR_1 \neq \dots \neq \LVAR_n \neq \LVAR'_1 \neq \dots \neq \LVAR'_m\\
P_2 = \store_\V{LS}\left(\begin{array}{l}
                                \LVAR_1,\dots,\LVAR_n |
                                \js{x}:\LVAL,\LVAR'_1:\LVAL'_1,\dots,\LVAR'_m:\LVAL'_m
                        \end{array}\right)}
{\tr {P_2\sep S}{\js{x=y}}{Q\sep S\sep \true}}
%
\end{display}
\begin{display}{Destructive \store Initialisation}
%
\nohrule
{\js{x}\neq\LVAR_1 \neq \dots \neq \LVAR_n \neq \LVAR'_1 \neq \dots \neq \LVAR'_m \\
R= \store_\ls(\js{x},\LVAR_1\dots \LVAR_n | \LVAR'_1\cons \LVAL_1 \dots \LVAR'_m\cons \LVAL_m)\\
 \tr {R\sep P}{\js{e}}{R\sepish \getValue(\E{LS},\LVAL'\LVAL)\sep Q \sep\rv\doteq \LVAL'
                }\qquad \rv\not\in\fv(Q)\\[\gap]        
S =         
        \left(\begin{array}{l}
                \store_\ls\left(\begin{array}{l}
                        \LVAR_1\dots \LVAR_n | 
                        \js{x}\cons \LVAL,\LVAR'_1\cons \LVAL_1 \dots \LVAR'_m\cons \LVAL_m
                \end{array}\right) \\
                {}\sepish \getValue(\E{LS},\LVAL'\LVAL) \sep Q \sep \true \sep\rv\doteq \LVAL
        \end{array}\right)
}{
\tr{R\sep P}{\js{x = e}}{S}}
\\[\gap]


\nohrule
{\js{x}\neq\LVAR_1 \neq \dots \neq \LVAR_n \neq \LVAR'_1 \neq \dots \neq \LVAR'_m \\
 R = \store_{\E{L}\cons \E{SLS}}(\js{x},\LVAR_1\dots \LVAR_n | \LVAR'_1\cons \LVAL_1 \dots \LVAR'_m\cons \LVAL_m)\sepish {} \notscope(\E{Nsls},\ls,\js{x},\E{L})\\
 \tr{R
                }{
                \js{e}}{R\sepish
                        \getValue(\E{LS},\LVAL',\LVAL)\sep Q \sep\rv\doteq \LVAL'
                }\qquad
        \rv\not\in\fv(Q)\\[\gap]
        S = \left(\begin{array}{l}
                \store_{\E{L}\cons \E{SLS}}\left(\begin{array}{l}
                        \LVAR_1\dots \LVAR_n | 
                        \js{x}\cons \LVAL,\LVAR'_1\cons \LVAL_1 \dots \LVAR'_m\cons \LVAL_m
                \end{array}\right) \sepish {}\\
                \notscope(\E{Nsls},\ls,\js{x},\E{L}) \sepish 
                \getValue(\E{LS},\LVAL',\LVAL) \sep Q \sep \true \sep\rv\doteq \LVAL
        \end{array}\right)
}
{\tr{R \sep P}{\js{x = e}}{S}}
\end{display}

The proofs of these rules are all similar, since they all follow the
same pattern. We give the first in full in
Figures~\ref{fig:storeinitconstnew1},~\ref{fig:storeinitconstnew2}
and~\ref{fig:storeinitconstnew3}.

\begin{figure*}
        \scriptsize
        \begin{center}
        \[\begin{array}{ll}
        \{\store_\ls(\js{x},\LVAR_1\dots \LVAR_n | \LVAR'_1:\LVAL_1 \dots \LVAR'_m:\LVAL_m)\}\\\\
        \left\{\begin{array}{l}
                \exists \V{LS},\V{LS}_1\,\dots,\V{LS}_n,\V{LS}'_1,\dots,\V{LS}'_m  \st\\
                \thischain(\ls)\sepish{}\\
                \notscope(\V{LS},\ls,\js{x},\nil) \sepish {}\\
                \notscope(\V{LS}_1,\ls,\LVAR_1,\nil) \sepish {}\\
                \vdots\\
                \notscope(\V{LS}_n,\ls,\LVAR_n,\nil) \sepish {}\\
                \scope(\V{LS}'_1,\ls,\LVAR'_1,\ls_1) \sepish {}\\
                \vdots\\
                \scope(\V{LS}'_m,\ls,\LVAR'_m,\ls_m) \sep {}\\
                (\ls_1,\LVAR'_1) \pointsto \LVAL_1 \sep {}\\
                \vdots\\
                (\ls_m,\LVAR'_m) \pointsto \LVAL_m
        \end{array}\right\} & \text{(cons)}\\\\
        \left\{\begin{array}{l}
                \exists \V{LS}_1\,\dots,\V{LS}_n,\V{LS}'_1,\dots,\V{LS}'_m  \st\\
                \thischain(\ls)\sepish{}\\
                \notscope(\V{LS},\ls,\js{x},\nil) \sepish {}\\
                \notscope(\V{LS}_1,\ls,\LVAR_1,\nil) \sepish {}\\
                \vdots\\
                \notscope(\V{LS}_n,\ls,\LVAR_n,\nil) \sepish {}\\
                \scope(\V{LS}'_1,\ls,\LVAR'_1,\ls_1) \sepish {}\\
                \vdots\\
                \scope(\V{LS}'_m,\ls,\LVAR'_m,\ls_m) \sep {}\\
                (\ls_1,\LVAR'_1) \pointsto \LVAL_1 \sep {}\\
                \vdots\\
                (\ls_m,\LVAR'_m) \pointsto \LVAL_m
        \end{array}\right\} & \text{(var elim)}\\\\
        \left\{\begin{array}{l}
                \exists\V{L1},\V{L2},\V{L3}\st\V{LS}\doteq\V{L1}++((\lgo:\V{L2}):\V{L3}) \sep {}\\
                \notscope(\V{L1}++((\lgo:\V{L2}):\V{L3}),\ls,\js{x},\nil) \sep {}\\
                (\notscope(\V{L1}++((\lgo:\V{L2}):\V{L3}),\ls,\js{x},\nil) \wand {}\\
                \quad(\exists \V{LS}_1\,\dots,\V{LS}_n,\V{LS}'_1,\dots,\V{LS}'_m  \st\\
                \quad \thischain(\ls)\sepish{}\\
                \quad\notscope(\V{LS},\ls,\js{x},\nil) \sepish {}\\
                \quad\notscope(\V{LS}_1,\ls,\LVAR_1,\nil) \sepish {}\\
                \quad\vdots\\
                \quad\notscope(\V{LS}_n,\ls,\LVAR_n,\nil) \sepish {}\\
                \quad\scope(\V{LS}'_1,\ls,\LVAR'_1,\ls_1) \sepish {}\\
                \quad\vdots\\
                \quad\scope(\V{LS}'_m,\ls,\LVAR'_m,\ls_m) \sep {}\\
                \quad(\ls_1,\LVAR'_1) \pointsto \LVAL_1 \sep {}\\
                \quad\vdots\\
                \quad(\ls_m,\LVAR'_m) \pointsto \LVAL_m)) 
        \end{array}\right\} & \text{(cons (since $\lgo$ is in $\ls$))}\\\\
        \left\{\begin{array}{l}
                \notscope(\V{L1}++((\lgo:\V{L2}):\V{L3}),\ls,\js{x},\nil) \\
        \end{array}\right\} & \text{(frame/elim)}\\\\
        \left\{\begin{array}{l}
                \scope(\V{L1}++((\lgo:\V{L2}):\V{L3}),\ls,\js{x},\nil) \\
        \end{array}\right\} & \text{(cons )}\\
        \js{x = v}\\
        \left\{\begin{array}{l}
                \exists\V{L1}',\V{L3}',\V{SCOPE}',\V{GP}\st\\
                \notscopeg(\V{L1},\ls,\js{x},\lgo) \sepish \proto(\V{L2},\V{GP},\js{x},\nil) \sepish {}\\
                \notscopeg(\V{L3}',\V{SCOPE}',\js{x},\nil) \sep {}\\
                (\lgo,\js{x})\pointsto\js{v}\sep \ls \doteq \_++(\lgo:\V{SCOPE}') \sep{}\\
                (\lgo,\protop)\pointsto\V{GP} \sep\rv\doteq \js{v}
        \end{array}\right\} & \\\\
        \end{array}\]
        \end{center}
        \caption{Proof of \store initialisation with a constant (part 1 of 3).}
        \label{fig:storeinitconstnew1}
\end{figure*}
\begin{figure*}
        \scriptsize
        \begin{center}
        \[\begin{array}{ll}
        \left\{\begin{array}{l}
                \exists\V{L1}',\V{L3}',\V{SCOPE}',\V{GP}\st
                \notscopeg(\V{L1},\ls,\js{x},\lgo) \sepish \proto(\V{L2},\V{GP},\js{x},\nil) \sepish {}\\
                \notscopeg(\V{L3}',\V{SCOPE}',\js{x},\nil) \sep {}
                (\lgo,\js{x})\pointsto\js{v}\sep \ls \doteq \_++(\lgo:\V{SCOPE}') \sep{}\\
                (\lgo,\protop)\pointsto\V{GP} \sep\rv\doteq \js{v}
        \end{array}\right\} & \\\\
        % \left\{\begin{array}{l}
        %         \notscopeg(\V{L1},\ls,\js{x},\lgo) \sep \proto(\V{L2},\V{GP},\js{x},\nil) \sep {}\\
        %         \notscopeg(\V{L3},\V{PR},\js{x},\nil) \sep{}\\
        %         (\lgo,\js{x})\pointsto\js{v}\sep(\lgo,\scopep)\pointsto\V{PR}\sep(\lgo,\text{@proto})\pointsto\V{GP} \sep\rv\doteq \js{v}
        % \end{array}\right\} & \\\\
        \left\{\begin{array}{l}
                \exists\V{L1},\V{L2},\V{L3},\V{L1}',\V{L3}',\V{SCOPE}',\V{GP}\st
                \V{LS}\doteq\V{L1}++((\lgo:\V{L2}):\V{L3}) \sep {}\\
                \notscopeg(\V{L1},\ls,\js{x},\lgo) \sepish \proto(\V{L2},\V{GP},\js{x},\nil) \sepish {}
                \notscopeg(\V{L3}',\V{SCOPE}',\js{x},\nil) \sep {}\\
                (\lgo,\js{x})\pointsto\js{v}\sep \ls \doteq \_++(\lgo:\V{SCOPE}') \sep{}
                (\lgo,\protop)\pointsto\V{GP} \sep\rv\doteq \js{v}\\
                % \notscopeg(\V{L1},\ls,\js{x},\lgo) \sep \proto(\V{L2},\V{GP},\js{x},\nil) \sep {}\\
                % \notscopeg(\V{L3},\V{PR},\js{x},\nil) \sep{}\\
                % (\lgo,\js{x})\pointsto\js{v}\sep(\lgo,\scopep)\pointsto\V{PR}\sep(\lgo,\protop)\pointsto\V{GP} \sep {}\\
                (\notscope(\V{L1}++((\lgo:\V{L2}):[]),\ls,\js{x},\nil) \wand {}\\
                \quad(\exists \V{LS}_1\,\dots,\V{LS}_n,\V{LS}'_1,\dots,\V{LS}'_m  \st\\
                \quad \thischain(\ls)\sepish{}\\
                \quad\notscope(\V{LS},\ls,\js{x},\nil) \sepish {}\\
                \quad\notscope(\V{LS}_1,\ls,\LVAR_1,\nil) \sepish {}\\
                \quad\vdots\\
                \quad\notscope(\V{LS}_n,\ls,\LVAR_n,\nil) \sepish {}\\
                \quad\scope(\V{LS}'_1,\ls,\LVAR'_1,\ls_1) \sepish {}\\
                \quad\vdots\\
                \quad\scope(\V{LS}'_m,\ls,\LVAR'_m,\ls_m) \sep {}\\
                \quad(\ls_1,\LVAR'_1) \pointsto \LVAL_1 \sep {}\\
                \quad\vdots\\
                \quad(\ls_m,\LVAR'_m) \pointsto \LVAL_m)) \sep {}\\
        \end{array}\right\} & \text{(frame)}\\\\
        \left\{\begin{array}{l}
                \exists\V{L1},\V{L2},\V{L3},\V{L1}',\V{L3}',\V{SCOPE}',\V{GP}\st
                \V{LS}\doteq\V{L1}++((\lgo:\V{L2}):\V{L3}) \sep {}\\
                \notscopeg(\V{L1},\ls,\js{x},\lgo) \sepish \proto(\V{L2},\V{GP},\js{x},\nil) \sepish {}\\
                \notscopeg(\V{L3}',\V{SCOPE}',\js{x},\nil) \sep {}\\
                (\lgo,\js{x})\pointsto\js{v}\sep \ls \doteq \_++(\lgo:\V{SCOPE}') \sep{}\\
                (\lgo,\protop)\pointsto\V{GP} \sep{}\\
                % \notscopeg(\V{L1},\ls,\js{x},\lgo) \sep \proto(\V{L2},\V{GP},\js{x},\nil) \sep {}\\
                % \notscopeg(\V{L3},\V{PR},\js{x},\nil) \sep{}\\
                % (\lgo,\js{x})\pointsto\js{v}\sep(\lgo,\scopep)\pointsto\V{PR}\sep(\lgo,\protop)\pointsto\V{GP} \sep {}\\
                (\notscopeg(\V{L1},\ls,\js{x},\lgo) \sep \proto(\V{L2},\V{GP},\js{x},\nil) \sep {}\\
                (\lgo,\js{x})\pointsto\none\sep(\lgo,\scopep)\pointsto\nil\sep(\lgo,\protop)\pointsto\V{GP} \wand {}\\
                \quad \exists \V{LS}_1\,\dots,\V{LS}_n,\V{LS}'_1,\dots,\V{LS}'_m  \st\\
                \quad\thischain(\ls)\sepish{}\\
                \quad\left(\begin{array}{l}
                     (\notscopeg(\V{L1},\ls,\js{x},\lgo) \sepish \proto(\V{L2},\V{GP},\js{x},\nil) \sepish {}\\
                     \notscopeg(\V{L3}',\V{SCOPE},\js{x},\nil) \sep{}\\
                     (\lgo,\js{x})\pointsto\none\sep \ls \doteq \_++(\lgo:\V{SCOPE}')\sep{}\\
                     (\lgo,\protop)\pointsto\V{GP}) \end{array}\right) \sepish {}\\
                \quad\notscope(\V{LS}_1,\ls,\LVAR_1,\nil\sepish {}\\
                \quad\vdots\\
                \quad\notscope(\V{LS}_n,\ls,\LVAR_n,\nil) \sepish {}\\
                \quad\scope(\V{LS}'_1,\ls,\LVAR'_1,\ls_1) \sepish {}\\
                \quad\vdots\\
                \quad\scope(\V{LS}'_m,\ls,\LVAR'_m,\ls_m) \sep {}\\
                \quad(\ls_1,\LVAR'_1) \pointsto \LVAL_1 \sep {}\\
                \quad\vdots\\
                \quad(\ls_m,\LVAR'_m) \pointsto \LVAL_m))\sep\rv\doteq \js{v}
        \end{array}\right\} & \text{(cons)}\\\\
        \end{array}\]
        \end{center}
        \caption{Proof of \store initialisation with a constant (part 2 of 3).}
        \label{fig:storeinitconstnew2}
\end{figure*}
\begin{figure*}
        \scriptsize
        \begin{center}
        \[\begin{array}{ll}
        \left\{\begin{array}{l}
                \exists\V{L1},\V{L2},\V{L3},\V{L1}',\V{L3}',\V{SCOPE}',\V{GP}\st
                \V{LS}\doteq\V{L1}++((\lgo:\V{L2}):\V{L3}) \sep {}\\
                \notscopeg(\V{L1},\ls,\js{x},\lgo) \sepish \proto(\V{L2},\V{GP},\js{x},\nil) \sepish {}\\
                \notscopeg(\V{L3}',\V{SCOPE}',\js{x},\nil) \sep {}\\
                (\lgo,\js{x})\pointsto\js{v}\sep \ls \doteq \_++(\lgo:\V{SCOPE}') \sep{}\\
                (\lgo,\protop)\pointsto\V{GP} \sep{}\\
                % \notscopeg(\V{L1},\ls,\js{x},\lgo) \sep \proto(\V{L2},\V{GP},\js{x},\nil) \sep {}\\
                % \notscopeg(\V{L3},\V{PR},\js{x},\nil) \sep{}\\
                % (\lgo,\js{x})\pointsto\js{v}\sep(\lgo,\scopep)\pointsto\V{PR}\sep(\lgo,\protop)\pointsto\V{GP} \sep {}\\
                (\notscopeg(\V{L1},\ls,\js{x},\lgo) \sep \proto(\V{L2},\V{GP},\js{x},\nil) \sep {}\\
                (\lgo,\js{x})\pointsto\none\sep(\lgo,\scopep)\pointsto\nil\sep(\lgo,\protop)\pointsto\V{GP} \wand {}\\
                \quad \exists \V{LS}_1\,\dots,\V{LS}_n,\V{LS}'_1,\dots,\V{LS}'_m  \st\\
                \quad\thischain(\ls)\sepish{}\\
                \quad\left(\begin{array}{l}
                     (\notscopeg(\V{L1},\ls,\js{x},\lgo) \sepish \proto(\V{L2},\V{GP},\js{x},\nil) \sepish {}\\
                     \notscopeg(\V{L3}',\V{SCOPE},\js{x},\nil) \sep{}\\
                     (\lgo,\js{x})\pointsto\none\sep \ls \doteq \_++(\lgo:\V{SCOPE}')\sep{}\\
                     (\lgo,\protop)\pointsto\V{GP}) \end{array}\right) \sepish {}\\
                \quad\notscope(\V{LS}_1,\ls,\LVAR_1,\nil\sepish {}\\
                \quad\vdots\\
                \quad\notscope(\V{LS}_n,\ls,\LVAR_n,\nil) \sepish {}\\
                \quad\scope(\V{LS}'_1,\ls,\LVAR'_1,\ls_1) \sepish {}\\
                \quad\vdots\\
                \quad\scope(\V{LS}'_m,\ls,\LVAR'_m,\ls_m) \sep {}\\
                \quad(\ls_1,\LVAR'_1) \pointsto \LVAL_1 \sep {}\\
                \quad\vdots\\
                \quad(\ls_m,\LVAR'_m) \pointsto \LVAL_m))\sep\rv\doteq \js{v}
        \end{array}\right\} & \text{(cons)}\\\\
        \left\{\begin{array}{l}
                \exists \V{L1},\V{L2},\V{L3},\V{LS}_1\,\dots,\V{LS}_n,\V{LS}'_1,\dots,\V{LS}'_m  \st
                \thischain(\ls)\sepish{}\\
                \left(\begin{array}{l}\notscopeg(\V{L1},\ls,\js{x},\lgo) \sepish \proto(\V{L2},\V{GP},\js{x},\nil) \sepish {}\\
                \notscopeg(\V{L3},\V{SCOPE},\js{x},\nil) \sep{}\\
                (\lgo,\js{x})\pointsto\js{v}\sep\ls\doteq \_++(\lgo:\V{SCOPE}')\sep{}\\
                (\lgo,\protop)\pointsto\V{GP}\end{array}\right) \sepish {}\\
                \notscope(\V{LS}_1,\ls,\LVAR_1,\nil) \sepish {}\\
                \vdots\\
                \notscope(\V{LS}_n,\ls,\LVAR_n,\nil) \sepish {}\\
                \scope(\V{LS}'_1,\ls,\LVAR'_1,\ls_1) \sepish {}\\
                \vdots\\
                \scope(\V{LS}'_m,\ls,\LVAR'_m,\ls_m) \sep {}\\
                (\ls_1,\LVAR'_1) \pointsto \LVAL_1 \sep {}\\
                \vdots\\
                (\ls_m,\LVAR'_m) \pointsto \LVAL_m) \js{v}
        \end{array}\right\} & \text{(cons (using inequality of $\LVAR$s))}\\\\
        \{\store_\ls(\LVAR_1\dots \LVAR_n | \js{x}:\js{v}, \LVAR'_1:\LVAL_1 \dots \LVAR'_m:\LVAL_m) \sep \true \sep\rv\doteq v\} 
        &\text{(cons)}\\\\
        \end{array}\]
        \end{center}
        \caption{Proof of \store initialisation with a constant (part 3 of 3)}
        \label{fig:storeinitconstnew3}
\end{figure*}

\subsection{The Variable Scope Example}
\label{sec:varscopeproof}

Consider the program:
\begin{verbatim}
x = null; y = null; z = null;
f = function(w){x=v;v=4;var v;y=v;};
v = 5; f(null); z = v;
\end{verbatim}

The proof of this program is given in Figure~\ref{fig:varscope2}, and makes use of a proof of the function body in Figure~\ref{fig:functionbody}.
\begin{figure}
        \scriptsize
\begin{center}
        \[\begin{array}{l}
                \left\{\begin{array}{l}
                        \store_\ls(\js{x},\js{y},\js{z},\js{f},\js{v}|) 
                \end{array}\right\}\\
                \js{x = }\nil\js{;} \ifshort{\js{y = }\nil\js{;} \js{z = }\nil\js{;}}\\
                \iflong{\left\{\begin{array}{l}
                        \store_\ls(\js{y},\js{z},\js{f},\js{v}|\js{x}:\nil)  \sep \true
                \end{array}\right\}\\
        \js{y = }\nil\js{;}\\
                \left\{\begin{array}{l}
                        \store_\ls(\js{z},\js{f},\js{v}|\js{x}:\nil,\js{y}:\nil)  \sep\true
                \end{array}\right\}\\
                \js{z = }\nil\js{;}\\}
                \left\{\begin{array}{l}
                        \store_\ls(\js{f},\js{v}|\js{x}:\nil,\js{y}:\nil,\js{z}:\nil) \sep\true
                \end{array}\right\}\\
        \js{f = function(w)\{x=v ; v=4 ; var v ; y=v\};}\\
                \left\{\begin{array}{l}
                        \exists\V{L}\st
                        \store_\ls(\js{v}|\js{x}:\nil,\js{y}:\nil,\js{z}:\nil,\js{f}:\V{L}) \sep {}\\
                        (\V{L},\bodyp)\pointsto \lambda \js{w}.\{\dots\}\sep{}\\
                        (\V{L},\fscopep)\pointsto \V{LS} \sep \true
                \end{array}\right\}\\
        \js{v = 5;}\\
                \left\{\begin{array}{l}
                        %\exists\V{L}\st
                        \store_\ls(|\js{x}:\nil,\js{y}:\nil,\js{z}:\nil,\js{f}:\V{L},\js{v}:5) \sep {}\\
                        (\V{L},\bodyp)\pointsto \lambda w.\{\dots\}\sep{}\\
                        (\V{L},\fscopep)\pointsto \V{LS}  \sep\true
                \end{array}\right\}\\
        \js{f(}\nil\js{);}\\
                \left\{\begin{array}{l}
                        \exists %\V{L}, 
                        \V{L}' \st 
                        \store_\ls(|\js{x}:\und,\js{y}:4,\js{z}:\nil,\js{f}:\V{L},\js{v}:5)\sep{}\\
                        %(\lop,\js{x})\pointsto\none \sepish(\lop,\js{y})\pointsto\none\sep{}\\
                        \newobj(\V{L}',\protop,\js{w},\js{v})\sep (\V{L}',\protop)\pointsto \nil \sep{}\\
                        (\V{L}',\js{w})\pointsto\nil \sep (\V{L}',\js{v})\pointsto 4\sep\true\\
                \end{array}\right\}% \qquad [\text{from Figure~\ref{fig:functionbody}}]
                \\\text{[Frame]}\\
                \left\{\begin{array}{l}
                        %\exists\V{L}\st
                        \store_\ls(|\js{x}:\und,\js{y}:4,\js{z}:\nil,\js{f}:\V{L},\js{v}:5)\\
                \end{array}\right\} %\; \text{\scriptsize[Var-Elim/Frame]}
                \\
        \js{z = v;}\\
                \left\{\begin{array}{l}
                        %\exists\V{L}\st
                        \store_\ls(|\js{x}:\und,\js{y}:4,\js{z}:5,\js{f}:\V{L},\js{v}:5)\sep\true\\
                \end{array}\right\} \\\text{[Frame]}\\
                \left\{\begin{array}{l}
                        %\exists\V{L}, \V{L}' \st (
                        \store_\ls(|\js{x}:\und,\js{y}:4,\js{z}:5,\js{f}:\V{L},\js{v}:5)\sep{}\\
                        %(\lop,\js{x})\pointsto\none \sepish(\lop,\js{y})\pointsto\none\sep{}\\
                        \newobj(\V{L}',\protop,\js{w},\js{v})\sep (\V{L}',\protop)\pointsto \nil \sep{}\\
                        (\V{L}',\js{w})\pointsto\nil \sep (\V{L}',\js{v})\pointsto 4\sep\true\\
                \end{array}\right\} %\qquad [Var-Elim/Frame]
                \\\text{[Cons/Var Elim]}\\
                \left\{\begin{array}{l}
                        \exists\V{L}\st
                        \store_\ls(|\js{x}:\und,\js{y}:4,\js{z}:5,\js{f}:\V{L},\js{v}:5)\sep\true\\
                \end{array}\right\} 
        \end{array}\]
\end{center}
\caption{A Proof of the Variable Scopes Program}
\label{fig:varscope2}
\end{figure}
\begin{figure}
        \scriptsize
        \begin{center}
                \[\begin{array}{ll}
                \left\{\begin{array}{l}
                        \exists\V{L}',\V{LS}\st \ls\doteq\V{L}':\V{LS} \sep {}\\
                        \store_\V{LS}(|\js{x}:\nil,\js{y}:\nil,\js{z}:\nil,\js{f}:\V{L},\js{v}:5) \sep {}\\
                        (\V{L},\bodyp)\pointsto \lambda w.\{\dots\}\sep{}\\
                        (\V{L},\fscopep)\pointsto \V{LS}  \sep {} \\
                        \newobj(\V{L}',\protop,\js{w},\js{v},\thisp)\sep{}\\ 
                        (\V{L}',\protop)\pointsto \nil \sep{}\\
                        (\V{L}',\js{w})\pointsto\nil \sep (\V{L}',\js{v})\pointsto\und\sep (\V{L}',\thisp)\pointsto\_\sep\true
                \end{array}\right\}\\
                \iflong{\text{[ Frame/Cons ]}\\
                \left\{\begin{array}{l}
                        %\exists\V{L}',\V{LS}\st 
                        \ls\doteq\V{L}':\V{LS} \sep {}\\
                        \store_\V{LS}(|\js{x}:\nil,\js{y}:\nil,\js{z}:\nil,\js{f}:\V{L},\js{v}:5) \sep {}\\
                        (\V{L}',\protop)\pointsto \nil \sep (\V{L}',\js{x})\pointsto\none\sep{}\\
                        (\V{L}',\js{v})\pointsto\und \\
                \end{array}\right\} \\%& 
                \js{x=v;}\\
                \left\{\begin{array}{l}
                        %\exists\V{L}',\V{LS}\st 
                        \ls\doteq\V{L}':\V{LS} \sep {}\\
                        \store_\V{LS}(|\js{x}:\und,\js{y}:\nil,\js{z}:\nil,\js{f}:\V{L},\js{v}:5) \sep {}\\
                        (\V{L}',\protop)\pointsto \nil \sep (\V{L}',\js{x})\pointsto\none\sep{}\\
                        (\V{L}',\js{v})\pointsto\und \sep \true \\
                \end{array}\right\} \\%& \text{[ Lemma~\ref{lemma:storeoverwritedeepscope}]}\\\\
                \text{[Frame/Cons]}\\
                \left\{\begin{array}{l}
                        %\exists\V{L}',\V{LS}\st 
                        \ls\doteq\V{L}':\V{LS} \sep {}\\
                        \store_\V{LS}(|\js{x}:\und,\js{y}:\nil,\js{z}:\nil,\js{f}:\V{L},\js{v}:5)\sep{}\\
                        %(\lop,\js{x})\pointsto\none \sepish(\lop,\js{y})\pointsto\none\sep{}\\
                        \newobj(\V{L}',\protop,\js{w},\js{v},\thisp)\sep (\V{L}',\protop)\pointsto \nil \sep{}\\
                        (\V{L}',\js{w})\pointsto\nil \sep (\V{L}',\js{v})\pointsto\und\sep\true\\
                \end{array}\right\}\\%& 
                \text{[Frame]}\\
                \left\{\begin{array}{l}
                        %\exists\V{L}',\V{LS}\st 
                        \ls\doteq\V{L}':\V{LS} \sep {}\\
                        (\V{L}',\js{v})\pointsto\und\\
                \end{array}\right\}\\%& 
                \js{v=4;}\\
                \left\{\begin{array}{l}
                        \exists\V{L}',\V{LS}\st 
                        \ls\doteq\V{L}':\V{LS} \sep {}\\
                        (\V{L}',\js{v})\pointsto 4\\
                \end{array}\right\}\\%& \text{[ Assignment/Cons ]}\\
                \js{var v;}\\
                \left\{\begin{array}{l}
                        %\exists\V{L}',\V{LS}\st 
                        \ls\doteq\V{L}':\V{LS} \sep {}\\
                        (\V{L}',\js{v})\pointsto 4\\
                \end{array}\right\}\\%& \text{[ Variable/Cons ]}\\\\
                \text{[Frame]}\\
                \left\{\begin{array}{l}
                        %\exists\V{L}',\V{LS}\st 
                        \ls\doteq\V{L}':\V{LS} \sep {}\\
                        \store_\V{LS}(|\js{x}:\und,\js{y}:\nil,\js{z}:\nil,\js{f}:\V{L},\js{v}:5)\sep{}\\
                        %(\lop,\js{x})\pointsto\none \sepish(\lop,\js{y})\pointsto\none\sep{}\\
                        \newobj(\V{L}',\protop,\js{w},\js{v},\thisp)\sep (\V{L}',\protop)\pointsto \nil \sep{}\\
                        (\V{L}',\js{w})\pointsto\nil \sep (\V{L}',\js{v})\pointsto 4\sep\true\\
                \end{array}\right\}\\%& 
                \text{[Frame/Cons]}\\
                \left\{\begin{array}{l}
                        %\exists\V{L}',\V{LS}\st 
                        \ls\doteq\V{L}':\V{LS} \sep {}\\
                        \store_\V{LS}(|\js{x}:\und,\js{y}:\nil,\js{z}:\nil,\js{f}:\V{L},\js{v}:5)\sep{}\\
                        %(\lop,\js{x})\pointsto\none \sepish(\lop,\js{y})\pointsto\none\sep{}\\
                        (\V{L}',\protop)\pointsto \nil \sep(\V{L}',\js{y})\pointsto\none \sep{}\\
                        (\V{L}',\js{v})\pointsto 4\sep\\
                \end{array}\right\}\\%& 
                \js{y=v}\\
                \left\{\begin{array}{l}
                        %\exists\V{L}',\V{LS}\st 
                        \ls\doteq\V{L}':\V{LS} \sep {}\\
                        \store_\V{LS}(|\js{x}:\und,\js{y}:4,\js{z}:\nil,\js{f}:\V{L},\js{v}:5)\sep{}\\
                        %(\lop,\js{x})\pointsto\none \sepish(\lop,\js{y})\pointsto\none\sep{}\\
                        (\V{L}',\protop)\pointsto \nil \sep(\V{L}',\js{y})\pointsto\none \sep{}\\
                        (\V{L}',\js{v})\pointsto 4\sep\true\\
                \end{array}\right\}\\%& \text{[Lemma~\ref{lemma:storeoverwritedeepscope}]} \\\\
                \text{[Frame/Cons]}\\}\ifshort{\js{x=v;v=4;var v;y=v;}\\}
                \left\{\begin{array}{l}
                        \exists\V{L}',\V{LS}\st \ls\doteq\V{L}':\V{LS} \sep {}\\
                        \store_\V{LS}(|\js{x}:\und,\js{y}:4,\js{z}:\nil,\js{f}:\V{L},\js{v}:5)\sep{}\\
                        %(\lop,\js{x})\pointsto\none \sepish(\lop,\js{y})\pointsto\none\sep{}\\
                        \newobj(\V{L}',\protop,\js{w},\js{v},\thisp)\sep (\V{L}',\protop)\pointsto \nil \sep{}\\
                        (\V{L}',\js{w})\pointsto\nil \sep (\V{L}',\js{v})\pointsto 4\sep\true\\
                \end{array}\right\}\\%& 
                \end{array}\]
        \end{center}
        \caption{Proof of the Scope Example Function Body}
        \label{fig:functionbody}
\end{figure}

\section{Abstraction Layer 3: Proofs for Section~\ref{sec:examples:recstore}}
\begin{lemma}[Recursive Store Commutativity]
        The order of the variables in each scope-frame does not matter.
        \begin{proof}
                The proof follows directly from the definition of the predicate, the definition of the list inclusion operator $\elem$, and the commutativity of $\sep$.
        \end{proof}
\end{lemma}


\begin{lemma}[Recursive Store Variable Initialisation (with a constant)]
        Assigning a value to an unused variable creates a new global variable.
        \[\begin{array}{c}
                \{ \recstore_{\ls}((\js{x}:\E{EmpVars}) , (\E{Locals}{\append}[\E{Globals}])) \} \\
                \js{x = v}\\
                \{ \recstore_{\ls}((\E{EmpVars}) , (\E{Locals}{\append}[\js{x}=\js{v}:\E{Globals}])) \sep \true \} \\
        \end{array}\]
        \begin{proof}
                The proof follows directly from the definition of $\recstore$ and the rules for \store.
        \end{proof}
\end{lemma}

\begin{lemma}[Recursive Store Variable Update (with a constant)]
        Assigning a value to a used variable overwrites it, at the same scope-level.
        \[\frac{
        \forall \V{LS} \elem \E{Locs} \st (\js{x}=\_)\not\elem\V{LS}
        }{\begin{array}{c}
                \{ \recstore_{\ls}((\E{Emps}) , (\E{Locs}{\append}((\js{x}=\E{Var}):\E{Curr}){\append}\E{Globs})) \} \\
                \js{x = v}\\
                \{ \recstore_{\ls}((\E{Emps}) , (\E{Locs}{\append}((\js{x}=v):\E{Curr}){\append}\E{Globs})) \sep \true \} \\
        \end{array}}\]
        \begin{proof}
                The proof has two cases. In the case where $\js{x}$ is in the global scope, the proof follows from the rules for \store.
                In the case where $\js{x}$ is in a local or intermediate scope, the proof follows directly from the definition of $\recstore$ and the inference rule for assignment.
        \end{proof}
\end{lemma}

\begin{lemma}[Destructive Variable Initialisation]
        \label{lem:recstore:destricvarinit}
        \[\frac{
        \begin{array}{l}
                \begin{array}{c} 
                        \{\recstore_{\ls}((\js{x}:\E{EmpVars}) , (\E{Locals}{\append}[\E{Globals}])) \sep P \}\\
                        \js{e}\\
                        \{ \recstore_{\ls}((\js{x}:\E{EmpVars}) , (\E{Locals}{\append}[\E{Globals}])) \sep Q \sep \rv\doteq\E{Var} \} \\
                \end{array}\\
                \\
                \rv\not\in\fv(Q)
        \end{array}
        }{\begin{array}{c}
                \{ \recstore_{\ls}((\js{x}:\E{EmpVars}) , (\E{Locals}{\append}[\E{Globals}])) \sep P \} \\
                \js{x = e}\\
                \{ \recstore_{\ls}((\E{EmpVars}) , (\E{Locals}{\append}[\js{x}=\E{Var}:\E{Globals}])) \sep Q \sep \true \} \\
        \end{array}
        }\]
        \begin{proof} The proof follows directly from the assignment rules, the definition of \recstore and the rules for \store.\end{proof}
\end{lemma}
\begin{lemma}[Destructive Variable Update]
        \label{lem:recstore:destricvarupdate}
        \[\frac{
        \begin{array}{l}
                \begin{array}{c} 
                        \left\{\begin{array}{l}
                                \recstore_{\ls}((\E{Emps}) , (\E{Locs}{\append}((\js{x}=\E{Var}):\E{Curr}){\append}\E{Globs})) \\
                                {} \sep \E{Globs}\not\doteq{\emptylist} \sep P 
                        \end{array}\right\}\\
                        \js{e}\\
                        \left\{\begin{array}{l}
                                \recstore_{\ls}((\E{Emps}) , (\E{Locs}{\append}((\js{x}=\E{Var}):\E{Curr}){\append}\E{Globs})) \\
                                {}  \sep \E{Globs}\not\doteq{\emptylist}\sep Q \sep \rv\doteq\E{Var}'
                        \end{array}\right\}\\
                \end{array}\\
                \\
                \rv\not\in\fv(Q)\\
                \forall \V{LS}\in\E{Locs} \st (\js{x}=\_)\not\in\V{LS}
        \end{array}
        }{
        \begin{array}{c} 
               \left\{\begin{array}{l} 
                       \recstore_{\ls}((\E{Emps}) , (\E{Locs}{\append}((\js{x}=\E{Var}):\E{Curr}){\append}\E{Globs})) \\
                       {} \sep \E{Globs}\not\doteq{\emptylist} \sep P 
               \end{array}\right\}\\
                \js{x = e}\\
                \left\{\begin{array}{l}
                        \recstore_{\ls}((\E{Emps}) , (\E{Locs}{\append}((\js{x}=\E{Var}'):\E{Curr}){\append}\E{Globs})) \\
                        {} \sep \E{Globs}\not\doteq{\emptylist} \sep Q \sep \rv\doteq\E{V}
                \end{array}\right\}\\
        \end{array}
         }\]
        \begin{proof} The proof follows directly from the assignment and the definition of \recstore. \end{proof}
\end{lemma}

Notice that Lemma~\ref{lem:recstore:destricvarupdate} does not permit us to
update variables in the global portion of the abstract variable store with the
results of potentially destructive expressions. This is for the same reason as
the corresponding restriction on the \store predicate in
the previous Section. There is a corner case which would
lead to very unexpected behaviour. At this level of abstraction however, we
have an advantage: we can be sure that the more local abstract scope frames
were constructed in a more principled way, and so we are able to reason about
updating them with destructive expressions using
Lemma~\ref{lem:recstore:destricvarupdate}.





\end{document}
