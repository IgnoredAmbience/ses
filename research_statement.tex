\documentclass[a4paper]{article}
\usepackage{fullpage, titling, amsmath, footnote, listings}
\usepackage{hyperref}
\makesavenoteenv{tabular}
\setlength{\droptitle}{-50pt}

\begin{document}

\section{Research interests}
\begin{itemize}
\item Software verification/reasoning
\item Automated software testing / test generation
\item Programming language theory
\end{itemize}
With a particular focus on:
\begin{itemize}
\item JavaScript / web technologies
\item Security properties of programming languages/software
\end{itemize}

\subsection{JavaScript Background}
Whilst JavaScript was once a small language for mere form validation on web
pages, the growth of the internet in the pasdecade has pushed the web-browser
and the language forward to be one of the most widely-deployed languages.
Its large deployment has led developers to target the language and the web as a
platform on which to build their software. % More here?

JavaScript was conceived with some unusual semantics for object structure, which
can easily trip even those experienced with
using the language into producing software that is vulnerable to attack under
certain conditions.

Another unusual aspect of JavaScript is that there are multiple competing
implementations of the language, each with a significant share of the end users.
JavaScript is an interpreted language, so the behaviour of a program written in
the language is determined by the language specification, but also
the particular implementation of the language on which the software is
run.

JavaScript's specification is large and complex, it is common for
different implementations of the language to be incorrect against the
specification, or to interpret the specification in subtly different ways.
Although this is very unlikely to happen for the language's core functionality,
it is a regular occurrence for bugs to be detected in the lesser used `corners'
of the language. This may seem a small or insignificant issue, but
deviations from the specification or differences in behaviour between
implementations is an oft-used attack vector for malicious parties.

The JsCert project, joint between Imperial and INRIA, are in the process of
producing an executable formal semantics for the (current) ECMAScript 5.1
specification of the JavaScript language.
The construction of these semantics is designed to support future tools for
reasoning about and assisting developers to work with JavaScript.

I detail two projects of interest to me that make use of the JsCert semantics in
my fields of interest.

\subsection{Semantically-guided Language Test Suite Generation}
Many popular programming languages are developed without formal specifications,
instead using a mixture of 3 ways: by a specification written in English,
through a canonical implementation, or through a test suite of code examples and
expected behaviours.

To address the issue of non-conformant implementations, JavaScript has recently
moved to supplement its specification with a test suite. The test suite
currently comprises of around 10,000 tests, which notionally cover the entirety
of the specification. However, as the suite is largely handwritten, it suffers
from the common incompleteness problem due to lack of inspiration of failure
cases. Indeed, a number of bug reports are currently open, noting potentially
poor test coverage of a number of parts of the specification.

Furthermore, since the JavaScript specification is not machine-readable, the
test suite developers have no means of verification of the test suite's
completeness against the specification. One proposed solution is to use the
coverage of implementations as a measure of coverage of the specification, but
this is likely to produce spurious results. The group developing the test suite
recognise that the specification coverage problem is likely to be worthy of
academic interest\footnote{\url{https://bugs.ecmascript.org/show_bug.cgi?id=56}}.

Given an executable specification of the language, it would be possible to run
the tests directly against the specification and hence estimate the proportion
of the language that the test cover, and highlight any portions of the spec
that should be considered more carefully.

Secondly, is it possible to automatically produce new, interesting test cases
for the language from the formal specification, and can these new tests tell us
anything new about the language? % More needed here, too!

% Suitable? {
One notable automated testing method for compilers and interpreters is
\emph{fuzzing}, production of random test data (often syntactically directed by
a grammar, or dictionary), in attempt to trigger a crash condition. The
\texttt{jsfunfuzz} tool, produced by Mozilla, is one particularly successful
fuzzer for the JavaScript language. The purpose of the tool is mainly to find
crash-causing bugs in the interpreter, however it is also used to check
implementation correctness by comparing test results with another implementation.
% }
% Other methods include passing code through a compile/decompile cycle. Also
% used for perf testing implementation improvements.

% Appropriate? (to name my second reference)
One previous effort towards semantic test generation was Allwood and Eisenbach's
``Tickling Java with a Feather'' 2008 paper, in which initial attempts at test
generation for Java were reported. This paper led to REACTOR, a prize-winning
undergraduate 3rd year project of 2008/9. These projects show that the basis for
this approach is reasonable, both left the generation of tests with direct
reference to a formal language specification as an open problem.
% I've failed to find any later references to similar projects
% Note: This was Azalea's UG Group Project

\subsection{Safe Sandboxing of Untrusted JavaScript Code}
An interesting result of the tight integration of JavaScript code and the web is
that code and data can be combined from many different sources. This results in
situations where code written by the developer of a particular webpage relies
upon code from lesser or untrusted third-parties. A common example of this is
the inclusion of advertising banners on webpages, a less common but more
interesting use-case is the execution of user-provided code within a web
application.

JavaScript is a notoriously hard language to secure against untrusted code,
because a large portion of the language's primitives are mutable, function aliasing
(especially of the \texttt{eval} function, and other primitives), and a tendency
to leak pointers to the global object (from which most other objects can be
reached) made JavaScript versions prior to the latest specification impossible
to secure against malicious code. Recent additions to the
language primitives to properly support sandboxing implementations have
simplified this impossible problem to just a \emph{very difficult} one.

As part of their Caja project, Google have (loosely) specified the Secure
ECMAScript (SES) variant of JavaScript to provide sandboxing primitives that
permit controlled interaction between trusted and untrusted code.

My masters' thesis project is examining the additions required to a JavaScript
program verification logic to additionally support reasoning about the security
implications of interactions across the sandbox boundary.

% Is Mark representative of Google as a whole? :D
% The stuff below also exists, now. Probably needs a tense change.
Google have lofty ambitions for the future of the SES language, producing it as
one ideal view for the future of programming in the browser. When
tightly-coupled with a communication layer, the concept of a distributed object
capability language becomes a possibility. Such a language permits the
implementation of interesting algorithms such as multi-party mutually-suspicious
escrow exchange, or contract agreement (where the contract may be executable
code).

Verification of these types of algorithms is a new, interesting problem, as
their proofs will possibly involve several verification techniques that are
currently rarely used together. For example a process calculus for the
distributed reasoning, combined with higher-order reasoning for contract
agreement, and some means of representing a transferable notion of a user's
`trust' in other parties participating in the transaction.
% tentative? not descriptive enough?

The implementation of SES as a layer on top of JavaScript also poses its own
interesting problems. SES inherently depends upon the JavaScript specification
to work, but the JavaScript specification process is also directed with
maintaining the invariants required to enable SES to be implemented securely.
(These invariants are usually very subtle, such as ensuring that the
language-defined data structures and primitives do not inadvertently allow for
pointer leakage or covert channels of communication within the language.)
% Where am I going with this?

\section{Relevant experience}
Work on automatic regression test generation for a duck-typed language (third
year group project)

Research into SES, a secure subset of the JavaScript language, development of
  a program logic capable of proving desired security properties of programs
  written in SES / object-capability style languages.

\section{Funding}
I am seeking a studentship with the department, I am unable to self-fund.
\end{document}


